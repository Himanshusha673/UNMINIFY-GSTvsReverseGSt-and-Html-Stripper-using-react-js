{"ast":null,"code":"'use strict';\n\nconst reducer = require('shift-reducer');\nconst Shift = require('shift-ast/checked');\nconst shiftScope = require('shift-scope');\nconst getParents = require('../../helpers/parents');\nconst none = {};\nfunction constantToNode(c) {\n  switch (typeof c) {\n    case 'undefined':\n      return new Shift.UnaryExpression({\n        operator: 'void',\n        operand: new Shift.LiteralNumericExpression({\n          value: 0\n        })\n      });\n    case 'number':\n      return new Shift.LiteralNumericExpression({\n        value: c\n      });\n    case 'string':\n      return new Shift.LiteralStringExpression({\n        value: c\n      });\n    case 'boolean':\n      return new Shift.LiteralBooleanExpression({\n        value: c\n      });\n    case 'object':\n      if (Array.isArray(c)) {\n        const elements = c.map(constantToNode);\n        return new Shift.ArrayExpression({\n          elements\n        });\n      }\n    // falls through\n    default:\n      throw new Error('cannot handle ' + typeof c);\n  }\n}\nconst globalFunctions = {\n  decodeURI,\n  decodeURIComponent,\n  unescape,\n  parseInt,\n  parseFloat\n};\nconst isNonMutatingArrayMethod = p => ['slice', 'forEach', 'map', 'filter', 'reduce', 'indexOf'].includes(p);\nmodule.exports = function partialEvaluate(ast) {\n  const parents = getParents(ast);\n  const globalScope = shiftScope.default(ast);\n  const lookup = new shiftScope.ScopeLookup(globalScope);\n  function getStaticInit(node) {\n    // This is unsafe in that it assumes no use-before-def\n    const vs = lookup.lookup(node);\n    if (vs && vs.length === 1) {\n      const v = vs[0];\n      if (v.declarations.length === 1) {\n        const binding = v.declarations[0].node;\n        const parent = parents.get(binding);\n        if (parent.type === 'VariableDeclarator' && parent.init !== null && v.references.every(r => !(r.accessibility.isWrite && r.node !== binding))) {\n          return {\n            initNode: parent.init,\n            variable: v\n          };\n        }\n      }\n    }\n    return {\n      initNode: null\n    };\n  }\n  function evaluateToNode(node) {\n    const value = evaluate(node);\n    if (value !== none && (typeof value !== 'object' || value === null) && typeof value !== 'function') {\n      const rv = constantToNode(value);\n      if (rv.type === 'UnaryExpression' && rv.type === node.type && rv.operator === 'void' && rv.operator === node.operator && rv.operand.type === 'LiteralNumericExpression' && rv.operand.type === node.operand.type && rv.operand.value === node.operand.value) {\n        return node;\n      }\n      return rv;\n    }\n    return node;\n  }\n  const seen = new WeakMap();\n  function evaluate(node) {\n    if (seen.has(node)) {\n      return seen.get(node);\n    }\n    seen.set(node, none);\n    const out = evaluateCore(node);\n    if (out !== none) {\n      seen.set(node, out);\n    }\n    return out;\n  }\n  function evaluateCore(node) {\n    switch (node.type) {\n      case 'ArrayExpression':\n        {\n          const evaluated = node.elements.map(e => e === null ? void 0 : evaluate(e));\n          if (evaluated.every(v => v !== none)) {\n            return evaluated;\n          }\n          break;\n        }\n      case 'LiteralNumericExpression':\n      case 'LiteralStringExpression':\n      case 'LiteralBooleanExpression':\n        return node.value;\n      case 'LiteralRegExpExpression':\n        // Not actually safe, since regexps have identity\n        if (!node.global && !node.ignoreCase && !node.multiLine && !node.sticky && !node.unicode) {\n          return new RegExp(node.pattern);\n        }\n        break;\n      case 'UnaryExpression':\n        {\n          const operand = evaluate(node.operand);\n          if (operand !== none) {\n            switch (node.operator) {\n              case '+':\n                return +operand;\n              case 'void':\n                return void 0;\n              case '-':\n                return -operand;\n              case '!':\n                return !operand;\n              case '~':\n                return ~operand;\n              case 'typeof':\n                return typeof operand;\n              default:\n                throw new Error('useful unary operator: ' + node.operator + ' ' + operand);\n            }\n          }\n          break;\n        }\n      case 'BinaryExpression':\n        {\n          const left = evaluate(node.left);\n          const right = evaluate(node.right);\n          if (left !== none && right !== none) {\n            switch (node.operator) {\n              case '===':\n                return left === right;\n              case '!==':\n                return left !== right;\n              case '==':\n                // eslint-disable-next-line eqeqeq\n                return left == right;\n              case '!=':\n                // eslint-disable-next-line eqeqeq\n                return left != right;\n              case '>':\n                return left > right;\n              case '<':\n                return left < right;\n              case '>=':\n                return left >= right;\n              case '<=':\n                return left <= right;\n              case '+':\n                return left + right;\n              case '-':\n                return left - right;\n              case '*':\n                return left * right;\n              case '/':\n                return left / right;\n              case '%':\n                return left % right;\n              case '||':\n                return left || right;\n              case '&&':\n                return left && right;\n              case '<<':\n                return left << right;\n              case '>>':\n                return left >> right;\n              case '>>>':\n                return left >>> right;\n              case '|':\n                return left | right;\n              case '&':\n                return left & right;\n              case '^':\n                return left ^ right;\n              case 'in':\n                // If this happens, something may have gone wrong.\n                break;\n              default:\n                throw new Error('useful binary operator: ' + node.operator + ' ' + left + ' ' + right);\n            }\n          }\n          break;\n        }\n      case 'IdentifierExpression':\n        {\n          if (node.name in globalFunctions) {\n            const vs = lookup.lookup(node);\n            if (vs.length === 1) {\n              const refs = vs[0].references;\n              if (vs[0].declarations.length === 0 && !refs.some(r => r.accessibility.isWrite)) {\n                return globalFunctions[node.name];\n              }\n            }\n          }\n\n          // TODO this isn't actually safe, for several reasons\n          const {\n            initNode,\n            variable\n          } = getStaticInit(node);\n          if (initNode !== null) {\n            const val = evaluate(initNode);\n            if (val !== none) {\n              if (Array.isArray(val)) {\n                for (let r of variable.references) {\n                  let p = parents.get(r.node);\n                  if (p.type === 'StaticMemberExpression') {\n                    if (!(isNonMutatingArrayMethod(p.property) || p.property === 'length')) {\n                      return none;\n                    }\n                  } else if (p.type === 'StaticMemberAssignmentTarget' || p.type === 'ComputedMemberAssignmentTarget') {\n                    return none;\n                  } else if (p.type === 'ComputedMemberExpression') {\n                    const gp = parents.get(p);\n                    if (gp.type === 'CallExpression' && gp.callee === p) {\n                      return none;\n                    }\n                  }\n                }\n              }\n              return val;\n            }\n          }\n          break;\n        }\n      case 'CallExpression':\n        {\n          // TODO factor these cases better\n          const argVals = node.arguments.map(evaluate);\n          if (argVals.every(v => v !== none)) {\n            if (node.callee.type === 'StaticMemberExpression') {\n              // TODO factor this and similar cases out to something else\n              if (node.callee.object.type === 'IdentifierExpression' && node.callee.object.name === 'String' && node.callee.property === 'fromCharCode' && node.arguments.length === 1 && node.arguments[0].type === 'LiteralNumericExpression') {\n                return String.fromCharCode(node.arguments[0].value);\n              }\n              const objVal = evaluate(node.callee.object);\n              if (objVal !== none) {\n                if (typeof objVal !== 'object') {\n                  if (typeof objVal !== 'function') {\n                    return objVal[node.callee.property](...argVals);\n                  }\n                } else if (Array.isArray(objVal) && isNonMutatingArrayMethod(node.callee.property)) {\n                  return objVal[node.callee.property](...argVals);\n                }\n              }\n            }\n            const calleeVal = evaluate(node.callee);\n            if (typeof calleeVal === 'function') {\n              let c = calleeVal(...argVals);\n              return c;\n            }\n          }\n          break;\n        }\n      case 'StaticMemberExpression':\n        {\n          if (node.property === 'length' && node.object.type === 'ArrayExpression') {\n            return node.object.elements.length;\n          }\n          return evaluateStaticProperty(node.object, node.property);\n        }\n    }\n    return none;\n  }\n  function evaluateStaticProperty(object, property) {\n    // TODO this has a lot of overlap with inline.js\n    // this interacts poorly with getters\n    const objVal = evaluate(object);\n    if (objVal !== none && typeof objVal !== 'object' && typeof objVal !== 'function') {\n      if (property in Object(objVal)) {\n        return objVal[property];\n      }\n      return none;\n    }\n    if (object.type === 'IdentifierExpression') {\n      const {\n        initNode,\n        variable\n      } = getStaticInit(object); // TODO this is not sufficient; we also need to check it doesn't leak\n      if (initNode !== null) {\n        const leaks = variable.references.some(r => {\n          if (r.accessibility.isRead) {\n            const parent = parents.get(r.node);\n            return parent.type !== 'StaticMemberExpression' && parent.type !== 'ComputedMemberAssignmentTarget' && parent.type !== 'StaticMemberAssignmentTarget' && parent.type !== 'ComputedMemberAssignmentTarget';\n          }\n          return false;\n        });\n        if (!leaks && (initNode.type === 'FunctionExpression' || initNode.type === 'ObjectExpression' && initNode.properties.every(p => p.type === 'DataProperty' && p.name.type === 'StaticPropertyName'))) {\n          const hasComputedWrite = variable.references.some(r => {\n            const parent = parents.get(r.node);\n            return parent.type === 'ComputedMemberAssignmentTarget' && parent.object === r.node;\n          });\n          if (!hasComputedWrite) {\n            const hasProperty = initNode.type === 'ObjectExpression' && initNode.properties.filter(p => p.name.value === property).length === 1;\n            const propertyWrites = variable.references.filter(r => {\n              const parent = parents.get(r.node);\n              return parent.type === 'StaticMemberAssignmentTarget' && parent.property === property;\n            });\n            if (!hasProperty && propertyWrites.length === 1) {\n              const gp = parents.get(parents.get(propertyWrites[0].node));\n              if (gp.type === 'AssignmentExpression') {\n                return evaluate(gp.expression);\n              }\n            } else if (hasProperty && propertyWrites.length === 0) {\n              for (let p of initNode.properties) {\n                if (p.name.value === property) {\n                  return evaluate(p.expression);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return none;\n  }\n  class Evaluate extends reducer.LazyCloneReducer {\n    reduceUnaryExpression(node, {\n      operand\n    }) {\n      return evaluateToNode(super.reduceUnaryExpression(node, {\n        operand\n      }));\n    }\n    reduceBinaryExpression(node, {\n      left,\n      right\n    }) {\n      return evaluateToNode(super.reduceBinaryExpression(node, {\n        left,\n        right\n      }));\n    }\n    reduceCallExpression(node, {\n      callee,\n      arguments: _arguments\n    }) {\n      return evaluateToNode(super.reduceCallExpression(node, {\n        callee,\n        arguments: _arguments\n      }));\n    }\n    reduceStaticMemberExpression(node, {\n      object\n    }) {\n      return evaluateToNode(super.reduceStaticMemberExpression(node, {\n        object\n      }));\n    }\n    reduceIdentifierExpression(node) {\n      return evaluateToNode(node);\n    }\n    reduceComputedMemberExpression(node, {\n      object,\n      expression\n    }) {\n      const clone = super.reduceComputedMemberExpression(node, {\n        object,\n        expression\n      });\n      const parent = parents.get(node);\n      if (parent.type !== 'CallExpression' || parent.callee !== node) {\n        if (object.type === 'ArrayExpression' || object.type === 'LiteralStringExpression') {\n          const isArray = object.type === 'ArrayExpression';\n          const index = evaluate(expression);\n          if (index !== none) {\n            if (index === 'length') {\n              return constantToNode((isArray ? object.elements : object.value).length);\n            }\n            const coerced = +('' + index);\n            if (!Number.isNaN(coerced) && Math.floor(coerced) === coerced && coerced.toString() === '' + index) {\n              if (coerced >= (isArray ? object.elements : object.value).length) {\n                return constantToNode(void 0);\n              }\n              return isArray ? object.elements[index] : constantToNode(object.value[index]);\n            }\n          }\n        }\n      }\n      return clone;\n    }\n    reduceConditionalExpression(node, {\n      test,\n      consequent,\n      alternate\n    }) {\n      const clone = super.reduceConditionalExpression(node, {\n        test,\n        consequent,\n        alternate\n      });\n      const testValue = evaluate(clone.test);\n      if (testValue !== none) {\n        return testValue ? consequent : alternate;\n      }\n      return clone;\n    }\n    reduceIfStatement(node, {\n      test,\n      consequent,\n      alternate\n    }) {\n      // Note: this needs to pull var declarations out of the untaken branch\n      const clone = super.reduceIfStatement(node, {\n        test,\n        consequent,\n        alternate\n      });\n      const testValue = evaluate(clone.test);\n      if (testValue !== none) {\n        if (testValue) {\n          return consequent;\n        }\n        if (alternate === null) {\n          return new Shift.EmptyStatement();\n        }\n        return alternate;\n      }\n      return clone;\n    }\n  }\n  return reducer.default(new Evaluate(), ast);\n};","map":{"version":3,"names":["reducer","require","Shift","shiftScope","getParents","none","constantToNode","c","UnaryExpression","operator","operand","LiteralNumericExpression","value","LiteralStringExpression","LiteralBooleanExpression","Array","isArray","elements","map","ArrayExpression","Error","globalFunctions","decodeURI","decodeURIComponent","unescape","parseInt","parseFloat","isNonMutatingArrayMethod","p","includes","module","exports","partialEvaluate","ast","parents","globalScope","default","lookup","ScopeLookup","getStaticInit","node","vs","length","v","declarations","binding","parent","get","type","init","references","every","r","accessibility","isWrite","initNode","variable","evaluateToNode","evaluate","rv","seen","WeakMap","has","set","out","evaluateCore","evaluated","e","global","ignoreCase","multiLine","sticky","unicode","RegExp","pattern","left","right","name","refs","some","val","property","gp","callee","argVals","arguments","object","String","fromCharCode","objVal","calleeVal","evaluateStaticProperty","Object","leaks","isRead","properties","hasComputedWrite","hasProperty","filter","propertyWrites","expression","Evaluate","LazyCloneReducer","reduceUnaryExpression","reduceBinaryExpression","reduceCallExpression","_arguments","reduceStaticMemberExpression","reduceIdentifierExpression","reduceComputedMemberExpression","clone","index","coerced","Number","isNaN","Math","floor","toString","reduceConditionalExpression","test","consequent","alternate","testValue","reduceIfStatement","EmptyStatement"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/unminify/src/transforms/wildly-unsafe/partial-evaluate.js"],"sourcesContent":["'use strict';\n\nconst reducer = require('shift-reducer');\nconst Shift = require('shift-ast/checked');\nconst shiftScope = require('shift-scope');\n\nconst getParents = require('../../helpers/parents');\n\nconst none = {};\n\nfunction constantToNode(c) {\n  switch (typeof c) {\n    case 'undefined':\n      return new Shift.UnaryExpression({ operator: 'void', operand: new Shift.LiteralNumericExpression({ value: 0 }) });\n    case 'number':\n      return new Shift.LiteralNumericExpression({ value: c });\n    case 'string':\n      return new Shift.LiteralStringExpression({ value: c });\n    case 'boolean':\n      return new Shift.LiteralBooleanExpression({ value: c });\n    case 'object':\n      if (Array.isArray(c)) {\n        const elements = c.map(constantToNode);\n        return new Shift.ArrayExpression({ elements });\n      }\n      // falls through\n    default:\n      throw new Error('cannot handle ' + typeof c);\n  }\n}\n\nconst globalFunctions = {\n  decodeURI,\n  decodeURIComponent,\n  unescape,\n  parseInt,\n  parseFloat,\n};\n\nconst isNonMutatingArrayMethod = p => ['slice', 'forEach', 'map', 'filter', 'reduce', 'indexOf'].includes(p);\n\nmodule.exports = function partialEvaluate(ast) {\n\n  const parents = getParents(ast);\n  const globalScope = shiftScope.default(ast);\n  const lookup = new shiftScope.ScopeLookup(globalScope);\n\n  function getStaticInit(node) {\n    // This is unsafe in that it assumes no use-before-def\n    const vs = lookup.lookup(node);\n    if (vs && vs.length === 1) {\n      const v = vs[0];\n      if (v.declarations.length === 1) {\n        const binding = v.declarations[0].node;\n        const parent = parents.get(binding);\n        if (parent.type === 'VariableDeclarator' && parent.init !== null && v.references.every(r => !(r.accessibility.isWrite && r.node !== binding))) {\n          return { initNode: parent.init, variable: v };\n        }\n      }\n    }\n    return { initNode: null };\n  }\n\n  function evaluateToNode(node) {\n    const value = evaluate(node);\n    if (value !== none && (typeof value !== 'object' || value === null) && typeof value !== 'function') {\n      const rv = constantToNode(value);\n      if (rv.type === 'UnaryExpression' && rv.type === node.type && rv.operator === 'void' && rv.operator === node.operator && rv.operand.type === 'LiteralNumericExpression' && rv.operand.type === node.operand.type && rv.operand.value === node.operand.value) {\n        return node;\n      }\n      return rv;\n    }\n    return node;\n  }\n\n\n  const seen = new WeakMap;\n  function evaluate(node) {\n    if (seen.has(node)) {\n      return seen.get(node);\n    }\n    seen.set(node, none);\n    const out = evaluateCore(node);\n    if (out !== none) {\n      seen.set(node, out);\n    }\n    return out;\n  }\n  function evaluateCore(node) {\n    switch (node.type) {\n      case 'ArrayExpression': {\n        const evaluated = node.elements.map(e => e === null ? void 0 : evaluate(e));\n        if (evaluated.every(v => v !== none)) {\n          return evaluated;\n        }\n        break;\n      }\n      case 'LiteralNumericExpression':\n      case 'LiteralStringExpression':\n      case 'LiteralBooleanExpression':\n        return node.value;\n      case 'LiteralRegExpExpression':\n        // Not actually safe, since regexps have identity\n        if (!node.global && !node.ignoreCase && !node.multiLine && !node.sticky && !node.unicode) {\n          return new RegExp(node.pattern);\n        }\n        break;\n      case 'UnaryExpression': {\n        const operand = evaluate(node.operand);\n        if (operand !== none) {\n          switch (node.operator) {\n            case '+':\n              return +operand;\n            case 'void':\n              return void 0;\n            case '-':\n              return -operand;\n            case '!':\n              return !operand;\n            case '~':\n              return ~operand;\n            case 'typeof':\n              return typeof operand;\n            default:\n              throw new Error('useful unary operator: ' + node.operator + ' ' + operand);\n          }\n        }\n        break;\n      }\n      case 'BinaryExpression': {\n        const left = evaluate(node.left);\n        const right = evaluate(node.right);\n        if (left !== none && right !== none) {\n          switch (node.operator) {\n            case '===':\n              return left === right;\n            case '!==':\n              return left !== right;\n            case '==':\n              // eslint-disable-next-line eqeqeq\n              return left == right;\n            case '!=':\n              // eslint-disable-next-line eqeqeq\n              return left != right;\n            case '>':\n              return left > right;\n            case '<':\n              return left < right;\n            case '>=':\n              return left >= right;\n            case '<=':\n              return left <= right;\n            case '+':\n              return left + right;\n            case '-':\n              return left - right;\n            case '*':\n              return left * right;\n            case '/':\n              return left / right;\n            case '%':\n              return left % right;\n            case '||':\n              return left || right;\n            case '&&':\n              return left && right;\n            case '<<':\n              return left << right;\n            case '>>':\n              return left >> right;\n            case '>>>':\n              return left >>> right;\n            case '|':\n              return left | right;\n            case '&':\n              return left & right;\n            case '^':\n              return left ^ right;\n            case 'in':\n              // If this happens, something may have gone wrong.\n              break;\n            default:\n              throw new Error('useful binary operator: ' + node.operator + ' ' + left + ' ' + right);\n          }\n        }\n        break;\n      }\n      case 'IdentifierExpression': {\n        if (node.name in globalFunctions) {\n          const vs = lookup.lookup(node);\n          if (vs.length === 1) {\n            const refs = vs[0].references;\n            if (vs[0].declarations.length === 0 && !refs.some(r => r.accessibility.isWrite)) {\n              return globalFunctions[node.name];\n            }\n          }\n        }\n\n        // TODO this isn't actually safe, for several reasons\n        const { initNode, variable } = getStaticInit(node);\n        if (initNode !== null) {\n          const val = evaluate(initNode);\n          if (val !== none) {\n            if (Array.isArray(val)) {\n              for (let r of variable.references) {\n                let p = parents.get(r.node);\n                if (p.type === 'StaticMemberExpression') {\n                  if (!(isNonMutatingArrayMethod(p.property) || p.property === 'length')) {\n                    return none;\n                  }\n                } else if (p.type === 'StaticMemberAssignmentTarget' || p.type === 'ComputedMemberAssignmentTarget') {\n                  return none;\n                } else if (p.type === 'ComputedMemberExpression') {\n                  const gp = parents.get(p);\n                  if (gp.type === 'CallExpression' && gp.callee === p) {\n                    return none;\n                  }\n                }\n              }\n            }\n            return val;\n          }\n        }\n        break;\n      }\n      case 'CallExpression': {\n        // TODO factor these cases better\n        const argVals = node.arguments.map(evaluate);\n        if (argVals.every(v => v !== none)) {\n          if (node.callee.type === 'StaticMemberExpression') {\n\n            // TODO factor this and similar cases out to something else\n            if (node.callee.object.type === 'IdentifierExpression' && node.callee.object.name === 'String' && node.callee.property === 'fromCharCode' && node.arguments.length === 1 && node.arguments[0].type === 'LiteralNumericExpression') {\n              return String.fromCharCode(node.arguments[0].value);\n            }\n\n\n            const objVal = evaluate(node.callee.object);\n            if (objVal !== none) {\n              if (typeof objVal !== 'object') {\n                if (typeof objVal !== 'function') {\n                  return objVal[node.callee.property](...argVals);\n                }\n              } else if (Array.isArray(objVal) && isNonMutatingArrayMethod(node.callee.property)) {\n                return objVal[node.callee.property](...argVals);\n              }\n            }\n          }\n\n          const calleeVal = evaluate(node.callee);\n          if (typeof calleeVal === 'function') {\n            let c = calleeVal(...argVals);\n            return c;\n          }\n        }\n        break;\n      }\n      case 'StaticMemberExpression': {\n        if (node.property === 'length' && node.object.type === 'ArrayExpression') {\n          return node.object.elements.length;\n        }\n        return evaluateStaticProperty(node.object, node.property);\n      }\n    }\n    return none;\n  }\n\n  function evaluateStaticProperty(object, property) {\n    // TODO this has a lot of overlap with inline.js\n    // this interacts poorly with getters\n    const objVal = evaluate(object);\n    if (objVal !== none && typeof objVal !== 'object' && typeof objVal !== 'function') {\n      if (property in Object(objVal)) {\n        return objVal[property];\n      }\n      return none;\n    }\n    if (object.type === 'IdentifierExpression') {\n      const { initNode, variable } = getStaticInit(object); // TODO this is not sufficient; we also need to check it doesn't leak\n      if (initNode !== null) {\n        const leaks = variable.references.some(r => {\n          if (r.accessibility.isRead) {\n            const parent = parents.get(r.node);\n            return parent.type !== 'StaticMemberExpression' && parent.type !== 'ComputedMemberAssignmentTarget' && parent.type !== 'StaticMemberAssignmentTarget' && parent.type !== 'ComputedMemberAssignmentTarget';\n          }\n          return false;\n        });\n        if (!leaks && (initNode.type === 'FunctionExpression' || initNode.type === 'ObjectExpression' && initNode.properties.every(p => p.type === 'DataProperty' && p.name.type === 'StaticPropertyName'))) {\n          const hasComputedWrite = variable.references.some(r => {\n            const parent = parents.get(r.node);\n            return parent.type === 'ComputedMemberAssignmentTarget' && parent.object === r.node;\n          });\n          if (!hasComputedWrite) {\n            const hasProperty = initNode.type === 'ObjectExpression' && initNode.properties.filter(p => p.name.value === property).length === 1;\n            const propertyWrites = variable.references.filter(r => {\n              const parent = parents.get(r.node);\n              return parent.type === 'StaticMemberAssignmentTarget' && parent.property === property;\n            });\n            if (!hasProperty && propertyWrites.length === 1) {\n              const gp = parents.get(parents.get(propertyWrites[0].node));\n              if (gp.type === 'AssignmentExpression') {\n                return evaluate(gp.expression);\n              }\n            } else if (hasProperty && propertyWrites.length === 0) {\n              for (let p of initNode.properties) {\n                if (p.name.value === property) {\n                  return evaluate(p.expression);\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    return none;\n  }\n\n  class Evaluate extends reducer.LazyCloneReducer {\n    reduceUnaryExpression(node, { operand }) {\n      return evaluateToNode(super.reduceUnaryExpression(node, { operand }));\n    }\n\n    reduceBinaryExpression(node, { left, right }) {\n      return evaluateToNode(super.reduceBinaryExpression(node, { left, right }));\n    }\n\n    reduceCallExpression(node, { callee, arguments: _arguments }) {\n      return evaluateToNode(super.reduceCallExpression(node, { callee, arguments: _arguments }));\n    }\n\n    reduceStaticMemberExpression(node, { object }) {\n      return evaluateToNode(super.reduceStaticMemberExpression(node, { object }));\n    }\n\n    reduceIdentifierExpression(node) {\n      return evaluateToNode(node);\n    }\n\n    reduceComputedMemberExpression(node, { object, expression }) {\n      const clone = super.reduceComputedMemberExpression(node, { object, expression });\n      const parent = parents.get(node);\n      if (parent.type !== 'CallExpression' || parent.callee !== node) {\n        if (object.type === 'ArrayExpression' || object.type === 'LiteralStringExpression') {\n          const isArray = object.type === 'ArrayExpression';\n          const index = evaluate(expression);\n          if (index !== none) {\n            if (index === 'length') {\n              return constantToNode((isArray ? object.elements : object.value).length);\n            }\n            const coerced = +('' + index);\n            if (!Number.isNaN(coerced) && Math.floor(coerced) === coerced && coerced.toString() === '' + index) {\n              if (coerced >= (isArray ? object.elements : object.value).length) {\n                return constantToNode(void 0);\n              }\n              return isArray ? object.elements[index] : constantToNode(object.value[index]);\n            }\n          }\n        }\n      }\n      return clone;\n    }\n\n    reduceConditionalExpression(node, { test, consequent, alternate }) {\n      const clone = super.reduceConditionalExpression(node, { test, consequent, alternate });\n      const testValue = evaluate(clone.test);\n      if (testValue !== none) {\n        return testValue ? consequent : alternate;\n      }\n      return clone;\n    }\n\n    reduceIfStatement(node, { test, consequent, alternate }) {\n      // Note: this needs to pull var declarations out of the untaken branch\n      const clone = super.reduceIfStatement(node, { test, consequent, alternate });\n      const testValue = evaluate(clone.test);\n      if (testValue !== none) {\n        if (testValue) {\n          return consequent;\n        }\n        if (alternate === null) {\n          return new Shift.EmptyStatement;\n        }\n        return alternate;\n\n\n      }\n      return clone;\n    }\n  }\n\n  return reducer.default(new Evaluate, ast);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}