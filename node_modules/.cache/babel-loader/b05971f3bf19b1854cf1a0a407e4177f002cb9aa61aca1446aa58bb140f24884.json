{"ast":null,"code":"const objectAssign = require('object-assign');\nconst {\n  keyword\n} = require('esutils');\nconst {\n  Precedence,\n  getPrecedence,\n  escapeStringLiteral,\n  Empty,\n  Token,\n  RawToken,\n  NumberCodeRep,\n  Paren,\n  Bracket,\n  Brace,\n  NoIn,\n  ContainsIn,\n  Seq,\n  Semi,\n  CommaSep,\n  SemiOp\n} = require('./coderep');\nfunction p(node, precedence, a) {\n  return getPrecedence(node) < precedence ? paren(a) : a;\n}\nfunction t(token, isRegExp = false) {\n  return new Token(token, isRegExp);\n}\nfunction paren(rep) {\n  return new Paren(rep);\n}\nfunction brace(rep) {\n  return new Brace(rep);\n}\nfunction bracket(rep) {\n  return new Bracket(rep);\n}\nfunction noIn(rep) {\n  return new NoIn(rep);\n}\nfunction markContainsIn(state) {\n  return state.containsIn ? new ContainsIn(state) : state;\n}\nfunction seq(...reps) {\n  return new Seq(reps);\n}\nfunction semi() {\n  return new Semi();\n}\nfunction semiOp() {\n  return new SemiOp();\n}\nfunction empty() {\n  return new Empty();\n}\nfunction commaSep(pieces) {\n  return new CommaSep(pieces);\n}\nfunction getAssignmentExpr(state) {\n  return state ? state.containsGroup ? paren(state) : state : empty();\n}\nclass MinimalCodeGen {\n  parenToAvoidBeingDirective(element, original) {\n    if (element && element.type === 'ExpressionStatement' && element.expression.type === 'LiteralStringExpression') {\n      return seq(paren(original.children[0]), semiOp());\n    }\n    return original;\n  }\n  regenerateArrowParams(element, original) {\n    if (element.rest == null && element.items.length === 1 && element.items[0].type === 'BindingIdentifier') {\n      // FormalParameters unconditionally include parentheses, but they're not necessary here\n      return this.reduceBindingIdentifier(element.items[0]);\n    }\n    return original;\n  }\n  reduceArrayExpression(node, {\n    elements\n  }) {\n    if (elements.length === 0) {\n      return bracket(empty());\n    }\n    let content = commaSep(elements.map(getAssignmentExpr));\n    if (elements.length > 0 && elements[elements.length - 1] == null) {\n      content = seq(content, t(','));\n    }\n    return bracket(content);\n  }\n  reduceAwaitExpression(node, {\n    expression\n  }) {\n    return seq(t('await'), p(node.expression, getPrecedence(node), expression));\n  }\n  reduceSpreadElement(node, {\n    expression\n  }) {\n    return seq(t('...'), p(node.expression, Precedence.Assignment, expression));\n  }\n  reduceSpreadProperty(node, {\n    expression\n  }) {\n    return seq(t('...'), getAssignmentExpr(expression));\n  }\n  reduceAssignmentExpression(node, {\n    binding,\n    expression\n  }) {\n    let leftCode = binding;\n    let rightCode = expression;\n    let containsIn = expression.containsIn;\n    let startsWithCurly = binding.startsWithCurly;\n    let startsWithLetSquareBracket = binding.startsWithLetSquareBracket;\n    let startsWithFunctionOrClass = binding.startsWithFunctionOrClass;\n    if (getPrecedence(node.expression) < getPrecedence(node)) {\n      rightCode = paren(rightCode);\n      containsIn = false;\n    }\n    return objectAssign(seq(leftCode, t('='), rightCode), {\n      containsIn,\n      startsWithCurly,\n      startsWithLetSquareBracket,\n      startsWithFunctionOrClass\n    });\n  }\n  reduceAssignmentTargetIdentifier(node) {\n    let a = t(node.name);\n    if (node.name === 'let') {\n      a.startsWithLet = true;\n    }\n    return a;\n  }\n  reduceAssignmentTargetWithDefault(node, {\n    binding,\n    init\n  }) {\n    return seq(binding, t('='), p(node.init, Precedence.Assignment, init));\n  }\n  reduceCompoundAssignmentExpression(node, {\n    binding,\n    expression\n  }) {\n    let leftCode = binding;\n    let rightCode = expression;\n    let containsIn = expression.containsIn;\n    let startsWithCurly = binding.startsWithCurly;\n    let startsWithLetSquareBracket = binding.startsWithLetSquareBracket;\n    let startsWithFunctionOrClass = binding.startsWithFunctionOrClass;\n    if (getPrecedence(node.expression) < getPrecedence(node)) {\n      rightCode = paren(rightCode);\n      containsIn = false;\n    }\n    return objectAssign(seq(leftCode, t(node.operator), rightCode), {\n      containsIn,\n      startsWithCurly,\n      startsWithLetSquareBracket,\n      startsWithFunctionOrClass\n    });\n  }\n  reduceBinaryExpression(node, {\n    left,\n    right\n  }) {\n    let leftCode = left;\n    let startsWithCurly = left.startsWithCurly;\n    let startsWithLetSquareBracket = left.startsWithLetSquareBracket;\n    let startsWithFunctionOrClass = left.startsWithFunctionOrClass;\n    let leftContainsIn = left.containsIn;\n    let isRightAssociative = node.operator === '**';\n    if (getPrecedence(node.left) < getPrecedence(node) || isRightAssociative && (getPrecedence(node.left) === getPrecedence(node) || node.left.type === 'UnaryExpression')) {\n      leftCode = paren(leftCode);\n      startsWithCurly = false;\n      startsWithLetSquareBracket = false;\n      startsWithFunctionOrClass = false;\n      leftContainsIn = false;\n    }\n    let rightCode = right;\n    let rightContainsIn = right.containsIn;\n    if (getPrecedence(node.right) < getPrecedence(node) || !isRightAssociative && getPrecedence(node.right) === getPrecedence(node)) {\n      rightCode = paren(rightCode);\n      rightContainsIn = false;\n    }\n    return objectAssign(seq(leftCode, t(node.operator), rightCode), {\n      containsIn: leftContainsIn || rightContainsIn || node.operator === 'in',\n      containsGroup: node.operator === ',',\n      startsWithCurly,\n      startsWithLetSquareBracket,\n      startsWithFunctionOrClass\n    });\n  }\n  reduceBindingWithDefault(node, {\n    binding,\n    init\n  }) {\n    return seq(binding, t('='), p(node.init, Precedence.Assignment, init));\n  }\n  reduceBindingIdentifier(node) {\n    let a = t(node.name);\n    if (node.name === 'let') {\n      a.startsWithLet = true;\n    }\n    return a;\n  }\n  reduceArrayAssignmentTarget(node, {\n    elements,\n    rest\n  }) {\n    let content;\n    if (elements.length === 0) {\n      content = rest == null ? empty() : seq(t('...'), rest);\n    } else {\n      elements = elements.concat(rest == null ? [] : [seq(t('...'), rest)]);\n      content = commaSep(elements.map(getAssignmentExpr));\n      if (elements.length > 0 && elements[elements.length - 1] == null) {\n        content = seq(content, t(','));\n      }\n    }\n    return bracket(content);\n  }\n  reduceArrayBinding(node, {\n    elements,\n    rest\n  }) {\n    let content;\n    if (elements.length === 0) {\n      content = rest == null ? empty() : seq(t('...'), rest);\n    } else {\n      elements = elements.concat(rest == null ? [] : [seq(t('...'), rest)]);\n      content = commaSep(elements.map(getAssignmentExpr));\n      if (elements.length > 0 && elements[elements.length - 1] == null) {\n        content = seq(content, t(','));\n      }\n    }\n    return bracket(content);\n  }\n  reduceObjectAssignmentTarget(node, {\n    properties,\n    rest\n  }) {\n    let content = commaSep(properties);\n    if (properties.length === 0) {\n      content = rest == null ? empty() : seq(t('...'), rest);\n    } else {\n      content = rest == null ? content : seq(content, t(','), t('...'), rest);\n    }\n    let state = brace(content);\n    state.startsWithCurly = true;\n    return state;\n  }\n  reduceObjectBinding(node, {\n    properties,\n    rest\n  }) {\n    let content = commaSep(properties);\n    if (properties.length === 0) {\n      content = rest == null ? empty() : seq(t('...'), rest);\n    } else {\n      content = rest == null ? content : seq(content, t(','), t('...'), rest);\n    }\n    let state = brace(content);\n    state.startsWithCurly = true;\n    return state;\n  }\n  reduceAssignmentTargetPropertyIdentifier(node, {\n    binding,\n    init\n  }) {\n    if (node.init == null) return binding;\n    return seq(binding, t('='), p(node.init, Precedence.Assignment, init));\n  }\n  reduceAssignmentTargetPropertyProperty(node, {\n    name,\n    binding\n  }) {\n    return seq(name, t(':'), binding);\n  }\n  reduceBindingPropertyIdentifier(node, {\n    binding,\n    init\n  }) {\n    if (node.init == null) return binding;\n    return seq(binding, t('='), p(node.init, Precedence.Assignment, init));\n  }\n  reduceBindingPropertyProperty(node, {\n    name,\n    binding\n  }) {\n    return seq(name, t(':'), binding);\n  }\n  reduceBlock(node, {\n    statements\n  }) {\n    return brace(seq(...statements));\n  }\n  reduceBlockStatement(node, {\n    block\n  }) {\n    return block;\n  }\n  reduceBreakStatement(node) {\n    return seq(t('break'), node.label ? t(node.label) : empty(), semiOp());\n  }\n  reduceCallExpression(node, {\n    callee,\n    arguments: args\n  }) {\n    const parenthizedArgs = args.map((a, i) => p(node.arguments[i], Precedence.Assignment, a));\n    return objectAssign(seq(p(node.callee, getPrecedence(node), callee), paren(commaSep(parenthizedArgs))), {\n      startsWithCurly: callee.startsWithCurly,\n      startsWithLet: callee.startsWithLet,\n      startsWithLetSquareBracket: callee.startsWithLetSquareBracket,\n      startsWithFunctionOrClass: callee.startsWithFunctionOrClass\n    });\n  }\n  reduceCatchClause(node, {\n    binding,\n    body\n  }) {\n    if (binding == null) {\n      return seq(t('catch'), body);\n    }\n    return seq(t('catch'), paren(binding), body);\n  }\n  reduceClassDeclaration(node, {\n    name,\n    super: _super,\n    elements\n  }) {\n    let state = seq(t('class'), node.name.name === '*default*' ? empty() : name);\n    if (_super != null) {\n      state = seq(state, t('extends'), p(node.super, Precedence.New, _super));\n    }\n    state = seq(state, t('{'), ...elements, t('}'));\n    return state;\n  }\n  reduceClassExpression(node, {\n    name,\n    super: _super,\n    elements\n  }) {\n    let state = t('class');\n    if (name != null) {\n      state = seq(state, name);\n    }\n    if (_super != null) {\n      state = seq(state, t('extends'), p(node.super, Precedence.New, _super));\n    }\n    state = seq(state, t('{'), ...elements, t('}'));\n    state.startsWithFunctionOrClass = true;\n    return state;\n  }\n  reduceClassElement(node, {\n    method\n  }) {\n    if (!node.isStatic) return method;\n    return seq(t('static'), method);\n  }\n  reduceComputedMemberAssignmentTarget(node, {\n    object,\n    expression\n  }) {\n    let startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === 'IdentifierExpression' && node.object.name === 'let';\n    return objectAssign(seq(p(node.object, getPrecedence(node), object), bracket(expression)), {\n      startsWithLet: object.startsWithLet,\n      startsWithLetSquareBracket,\n      startsWithCurly: object.startsWithCurly,\n      startsWithFunctionOrClass: object.startsWithFunctionOrClass\n    });\n  }\n  reduceComputedMemberExpression(node, {\n    object,\n    expression\n  }) {\n    let startsWithLetSquareBracket = object.startsWithLetSquareBracket || node.object.type === 'IdentifierExpression' && node.object.name === 'let';\n    return objectAssign(seq(p(node.object, getPrecedence(node), object), bracket(expression)), {\n      startsWithLet: object.startsWithLet,\n      startsWithLetSquareBracket,\n      startsWithCurly: object.startsWithCurly,\n      startsWithFunctionOrClass: object.startsWithFunctionOrClass\n    });\n  }\n  reduceComputedPropertyName(node, {\n    expression\n  }) {\n    return bracket(p(node.expression, Precedence.Assignment, expression));\n  }\n  reduceConditionalExpression(node, {\n    test,\n    consequent,\n    alternate\n  }) {\n    let containsIn = test.containsIn || alternate.containsIn;\n    let startsWithCurly = test.startsWithCurly;\n    let startsWithLetSquareBracket = test.startsWithLetSquareBracket;\n    let startsWithFunctionOrClass = test.startsWithFunctionOrClass;\n    return objectAssign(seq(p(node.test, Precedence.LogicalOR, test), t('?'), p(node.consequent, Precedence.Assignment, consequent), t(':'), p(node.alternate, Precedence.Assignment, alternate)), {\n      containsIn,\n      startsWithCurly,\n      startsWithLetSquareBracket,\n      startsWithFunctionOrClass\n    });\n  }\n  reduceContinueStatement(node) {\n    return seq(t('continue'), node.label ? t(node.label) : empty(), semiOp());\n  }\n  reduceDataProperty(node, {\n    name,\n    expression\n  }) {\n    return seq(name, t(':'), getAssignmentExpr(expression));\n  }\n  reduceDebuggerStatement( /* node */\n  ) {\n    return seq(t('debugger'), semiOp());\n  }\n  reduceDoWhileStatement(node, {\n    body,\n    test\n  }) {\n    return seq(t('do'), body, t('while'), paren(test), semiOp());\n  }\n  reduceEmptyStatement( /* node */\n  ) {\n    return semi();\n  }\n  reduceExpressionStatement(node, {\n    expression\n  }) {\n    let needsParens = expression.startsWithCurly || expression.startsWithLetSquareBracket || expression.startsWithFunctionOrClass;\n    return seq(needsParens ? paren(expression) : expression, semiOp());\n  }\n  reduceForInStatement(node, {\n    left,\n    right,\n    body\n  }) {\n    left = node.left.type === 'VariableDeclaration' ? noIn(markContainsIn(left)) : left;\n    return objectAssign(seq(t('for'), paren(seq(left.startsWithLet ? paren(left) : left, t('in'), right)), body), {\n      endsWithMissingElse: body.endsWithMissingElse\n    });\n  }\n  reduceForOfStatement(node, {\n    left,\n    right,\n    body\n  }) {\n    left = node.left.type === 'VariableDeclaration' ? noIn(markContainsIn(left)) : left;\n    return objectAssign(seq(t('for'), paren(seq(left.startsWithLet ? paren(left) : left, t('of'), p(node.right, Precedence.Assignment, right))), body), {\n      endsWithMissingElse: body.endsWithMissingElse\n    });\n  }\n  reduceForStatement(node, {\n    init,\n    test,\n    update,\n    body\n  }) {\n    if (init) {\n      if (init.startsWithLetSquareBracket) {\n        init = paren(init);\n      }\n      init = noIn(markContainsIn(init));\n    }\n    return objectAssign(seq(t('for'), paren(seq(init ? init : empty(), semi(), test || empty(), semi(), update || empty())), body), {\n      endsWithMissingElse: body.endsWithMissingElse\n    });\n  }\n  reduceForAwaitStatement(node, {\n    left,\n    right,\n    body\n  }) {\n    left = node.left.type === 'VariableDeclaration' ? noIn(markContainsIn(left)) : left;\n    return objectAssign(seq(t('for'), t('await'), paren(seq(left.startsWithLet ? paren(left) : left, t('of'), p(node.right, Precedence.Assignment, right))), body), {\n      endsWithMissingElse: body.endsWithMissingElse\n    });\n  }\n  reduceFunctionBody(node, {\n    directives,\n    statements\n  }) {\n    if (statements.length) {\n      statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);\n    }\n    return brace(seq(...directives, ...statements));\n  }\n  reduceFunctionDeclaration(node, {\n    name,\n    params,\n    body\n  }) {\n    return seq(node.isAsync ? t('async') : empty(), t('function'), node.isGenerator ? t('*') : empty(), node.name.name === '*default*' ? empty() : name, params, body);\n  }\n  reduceFunctionExpression(node, {\n    name,\n    params,\n    body\n  }) {\n    let state = seq(node.isAsync ? t('async') : empty(), t('function'), node.isGenerator ? t('*') : empty(), name ? name : empty(), params, body);\n    state.startsWithFunctionOrClass = true;\n    return state;\n  }\n  reduceFormalParameters(node, {\n    items,\n    rest\n  }) {\n    return paren(commaSep(items.concat(rest == null ? [] : [seq(t('...'), rest)])));\n  }\n  reduceArrowExpression(node, {\n    params,\n    body\n  }) {\n    params = this.regenerateArrowParams(node.params, params);\n    let containsIn = false;\n    if (node.body.type !== 'FunctionBody') {\n      if (body.startsWithCurly) {\n        body = paren(body);\n      } else if (body.containsIn) {\n        containsIn = true;\n      }\n    }\n    return objectAssign(seq(node.isAsync ? t('async') : empty(), params, t('=>'), p(node.body, Precedence.Assignment, body)), {\n      containsIn\n    });\n  }\n  reduceGetter(node, {\n    name,\n    body\n  }) {\n    return seq(t('get'), name, paren(empty()), body);\n  }\n  reduceIdentifierExpression(node) {\n    let a = t(node.name);\n    if (node.name === 'let') {\n      a.startsWithLet = true;\n    }\n    return a;\n  }\n  reduceIfStatement(node, {\n    test,\n    consequent,\n    alternate\n  }) {\n    if (alternate && consequent.endsWithMissingElse) {\n      consequent = brace(consequent);\n    }\n    return objectAssign(seq(t('if'), paren(test), consequent, alternate ? seq(t('else'), alternate) : empty()), {\n      endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true\n    });\n  }\n  reduceImport(node, {\n    defaultBinding,\n    namedImports\n  }) {\n    let bindings = [];\n    if (defaultBinding != null) {\n      bindings.push(defaultBinding);\n    }\n    if (namedImports.length > 0) {\n      bindings.push(brace(commaSep(namedImports)));\n    }\n    if (bindings.length === 0) {\n      return seq(t('import'), t(escapeStringLiteral(node.moduleSpecifier)), semiOp());\n    }\n    return seq(t('import'), commaSep(bindings), t('from'), t(escapeStringLiteral(node.moduleSpecifier)), semiOp());\n  }\n  reduceImportNamespace(node, {\n    defaultBinding,\n    namespaceBinding\n  }) {\n    return seq(t('import'), defaultBinding == null ? empty() : seq(defaultBinding, t(',')), t('*'), t('as'), namespaceBinding, t('from'), t(escapeStringLiteral(node.moduleSpecifier)), semiOp());\n  }\n  reduceImportSpecifier(node, {\n    binding\n  }) {\n    if (node.name == null) return binding;\n    return seq(t(node.name), t('as'), binding);\n  }\n  reduceExportAllFrom(node) {\n    return seq(t('export'), t('*'), t('from'), t(escapeStringLiteral(node.moduleSpecifier)), semiOp());\n  }\n  reduceExportFrom(node, {\n    namedExports\n  }) {\n    return seq(t('export'), brace(commaSep(namedExports)), t('from'), t(escapeStringLiteral(node.moduleSpecifier)), semiOp());\n  }\n  reduceExportLocals(node, {\n    namedExports\n  }) {\n    return seq(t('export'), brace(commaSep(namedExports)), semiOp());\n  }\n  reduceExport(node, {\n    declaration\n  }) {\n    switch (node.declaration.type) {\n      case 'FunctionDeclaration':\n      case 'ClassDeclaration':\n        break;\n      default:\n        declaration = seq(declaration, semiOp());\n    }\n    return seq(t('export'), declaration);\n  }\n  reduceExportDefault(node, {\n    body\n  }) {\n    body = body.startsWithFunctionOrClass ? paren(body) : body;\n    switch (node.body.type) {\n      case 'FunctionDeclaration':\n      case 'ClassDeclaration':\n        return seq(t('export default'), body);\n      default:\n        return seq(t('export default'), p(node.body, Precedence.Assignment, body), semiOp());\n    }\n  }\n  reduceExportFromSpecifier(node) {\n    if (node.exportedName == null) return t(node.name);\n    return seq(t(node.name), t('as'), t(node.exportedName));\n  }\n  reduceExportLocalSpecifier(node, {\n    name\n  }) {\n    if (node.exportedName == null) return name;\n    return seq(name, t('as'), t(node.exportedName));\n  }\n  reduceLabeledStatement(node, {\n    body\n  }) {\n    return objectAssign(seq(t(node.label + ':'), body), {\n      endsWithMissingElse: body.endsWithMissingElse\n    });\n  }\n  reduceLiteralBooleanExpression(node) {\n    return t(node.value.toString());\n  }\n  reduceLiteralNullExpression( /* node */\n  ) {\n    return t('null');\n  }\n  reduceLiteralInfinityExpression( /* node */\n  ) {\n    return t('2e308');\n  }\n  reduceLiteralNumericExpression(node) {\n    return new NumberCodeRep(node.value);\n  }\n  reduceLiteralRegExpExpression(node) {\n    return t(`/${node.pattern}/${node.global ? 'g' : ''}${node.ignoreCase ? 'i' : ''}${node.multiLine ? 'm' : ''}${node.dotAll ? 's' : ''}${node.unicode ? 'u' : ''}${node.sticky ? 'y' : ''}`, true);\n  }\n  reduceLiteralStringExpression(node) {\n    return t(escapeStringLiteral(node.value));\n  }\n  reduceMethod(node, {\n    name,\n    params,\n    body\n  }) {\n    return seq(node.isAsync ? t('async') : empty(), node.isGenerator ? t('*') : empty(), name, params, body);\n  }\n  reduceModule(node, {\n    directives,\n    items\n  }) {\n    if (items.length) {\n      items[0] = this.parenToAvoidBeingDirective(node.items[0], items[0]);\n    }\n    return seq(...directives, ...items);\n  }\n  reduceNewExpression(node, {\n    callee,\n    arguments: args\n  }) {\n    const parenthizedArgs = args.map((a, i) => p(node.arguments[i], Precedence.Assignment, a));\n    let calleeRep = getPrecedence(node.callee) === Precedence.Call ? paren(callee) : p(node.callee, getPrecedence(node), callee);\n    return seq(t('new'), calleeRep, args.length === 0 ? empty() : paren(commaSep(parenthizedArgs)));\n  }\n  reduceNewTargetExpression() {\n    return t('new.target');\n  }\n  reduceObjectExpression(node, {\n    properties\n  }) {\n    let state = brace(commaSep(properties));\n    state.startsWithCurly = true;\n    return state;\n  }\n  reduceUpdateExpression(node, {\n    operand\n  }) {\n    if (node.isPrefix) {\n      return this.reduceUnaryExpression(...arguments);\n    }\n    return objectAssign(seq(p(node.operand, Precedence.New, operand), t(node.operator)), {\n      startsWithCurly: operand.startsWithCurly,\n      startsWithLetSquareBracket: operand.startsWithLetSquareBracket,\n      startsWithFunctionOrClass: operand.startsWithFunctionOrClass\n    });\n  }\n  reduceUnaryExpression(node, {\n    operand\n  }) {\n    return seq(t(node.operator), p(node.operand, getPrecedence(node), operand));\n  }\n  reduceReturnStatement(node, {\n    expression\n  }) {\n    return seq(t('return'), expression || empty(), semiOp());\n  }\n  reduceScript(node, {\n    directives,\n    statements\n  }) {\n    if (statements.length) {\n      statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);\n    }\n    return seq(...directives, ...statements);\n  }\n  reduceSetter(node, {\n    name,\n    param,\n    body\n  }) {\n    return seq(t('set'), name, paren(param), body);\n  }\n  reduceShorthandProperty(node, {\n    name\n  }) {\n    return name;\n  }\n  reduceStaticMemberAssignmentTarget(node, {\n    object\n  }) {\n    const state = seq(p(node.object, getPrecedence(node), object), t('.'), t(node.property));\n    state.startsWithLet = object.startsWithLet;\n    state.startsWithCurly = object.startsWithCurly;\n    state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;\n    state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;\n    return state;\n  }\n  reduceStaticMemberExpression(node, {\n    object\n  }) {\n    const state = seq(p(node.object, getPrecedence(node), object), t('.'), t(node.property));\n    state.startsWithLet = object.startsWithLet;\n    state.startsWithCurly = object.startsWithCurly;\n    state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;\n    state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;\n    return state;\n  }\n  reduceStaticPropertyName(node) {\n    if (keyword.isIdentifierNameES6(node.value)) {\n      return t(node.value);\n    }\n    let n = parseFloat(node.value);\n    if (n >= 0 && n.toString() === node.value) {\n      return new NumberCodeRep(n);\n    }\n    return t(escapeStringLiteral(node.value));\n  }\n  reduceSuper() {\n    return t('super');\n  }\n  reduceSwitchCase(node, {\n    test,\n    consequent\n  }) {\n    return seq(t('case'), test, t(':'), seq(...consequent));\n  }\n  reduceSwitchDefault(node, {\n    consequent\n  }) {\n    return seq(t('default:'), seq(...consequent));\n  }\n  reduceSwitchStatement(node, {\n    discriminant,\n    cases\n  }) {\n    return seq(t('switch'), paren(discriminant), brace(seq(...cases)));\n  }\n  reduceSwitchStatementWithDefault(node, {\n    discriminant,\n    preDefaultCases,\n    defaultCase,\n    postDefaultCases\n  }) {\n    return seq(t('switch'), paren(discriminant), brace(seq(...preDefaultCases, defaultCase, ...postDefaultCases)));\n  }\n  reduceTemplateExpression(node, {\n    tag,\n    elements\n  }) {\n    let state = node.tag == null ? empty() : p(node.tag, getPrecedence(node), tag);\n    state = seq(state, t('`'));\n    for (let i = 0, l = node.elements.length; i < l; ++i) {\n      if (node.elements[i].type === 'TemplateElement') {\n        state = seq(state, i > 0 ? t('}') : empty(), elements[i], i < l - 1 ? t('${') : empty());\n      } else {\n        state = seq(state, elements[i]);\n      }\n    }\n    state = seq(state, t('`'));\n    if (node.tag != null) {\n      state.startsWithCurly = tag.startsWithCurly;\n      state.startsWithLet = tag.startsWithLet;\n      state.startsWithLetSquareBracket = tag.startsWithLetSquareBracket;\n      state.startsWithFunctionOrClass = tag.startsWithFunctionOrClass;\n    }\n    return state;\n  }\n  reduceTemplateElement(node) {\n    return new RawToken(node.rawValue);\n  }\n  reduceThisExpression( /* node */\n  ) {\n    return t('this');\n  }\n  reduceThrowStatement(node, {\n    expression\n  }) {\n    return seq(t('throw'), expression, semiOp());\n  }\n  reduceTryCatchStatement(node, {\n    body,\n    catchClause\n  }) {\n    return seq(t('try'), body, catchClause);\n  }\n  reduceTryFinallyStatement(node, {\n    body,\n    catchClause,\n    finalizer\n  }) {\n    return seq(t('try'), body, catchClause || empty(), t('finally'), finalizer);\n  }\n  reduceYieldExpression(node, {\n    expression\n  }) {\n    if (node.expression == null) return t('yield');\n    return objectAssign(seq(t('yield'), p(node.expression, getPrecedence(node), expression)), {\n      containsIn: expression.containsIn\n    });\n  }\n  reduceYieldGeneratorExpression(node, {\n    expression\n  }) {\n    return objectAssign(seq(t('yield'), t('*'), p(node.expression, getPrecedence(node), expression)), {\n      containsIn: expression.containsIn\n    });\n  }\n  reduceDirective(node) {\n    let delim = node.rawValue.match(/(^|[^\\\\])(\\\\\\\\)*\"/) ? '\\'' : '\"';\n    return seq(t(delim + node.rawValue + delim), semiOp());\n  }\n  reduceVariableDeclaration(node, {\n    declarators\n  }) {\n    return seq(t(node.kind), commaSep(declarators));\n  }\n  reduceVariableDeclarationStatement(node, {\n    declaration\n  }) {\n    return seq(declaration, semiOp());\n  }\n  reduceVariableDeclarator(node, {\n    binding,\n    init\n  }) {\n    let containsIn = init && init.containsIn && !init.containsGroup;\n    if (init) {\n      if (init.containsGroup) {\n        init = paren(init);\n      } else {\n        init = markContainsIn(init);\n      }\n    }\n    return objectAssign(init == null ? binding : seq(binding, t('='), init), {\n      containsIn\n    });\n  }\n  reduceWhileStatement(node, {\n    test,\n    body\n  }) {\n    return objectAssign(seq(t('while'), paren(test), body), {\n      endsWithMissingElse: body.endsWithMissingElse\n    });\n  }\n  reduceWithStatement(node, {\n    object,\n    body\n  }) {\n    return objectAssign(seq(t('with'), paren(object), body), {\n      endsWithMissingElse: body.endsWithMissingElse\n    });\n  }\n}\nmodule.exports = MinimalCodeGen;","map":{"version":3,"names":["objectAssign","require","keyword","Precedence","getPrecedence","escapeStringLiteral","Empty","Token","RawToken","NumberCodeRep","Paren","Bracket","Brace","NoIn","ContainsIn","Seq","Semi","CommaSep","SemiOp","p","node","precedence","a","paren","t","token","isRegExp","rep","brace","bracket","noIn","markContainsIn","state","containsIn","seq","reps","semi","semiOp","empty","commaSep","pieces","getAssignmentExpr","containsGroup","MinimalCodeGen","parenToAvoidBeingDirective","element","original","type","expression","children","regenerateArrowParams","rest","items","length","reduceBindingIdentifier","reduceArrayExpression","elements","content","map","reduceAwaitExpression","reduceSpreadElement","Assignment","reduceSpreadProperty","reduceAssignmentExpression","binding","leftCode","rightCode","startsWithCurly","startsWithLetSquareBracket","startsWithFunctionOrClass","reduceAssignmentTargetIdentifier","name","startsWithLet","reduceAssignmentTargetWithDefault","init","reduceCompoundAssignmentExpression","operator","reduceBinaryExpression","left","right","leftContainsIn","isRightAssociative","rightContainsIn","reduceBindingWithDefault","reduceArrayAssignmentTarget","concat","reduceArrayBinding","reduceObjectAssignmentTarget","properties","reduceObjectBinding","reduceAssignmentTargetPropertyIdentifier","reduceAssignmentTargetPropertyProperty","reduceBindingPropertyIdentifier","reduceBindingPropertyProperty","reduceBlock","statements","reduceBlockStatement","block","reduceBreakStatement","label","reduceCallExpression","callee","arguments","args","parenthizedArgs","i","reduceCatchClause","body","reduceClassDeclaration","super","_super","New","reduceClassExpression","reduceClassElement","method","isStatic","reduceComputedMemberAssignmentTarget","object","reduceComputedMemberExpression","reduceComputedPropertyName","reduceConditionalExpression","test","consequent","alternate","LogicalOR","reduceContinueStatement","reduceDataProperty","reduceDebuggerStatement","reduceDoWhileStatement","reduceEmptyStatement","reduceExpressionStatement","needsParens","reduceForInStatement","endsWithMissingElse","reduceForOfStatement","reduceForStatement","update","reduceForAwaitStatement","reduceFunctionBody","directives","reduceFunctionDeclaration","params","isAsync","isGenerator","reduceFunctionExpression","reduceFormalParameters","reduceArrowExpression","reduceGetter","reduceIdentifierExpression","reduceIfStatement","reduceImport","defaultBinding","namedImports","bindings","push","moduleSpecifier","reduceImportNamespace","namespaceBinding","reduceImportSpecifier","reduceExportAllFrom","reduceExportFrom","namedExports","reduceExportLocals","reduceExport","declaration","reduceExportDefault","reduceExportFromSpecifier","exportedName","reduceExportLocalSpecifier","reduceLabeledStatement","reduceLiteralBooleanExpression","value","toString","reduceLiteralNullExpression","reduceLiteralInfinityExpression","reduceLiteralNumericExpression","reduceLiteralRegExpExpression","pattern","global","ignoreCase","multiLine","dotAll","unicode","sticky","reduceLiteralStringExpression","reduceMethod","reduceModule","reduceNewExpression","calleeRep","Call","reduceNewTargetExpression","reduceObjectExpression","reduceUpdateExpression","operand","isPrefix","reduceUnaryExpression","reduceReturnStatement","reduceScript","reduceSetter","param","reduceShorthandProperty","reduceStaticMemberAssignmentTarget","property","reduceStaticMemberExpression","reduceStaticPropertyName","isIdentifierNameES6","n","parseFloat","reduceSuper","reduceSwitchCase","reduceSwitchDefault","reduceSwitchStatement","discriminant","cases","reduceSwitchStatementWithDefault","preDefaultCases","defaultCase","postDefaultCases","reduceTemplateExpression","tag","l","reduceTemplateElement","rawValue","reduceThisExpression","reduceThrowStatement","reduceTryCatchStatement","catchClause","reduceTryFinallyStatement","finalizer","reduceYieldExpression","reduceYieldGeneratorExpression","reduceDirective","delim","match","reduceVariableDeclaration","declarators","kind","reduceVariableDeclarationStatement","reduceVariableDeclarator","reduceWhileStatement","reduceWithStatement","module","exports"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/shift-codegen/src/minimal-codegen.js"],"sourcesContent":["const objectAssign = require('object-assign');\nconst { keyword } = require('esutils');\nconst { Precedence, getPrecedence, escapeStringLiteral, Empty, Token, RawToken, NumberCodeRep, Paren, Bracket, Brace, NoIn, ContainsIn, Seq, Semi, CommaSep, SemiOp } = require('./coderep');\n\nfunction p(node, precedence, a) {\n  return getPrecedence(node) < precedence ? paren(a) : a;\n}\n\nfunction t(token, isRegExp = false) {\n  return new Token(token, isRegExp);\n}\n\nfunction paren(rep) {\n  return new Paren(rep);\n}\n\nfunction brace(rep) {\n  return new Brace(rep);\n}\n\nfunction bracket(rep) {\n  return new Bracket(rep);\n}\n\nfunction noIn(rep) {\n  return new NoIn(rep);\n}\n\nfunction markContainsIn(state) {\n  return state.containsIn ? new ContainsIn(state) : state;\n}\n\nfunction seq(...reps) {\n  return new Seq(reps);\n}\n\nfunction semi() {\n  return new Semi;\n}\n\nfunction semiOp() {\n  return new SemiOp;\n}\n\nfunction empty() {\n  return new Empty;\n}\n\nfunction commaSep(pieces) {\n  return new CommaSep(pieces);\n}\n\nfunction getAssignmentExpr(state) {\n  return state ? state.containsGroup ? paren(state) : state : empty();\n}\n\nclass MinimalCodeGen {\n  parenToAvoidBeingDirective(element, original) {\n    if (element && element.type === 'ExpressionStatement' && element.expression.type === 'LiteralStringExpression') {\n      return seq(paren(original.children[0]), semiOp());\n    }\n    return original;\n  }\n\n  regenerateArrowParams(element, original) {\n    if (element.rest == null && element.items.length === 1 && element.items[0].type === 'BindingIdentifier') {\n      // FormalParameters unconditionally include parentheses, but they're not necessary here\n      return this.reduceBindingIdentifier(element.items[0]);\n    }\n    return original;\n  }\n\n  reduceArrayExpression(node, { elements }) {\n    if (elements.length === 0) {\n      return bracket(empty());\n    }\n\n    let content = commaSep(elements.map(getAssignmentExpr));\n    if (elements.length > 0 && elements[elements.length - 1] == null) {\n      content = seq(content, t(','));\n    }\n    return bracket(content);\n  }\n\n  reduceAwaitExpression(node, { expression }) {\n    return seq(t('await'), p(node.expression, getPrecedence(node), expression));\n  }\n\n  reduceSpreadElement(node, { expression }) {\n    return seq(t('...'), p(node.expression, Precedence.Assignment, expression));\n  }\n\n  reduceSpreadProperty(node, { expression }) {\n    return seq(t('...'), getAssignmentExpr(expression));\n  }\n\n  reduceAssignmentExpression(node, { binding, expression }) {\n    let leftCode = binding;\n    let rightCode = expression;\n    let containsIn = expression.containsIn;\n    let startsWithCurly = binding.startsWithCurly;\n    let startsWithLetSquareBracket = binding.startsWithLetSquareBracket;\n    let startsWithFunctionOrClass = binding.startsWithFunctionOrClass;\n    if (getPrecedence(node.expression) < getPrecedence(node)) {\n      rightCode = paren(rightCode);\n      containsIn = false;\n    }\n    return objectAssign(seq(leftCode, t('='), rightCode), { containsIn, startsWithCurly, startsWithLetSquareBracket, startsWithFunctionOrClass });\n  }\n\n  reduceAssignmentTargetIdentifier(node) {\n    let a = t(node.name);\n    if (node.name === 'let') {\n      a.startsWithLet = true;\n    }\n    return a;\n  }\n\n  reduceAssignmentTargetWithDefault(node, { binding, init }) {\n    return seq(binding, t('='), p(node.init, Precedence.Assignment, init));\n  }\n\n  reduceCompoundAssignmentExpression(node, { binding, expression }) {\n    let leftCode = binding;\n    let rightCode = expression;\n    let containsIn = expression.containsIn;\n    let startsWithCurly = binding.startsWithCurly;\n    let startsWithLetSquareBracket = binding.startsWithLetSquareBracket;\n    let startsWithFunctionOrClass = binding.startsWithFunctionOrClass;\n    if (getPrecedence(node.expression) < getPrecedence(node)) {\n      rightCode = paren(rightCode);\n      containsIn = false;\n    }\n    return objectAssign(seq(leftCode, t(node.operator), rightCode), { containsIn, startsWithCurly, startsWithLetSquareBracket, startsWithFunctionOrClass });\n  }\n\n  reduceBinaryExpression(node, { left, right }) {\n    let leftCode = left;\n    let startsWithCurly = left.startsWithCurly;\n    let startsWithLetSquareBracket = left.startsWithLetSquareBracket;\n    let startsWithFunctionOrClass = left.startsWithFunctionOrClass;\n    let leftContainsIn = left.containsIn;\n    let isRightAssociative = node.operator === '**';\n    if (getPrecedence(node.left) < getPrecedence(node) || isRightAssociative && (getPrecedence(node.left) === getPrecedence(node) || node.left.type === 'UnaryExpression')) {\n      leftCode = paren(leftCode);\n      startsWithCurly = false;\n      startsWithLetSquareBracket = false;\n      startsWithFunctionOrClass = false;\n      leftContainsIn = false;\n    }\n    let rightCode = right;\n    let rightContainsIn = right.containsIn;\n    if (getPrecedence(node.right) < getPrecedence(node) || !isRightAssociative && getPrecedence(node.right) === getPrecedence(node)) {\n      rightCode = paren(rightCode);\n      rightContainsIn = false;\n    }\n    return objectAssign(\n      seq(leftCode, t(node.operator), rightCode),\n      {\n        containsIn: leftContainsIn || rightContainsIn || node.operator === 'in',\n        containsGroup: node.operator === ',',\n        startsWithCurly,\n        startsWithLetSquareBracket,\n        startsWithFunctionOrClass,\n      }\n    );\n  }\n\n  reduceBindingWithDefault(node, { binding, init }) {\n    return seq(binding, t('='), p(node.init, Precedence.Assignment, init));\n  }\n\n  reduceBindingIdentifier(node) {\n    let a = t(node.name);\n    if (node.name === 'let') {\n      a.startsWithLet = true;\n    }\n    return a;\n  }\n\n  reduceArrayAssignmentTarget(node, { elements, rest }) {\n    let content;\n    if (elements.length === 0) {\n      content = rest == null ? empty() : seq(t('...'), rest);\n    } else {\n      elements = elements.concat(rest == null ? [] : [seq(t('...'), rest)]);\n      content = commaSep(elements.map(getAssignmentExpr));\n      if (elements.length > 0 && elements[elements.length - 1] == null) {\n        content = seq(content, t(','));\n      }\n    }\n    return bracket(content);\n  }\n\n  reduceArrayBinding(node, { elements, rest }) {\n    let content;\n    if (elements.length === 0) {\n      content = rest == null ? empty() : seq(t('...'), rest);\n    } else {\n      elements = elements.concat(rest == null ? [] : [seq(t('...'), rest)]);\n      content = commaSep(elements.map(getAssignmentExpr));\n      if (elements.length > 0 && elements[elements.length - 1] == null) {\n        content = seq(content, t(','));\n      }\n    }\n    return bracket(content);\n  }\n\n  reduceObjectAssignmentTarget(node, { properties, rest }) {\n    let content = commaSep(properties);\n    if (properties.length === 0) {\n      content = rest == null ? empty() : seq(t('...'), rest);\n    } else {\n      content = rest == null ? content : seq(content, t(','), t('...'), rest);\n    }\n    let state = brace(content);\n    state.startsWithCurly = true;\n    return state;\n  }\n\n  reduceObjectBinding(node, { properties, rest }) {\n    let content = commaSep(properties);\n    if (properties.length === 0) {\n      content = rest == null ? empty() : seq(t('...'), rest);\n    } else {\n      content = rest == null ? content : seq(content, t(','), t('...'), rest);\n    }\n    let state = brace(content);\n    state.startsWithCurly = true;\n    return state;\n  }\n\n  reduceAssignmentTargetPropertyIdentifier(node, { binding, init }) {\n    if (node.init == null) return binding;\n    return seq(binding, t('='), p(node.init, Precedence.Assignment, init));\n  }\n\n  reduceAssignmentTargetPropertyProperty(node, { name, binding }) {\n    return seq(name, t(':'), binding);\n  }\n\n  reduceBindingPropertyIdentifier(node, { binding, init }) {\n    if (node.init == null) return binding;\n    return seq(binding, t('='), p(node.init, Precedence.Assignment, init));\n  }\n\n  reduceBindingPropertyProperty(node, { name, binding }) {\n    return seq(name, t(':'), binding);\n  }\n\n  reduceBlock(node, { statements }) {\n    return brace(seq(...statements));\n  }\n\n  reduceBlockStatement(node, { block }) {\n    return block;\n  }\n\n  reduceBreakStatement(node) {\n    return seq(t('break'), node.label ? t(node.label) : empty(), semiOp());\n  }\n\n  reduceCallExpression(node, { callee, arguments: args }) {\n    const parenthizedArgs = args.map((a, i) => p(node.arguments[i], Precedence.Assignment, a));\n    return objectAssign(\n      seq(p(node.callee, getPrecedence(node), callee), paren(commaSep(parenthizedArgs))),\n      {\n        startsWithCurly: callee.startsWithCurly,\n        startsWithLet: callee.startsWithLet,\n        startsWithLetSquareBracket: callee.startsWithLetSquareBracket,\n        startsWithFunctionOrClass: callee.startsWithFunctionOrClass,\n      }\n    );\n  }\n\n  reduceCatchClause(node, { binding, body }) {\n    if (binding == null) {\n      return seq(t('catch'), body);\n    }\n    return seq(t('catch'), paren(binding), body);\n  }\n\n  reduceClassDeclaration(node, { name, super: _super, elements }) {\n    let state = seq(t('class'), node.name.name === '*default*' ? empty() : name);\n    if (_super != null) {\n      state = seq(state, t('extends'), p(node.super, Precedence.New, _super));\n    }\n    state = seq(state, t('{'), ...elements, t('}'));\n    return state;\n  }\n\n  reduceClassExpression(node, { name, super: _super, elements }) {\n    let state = t('class');\n    if (name != null) {\n      state = seq(state, name);\n    }\n    if (_super != null) {\n      state = seq(state, t('extends'), p(node.super, Precedence.New, _super));\n    }\n    state = seq(state, t('{'), ...elements, t('}'));\n    state.startsWithFunctionOrClass = true;\n    return state;\n  }\n\n  reduceClassElement(node, { method }) {\n    if (!node.isStatic) return method;\n    return seq(t('static'), method);\n  }\n\n  reduceComputedMemberAssignmentTarget(node, { object, expression }) {\n    let startsWithLetSquareBracket =\n      object.startsWithLetSquareBracket ||\n      node.object.type === 'IdentifierExpression' && node.object.name === 'let';\n    return objectAssign(\n      seq(p(node.object, getPrecedence(node), object), bracket(expression)),\n      {\n        startsWithLet: object.startsWithLet,\n        startsWithLetSquareBracket,\n        startsWithCurly: object.startsWithCurly,\n        startsWithFunctionOrClass: object.startsWithFunctionOrClass,\n      }\n    );\n  }\n\n  reduceComputedMemberExpression(node, { object, expression }) {\n    let startsWithLetSquareBracket =\n      object.startsWithLetSquareBracket ||\n      node.object.type === 'IdentifierExpression' && node.object.name === 'let';\n    return objectAssign(\n      seq(p(node.object, getPrecedence(node), object), bracket(expression)),\n      {\n        startsWithLet: object.startsWithLet,\n        startsWithLetSquareBracket,\n        startsWithCurly: object.startsWithCurly,\n        startsWithFunctionOrClass: object.startsWithFunctionOrClass,\n      }\n    );\n  }\n\n  reduceComputedPropertyName(node, { expression }) {\n    return bracket(p(node.expression, Precedence.Assignment, expression));\n  }\n\n  reduceConditionalExpression(node, { test, consequent, alternate }) {\n    let containsIn = test.containsIn || alternate.containsIn;\n    let startsWithCurly = test.startsWithCurly;\n    let startsWithLetSquareBracket = test.startsWithLetSquareBracket;\n    let startsWithFunctionOrClass = test.startsWithFunctionOrClass;\n    return objectAssign(\n      seq(\n        p(node.test, Precedence.LogicalOR, test), t('?'),\n        p(node.consequent, Precedence.Assignment, consequent), t(':'),\n        p(node.alternate, Precedence.Assignment, alternate)), {\n        containsIn,\n        startsWithCurly,\n        startsWithLetSquareBracket,\n        startsWithFunctionOrClass,\n      });\n  }\n\n  reduceContinueStatement(node) {\n    return seq(t('continue'), node.label ? t(node.label) : empty(), semiOp());\n  }\n\n  reduceDataProperty(node, { name, expression }) {\n    return seq(name, t(':'), getAssignmentExpr(expression));\n  }\n\n  reduceDebuggerStatement(/* node */) {\n    return seq(t('debugger'), semiOp());\n  }\n\n  reduceDoWhileStatement(node, { body, test }) {\n    return seq(t('do'), body, t('while'), paren(test), semiOp());\n  }\n\n  reduceEmptyStatement(/* node */) {\n    return semi();\n  }\n\n  reduceExpressionStatement(node, { expression }) {\n    let needsParens =\n      expression.startsWithCurly ||\n      expression.startsWithLetSquareBracket ||\n      expression.startsWithFunctionOrClass;\n    return seq(needsParens ? paren(expression) : expression, semiOp());\n  }\n\n  reduceForInStatement(node, { left, right, body }) {\n    left = node.left.type === 'VariableDeclaration' ? noIn(markContainsIn(left)) : left;\n    return objectAssign(\n      seq(t('for'), paren(seq(left.startsWithLet ? paren(left) : left, t('in'), right)), body),\n      { endsWithMissingElse: body.endsWithMissingElse });\n  }\n\n  reduceForOfStatement(node, { left, right, body }) {\n    left = node.left.type === 'VariableDeclaration' ? noIn(markContainsIn(left)) : left;\n    return objectAssign(\n      seq(t('for'), paren(seq(left.startsWithLet ? paren(left) : left, t('of'), p(node.right, Precedence.Assignment, right))), body),\n      { endsWithMissingElse: body.endsWithMissingElse });\n  }\n\n  reduceForStatement(node, { init, test, update, body }) {\n    if (init) {\n      if (init.startsWithLetSquareBracket) {\n        init = paren(init);\n      }\n      init = noIn(markContainsIn(init));\n    }\n    return objectAssign(\n      seq(\n        t('for'),\n        paren(seq(init ? init : empty(), semi(), test || empty(), semi(), update || empty())),\n        body),\n      {\n        endsWithMissingElse: body.endsWithMissingElse,\n      });\n  }\n\n  reduceForAwaitStatement(node, { left, right, body }) {\n    left = node.left.type === 'VariableDeclaration' ? noIn(markContainsIn(left)) : left;\n    return objectAssign(\n      seq(t('for'), t('await'), paren(seq(left.startsWithLet ? paren(left) : left, t('of'), p(node.right, Precedence.Assignment, right))), body),\n      { endsWithMissingElse: body.endsWithMissingElse });\n  }\n\n  reduceFunctionBody(node, { directives, statements }) {\n    if (statements.length) {\n      statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);\n    }\n    return brace(seq(...directives, ...statements));\n  }\n\n  reduceFunctionDeclaration(node, { name, params, body }) {\n    return seq(node.isAsync ? t('async') : empty(), t('function'), node.isGenerator ? t('*') : empty(), node.name.name === '*default*' ? empty() : name, params, body);\n  }\n\n  reduceFunctionExpression(node, { name, params, body }) {\n    let state = seq(node.isAsync ? t('async') : empty(), t('function'), node.isGenerator ? t('*') : empty(), name ? name : empty(), params, body);\n    state.startsWithFunctionOrClass = true;\n    return state;\n  }\n\n  reduceFormalParameters(node, { items, rest }) {\n    return paren(commaSep(items.concat(rest == null ? [] : [seq(t('...'), rest)])));\n  }\n\n  reduceArrowExpression(node, { params, body }) {\n    params = this.regenerateArrowParams(node.params, params);\n    let containsIn = false;\n    if (node.body.type !== 'FunctionBody') {\n      if (body.startsWithCurly) {\n        body = paren(body);\n      } else if (body.containsIn) {\n        containsIn = true;\n      }\n    }\n    return objectAssign(seq(node.isAsync ? t('async') : empty(), params, t('=>'), p(node.body, Precedence.Assignment, body)), { containsIn });\n  }\n\n  reduceGetter(node, { name, body }) {\n    return seq(t('get'), name, paren(empty()), body);\n  }\n\n  reduceIdentifierExpression(node) {\n    let a = t(node.name);\n    if (node.name === 'let') {\n      a.startsWithLet = true;\n    }\n    return a;\n  }\n\n  reduceIfStatement(node, { test, consequent, alternate }) {\n    if (alternate && consequent.endsWithMissingElse) {\n      consequent = brace(consequent);\n    }\n    return objectAssign(\n      seq(t('if'), paren(test), consequent, alternate ? seq(t('else'), alternate) : empty()),\n      { endsWithMissingElse: alternate ? alternate.endsWithMissingElse : true });\n  }\n\n  reduceImport(node, { defaultBinding, namedImports }) {\n    let bindings = [];\n    if (defaultBinding != null) {\n      bindings.push(defaultBinding);\n    }\n    if (namedImports.length > 0) {\n      bindings.push(brace(commaSep(namedImports)));\n    }\n    if (bindings.length === 0) {\n      return seq(t('import'), t(escapeStringLiteral(node.moduleSpecifier)), semiOp());\n    }\n    return seq(t('import'), commaSep(bindings), t('from'), t(escapeStringLiteral(node.moduleSpecifier)), semiOp());\n  }\n\n  reduceImportNamespace(node, { defaultBinding, namespaceBinding }) {\n    return seq(\n      t('import'),\n      defaultBinding == null ? empty() : seq(defaultBinding, t(',')),\n      t('*'),\n      t('as'),\n      namespaceBinding,\n      t('from'),\n      t(escapeStringLiteral(node.moduleSpecifier)),\n      semiOp()\n    );\n  }\n\n  reduceImportSpecifier(node, { binding }) {\n    if (node.name == null) return binding;\n    return seq(t(node.name), t('as'), binding);\n  }\n\n  reduceExportAllFrom(node) {\n    return seq(t('export'), t('*'), t('from'), t(escapeStringLiteral(node.moduleSpecifier)), semiOp());\n  }\n\n  reduceExportFrom(node, { namedExports }) {\n    return seq(t('export'), brace(commaSep(namedExports)), t('from'), t(escapeStringLiteral(node.moduleSpecifier)), semiOp());\n  }\n\n  reduceExportLocals(node, { namedExports }) {\n    return seq(t('export'), brace(commaSep(namedExports)), semiOp());\n  }\n\n  reduceExport(node, { declaration }) {\n    switch (node.declaration.type) {\n      case 'FunctionDeclaration':\n      case 'ClassDeclaration':\n        break;\n      default:\n        declaration = seq(declaration, semiOp());\n    }\n    return seq(t('export'), declaration);\n  }\n\n  reduceExportDefault(node, { body }) {\n    body = body.startsWithFunctionOrClass ? paren(body) : body;\n    switch (node.body.type) {\n      case 'FunctionDeclaration':\n      case 'ClassDeclaration':\n        return seq(t('export default'), body);\n      default:\n        return seq(t('export default'), p(node.body, Precedence.Assignment, body), semiOp());\n    }\n  }\n\n  reduceExportFromSpecifier(node) {\n    if (node.exportedName == null) return t(node.name);\n    return seq(t(node.name), t('as'), t(node.exportedName));\n  }\n\n  reduceExportLocalSpecifier(node, { name }) {\n    if (node.exportedName == null) return name;\n    return seq(name, t('as'), t(node.exportedName));\n  }\n\n  reduceLabeledStatement(node, { body }) {\n    return objectAssign(seq(t(node.label + ':'), body), { endsWithMissingElse: body.endsWithMissingElse });\n  }\n\n  reduceLiteralBooleanExpression(node) {\n    return t(node.value.toString());\n  }\n\n  reduceLiteralNullExpression(/* node */) {\n    return t('null');\n  }\n\n  reduceLiteralInfinityExpression(/* node */) {\n    return t('2e308');\n  }\n\n  reduceLiteralNumericExpression(node) {\n    return new NumberCodeRep(node.value);\n  }\n\n  reduceLiteralRegExpExpression(node) {\n    return t(`/${node.pattern}/${node.global ? 'g' : ''}${node.ignoreCase ? 'i' : ''}${node.multiLine ? 'm' : ''}${node.dotAll ? 's' : ''}${node.unicode ? 'u' : ''}${node.sticky ? 'y' : ''}`, true);\n  }\n\n  reduceLiteralStringExpression(node) {\n    return t(escapeStringLiteral(node.value));\n  }\n\n  reduceMethod(node, { name, params, body }) {\n    return seq(node.isAsync ? t('async') : empty(), node.isGenerator ? t('*') : empty(), name, params, body);\n  }\n\n  reduceModule(node, { directives, items }) {\n    if (items.length) {\n      items[0] = this.parenToAvoidBeingDirective(node.items[0], items[0]);\n    }\n    return seq(...directives, ...items);\n  }\n\n  reduceNewExpression(node, { callee, arguments: args }) {\n    const parenthizedArgs = args.map((a, i) => p(node.arguments[i], Precedence.Assignment, a));\n    let calleeRep = getPrecedence(node.callee) === Precedence.Call ? paren(callee) :\n      p(node.callee, getPrecedence(node), callee);\n    return seq(t('new'), calleeRep, args.length === 0 ? empty() : paren(commaSep(parenthizedArgs)));\n  }\n\n  reduceNewTargetExpression() {\n    return t('new.target');\n  }\n\n  reduceObjectExpression(node, { properties }) {\n    let state = brace(commaSep(properties));\n    state.startsWithCurly = true;\n    return state;\n  }\n\n  reduceUpdateExpression(node, { operand }) {\n    if (node.isPrefix) {\n      return this.reduceUnaryExpression(...arguments);\n    }\n    return objectAssign(\n      seq(p(node.operand, Precedence.New, operand), t(node.operator)),\n      {\n        startsWithCurly: operand.startsWithCurly,\n        startsWithLetSquareBracket: operand.startsWithLetSquareBracket,\n        startsWithFunctionOrClass: operand.startsWithFunctionOrClass,\n      }\n    );\n\n  }\n\n  reduceUnaryExpression(node, { operand }) {\n    return seq(t(node.operator), p(node.operand, getPrecedence(node), operand));\n  }\n\n  reduceReturnStatement(node, { expression }) {\n    return seq(t('return'), expression || empty(), semiOp());\n  }\n\n  reduceScript(node, { directives, statements }) {\n    if (statements.length) {\n      statements[0] = this.parenToAvoidBeingDirective(node.statements[0], statements[0]);\n    }\n    return seq(...directives, ...statements);\n  }\n\n  reduceSetter(node, { name, param, body }) {\n    return seq(t('set'), name, paren(param), body);\n  }\n\n  reduceShorthandProperty(node, { name }) {\n    return name;\n  }\n\n  reduceStaticMemberAssignmentTarget(node, { object }) {\n    const state = seq(p(node.object, getPrecedence(node), object), t('.'), t(node.property));\n    state.startsWithLet = object.startsWithLet;\n    state.startsWithCurly = object.startsWithCurly;\n    state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;\n    state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;\n    return state;\n  }\n\n  reduceStaticMemberExpression(node, { object }) {\n    const state = seq(p(node.object, getPrecedence(node), object), t('.'), t(node.property));\n    state.startsWithLet = object.startsWithLet;\n    state.startsWithCurly = object.startsWithCurly;\n    state.startsWithLetSquareBracket = object.startsWithLetSquareBracket;\n    state.startsWithFunctionOrClass = object.startsWithFunctionOrClass;\n    return state;\n  }\n\n  reduceStaticPropertyName(node) {\n    if (keyword.isIdentifierNameES6(node.value)) {\n      return t(node.value);\n    }\n    let n = parseFloat(node.value);\n    if (n >= 0 && n.toString() === node.value) {\n      return new NumberCodeRep(n);\n    }\n    return t(escapeStringLiteral(node.value));\n  }\n\n  reduceSuper() {\n    return t('super');\n  }\n\n  reduceSwitchCase(node, { test, consequent }) {\n    return seq(t('case'), test, t(':'), seq(...consequent));\n  }\n\n  reduceSwitchDefault(node, { consequent }) {\n    return seq(t('default:'), seq(...consequent));\n  }\n\n  reduceSwitchStatement(node, { discriminant, cases }) {\n    return seq(t('switch'), paren(discriminant), brace(seq(...cases)));\n  }\n\n  reduceSwitchStatementWithDefault(node, { discriminant, preDefaultCases, defaultCase, postDefaultCases }) {\n    return seq(\n      t('switch'),\n      paren(discriminant),\n      brace(seq(...preDefaultCases, defaultCase, ...postDefaultCases)));\n  }\n\n  reduceTemplateExpression(node, { tag, elements }) {\n    let state = node.tag == null ? empty() : p(node.tag, getPrecedence(node), tag);\n    state = seq(state, t('`'));\n    for (let i = 0, l = node.elements.length; i < l; ++i) {\n      if (node.elements[i].type === 'TemplateElement') {\n        state = seq(\n          state,\n          i > 0 ? t('}') : empty(),\n          elements[i],\n          i < l - 1 ? t('${') : empty()\n        );\n      } else {\n        state = seq(state, elements[i]);\n      }\n    }\n    state = seq(state, t('`'));\n    if (node.tag != null) {\n      state.startsWithCurly = tag.startsWithCurly;\n      state.startsWithLet = tag.startsWithLet;\n      state.startsWithLetSquareBracket = tag.startsWithLetSquareBracket;\n      state.startsWithFunctionOrClass = tag.startsWithFunctionOrClass;\n    }\n    return state;\n  }\n\n  reduceTemplateElement(node) {\n    return new RawToken(node.rawValue);\n  }\n\n  reduceThisExpression(/* node */) {\n    return t('this');\n  }\n\n  reduceThrowStatement(node, { expression }) {\n    return seq(t('throw'), expression, semiOp());\n  }\n\n  reduceTryCatchStatement(node, { body, catchClause }) {\n    return seq(t('try'), body, catchClause);\n  }\n\n  reduceTryFinallyStatement(node, { body, catchClause, finalizer }) {\n    return seq(t('try'), body, catchClause || empty(), t('finally'), finalizer);\n  }\n\n  reduceYieldExpression(node, { expression }) {\n    if (node.expression == null) return t('yield');\n    return objectAssign(seq(t('yield'), p(node.expression, getPrecedence(node), expression)), { containsIn: expression.containsIn });\n  }\n\n  reduceYieldGeneratorExpression(node, { expression }) {\n    return objectAssign(seq(t('yield'), t('*'), p(node.expression, getPrecedence(node), expression)), { containsIn: expression.containsIn });\n  }\n\n  reduceDirective(node) {\n    let delim = node.rawValue.match(/(^|[^\\\\])(\\\\\\\\)*\"/) ? '\\'' : '\"';\n    return seq(t(delim + node.rawValue + delim), semiOp());\n  }\n\n  reduceVariableDeclaration(node, { declarators }) {\n    return seq(t(node.kind), commaSep(declarators));\n  }\n\n  reduceVariableDeclarationStatement(node, { declaration }) {\n    return seq(declaration, semiOp());\n  }\n\n  reduceVariableDeclarator(node, { binding, init }) {\n    let containsIn = init && init.containsIn && !init.containsGroup;\n    if (init) {\n      if (init.containsGroup) {\n        init = paren(init);\n      } else {\n        init = markContainsIn(init);\n      }\n    }\n    return objectAssign(init == null ? binding : seq(binding, t('='), init), { containsIn });\n  }\n\n  reduceWhileStatement(node, { test, body }) {\n    return objectAssign(seq(t('while'), paren(test), body), { endsWithMissingElse: body.endsWithMissingElse });\n  }\n\n  reduceWithStatement(node, { object, body }) {\n    return objectAssign(\n      seq(t('with'), paren(object), body),\n      { endsWithMissingElse: body.endsWithMissingElse });\n  }\n}\n\nmodule.exports = MinimalCodeGen;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}