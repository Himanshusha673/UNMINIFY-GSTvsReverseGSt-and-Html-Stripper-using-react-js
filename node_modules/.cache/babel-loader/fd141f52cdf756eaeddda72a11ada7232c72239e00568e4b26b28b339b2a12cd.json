{"ast":null,"code":"/**\n * Copyright 2014 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst MultiMap = require('multimap');\nfunction addEach(thisMap, ...otherMaps) {\n  otherMaps.forEach(otherMap => {\n    otherMap.forEachEntry((v, k) => {\n      thisMap.set.apply(thisMap, [k].concat(v));\n    });\n  });\n  return thisMap;\n}\nlet identity; // initialised below EarlyErrorState\n\nclass EarlyErrorState {\n  constructor() {\n    this.errors = [];\n    // errors that are only errors in strict mode code\n    this.strictErrors = [];\n\n    // Label values used in LabeledStatement nodes; cleared at function boundaries\n    this.usedLabelNames = [];\n\n    // BreakStatement nodes; cleared at iteration; switch; and function boundaries\n    this.freeBreakStatements = [];\n    // ContinueStatement nodes; cleared at\n    this.freeContinueStatements = [];\n\n    // labeled BreakStatement nodes; cleared at LabeledStatement with same Label and function boundaries\n    this.freeLabeledBreakStatements = [];\n    // labeled ContinueStatement nodes; cleared at labeled iteration statement with same Label and function boundaries\n    this.freeLabeledContinueStatements = [];\n\n    // NewTargetExpression nodes; cleared at function (besides arrow expression) boundaries\n    this.newTargetExpressions = [];\n\n    // BindingIdentifier nodes; cleared at containing declaration node\n    this.boundNames = new MultiMap();\n    // BindingIdentifiers that were found to be in a lexical binding position\n    this.lexicallyDeclaredNames = new MultiMap();\n    // BindingIdentifiers that were the name of a FunctionDeclaration\n    this.functionDeclarationNames = new MultiMap();\n    // BindingIdentifiers that were found to be in a variable binding position\n    this.varDeclaredNames = new MultiMap();\n    // BindingIdentifiers that were found to be in a variable binding position\n    this.forOfVarDeclaredNames = [];\n\n    // Names that this module exports\n    this.exportedNames = new MultiMap();\n    // Locally declared names that are referenced in export declarations\n    this.exportedBindings = new MultiMap();\n\n    // CallExpressions with Super callee\n    this.superCallExpressions = [];\n    // SuperCall expressions in the context of a Method named \"constructor\"\n    this.superCallExpressionsInConstructorMethod = [];\n    // MemberExpressions with Super object\n    this.superPropertyExpressions = [];\n\n    // YieldExpression and YieldGeneratorExpression nodes; cleared at function boundaries\n    this.yieldExpressions = [];\n    // AwaitExpression nodes; cleared at function boundaries\n    this.awaitExpressions = [];\n  }\n  addFreeBreakStatement(s) {\n    this.freeBreakStatements.push(s);\n    return this;\n  }\n  addFreeLabeledBreakStatement(s) {\n    this.freeLabeledBreakStatements.push(s);\n    return this;\n  }\n  clearFreeBreakStatements() {\n    this.freeBreakStatements = [];\n    return this;\n  }\n  addFreeContinueStatement(s) {\n    this.freeContinueStatements.push(s);\n    return this;\n  }\n  addFreeLabeledContinueStatement(s) {\n    this.freeLabeledContinueStatements.push(s);\n    return this;\n  }\n  clearFreeContinueStatements() {\n    this.freeContinueStatements = [];\n    return this;\n  }\n  enforceFreeBreakStatementErrors(createError) {\n    [].push.apply(this.errors, this.freeBreakStatements.map(createError));\n    this.freeBreakStatements = [];\n    return this;\n  }\n  enforceFreeLabeledBreakStatementErrors(createError) {\n    [].push.apply(this.errors, this.freeLabeledBreakStatements.map(createError));\n    this.freeLabeledBreakStatements = [];\n    return this;\n  }\n  enforceFreeContinueStatementErrors(createError) {\n    [].push.apply(this.errors, this.freeContinueStatements.map(createError));\n    this.freeContinueStatements = [];\n    return this;\n  }\n  enforceFreeLabeledContinueStatementErrors(createError) {\n    [].push.apply(this.errors, this.freeLabeledContinueStatements.map(createError));\n    this.freeLabeledContinueStatements = [];\n    return this;\n  }\n  observeIterationLabel(label) {\n    this.usedLabelNames.push(label);\n    this.freeLabeledBreakStatements = this.freeLabeledBreakStatements.filter(s => s.label !== label);\n    this.freeLabeledContinueStatements = this.freeLabeledContinueStatements.filter(s => s.label !== label);\n    return this;\n  }\n  observeNonIterationLabel(label) {\n    this.usedLabelNames.push(label);\n    this.freeLabeledBreakStatements = this.freeLabeledBreakStatements.filter(s => s.label !== label);\n    return this;\n  }\n  clearUsedLabelNames() {\n    this.usedLabelNames = [];\n    return this;\n  }\n  observeSuperCallExpression(node) {\n    this.superCallExpressions.push(node);\n    return this;\n  }\n  observeConstructorMethod() {\n    this.superCallExpressionsInConstructorMethod = this.superCallExpressions;\n    this.superCallExpressions = [];\n    return this;\n  }\n  clearSuperCallExpressionsInConstructorMethod() {\n    this.superCallExpressionsInConstructorMethod = [];\n    return this;\n  }\n  enforceSuperCallExpressions(createError) {\n    [].push.apply(this.errors, this.superCallExpressions.map(createError));\n    [].push.apply(this.errors, this.superCallExpressionsInConstructorMethod.map(createError));\n    this.superCallExpressions = [];\n    this.superCallExpressionsInConstructorMethod = [];\n    return this;\n  }\n  enforceSuperCallExpressionsInConstructorMethod(createError) {\n    [].push.apply(this.errors, this.superCallExpressionsInConstructorMethod.map(createError));\n    this.superCallExpressionsInConstructorMethod = [];\n    return this;\n  }\n  observeSuperPropertyExpression(node) {\n    this.superPropertyExpressions.push(node);\n    return this;\n  }\n  clearSuperPropertyExpressions() {\n    this.superPropertyExpressions = [];\n    return this;\n  }\n  enforceSuperPropertyExpressions(createError) {\n    [].push.apply(this.errors, this.superPropertyExpressions.map(createError));\n    this.superPropertyExpressions = [];\n    return this;\n  }\n  observeNewTargetExpression(node) {\n    this.newTargetExpressions.push(node);\n    return this;\n  }\n  clearNewTargetExpressions() {\n    this.newTargetExpressions = [];\n    return this;\n  }\n  bindName(name, node) {\n    this.boundNames.set(name, node);\n    return this;\n  }\n  clearBoundNames() {\n    this.boundNames = new MultiMap();\n    return this;\n  }\n  observeLexicalDeclaration() {\n    addEach(this.lexicallyDeclaredNames, this.boundNames);\n    this.boundNames = new MultiMap();\n    return this;\n  }\n  observeLexicalBoundary() {\n    this.previousLexicallyDeclaredNames = this.lexicallyDeclaredNames;\n    this.lexicallyDeclaredNames = new MultiMap();\n    this.functionDeclarationNames = new MultiMap();\n    return this;\n  }\n  enforceDuplicateLexicallyDeclaredNames(createError) {\n    this.lexicallyDeclaredNames.forEachEntry(nodes => {\n      if (nodes.length > 1) {\n        nodes.slice(1).forEach(dupeNode => {\n          this.addError(createError(dupeNode));\n        });\n      }\n    });\n    return this;\n  }\n  enforceConflictingLexicallyDeclaredNames(otherNames, createError) {\n    this.lexicallyDeclaredNames.forEachEntry((nodes, bindingName) => {\n      if (otherNames.has(bindingName)) {\n        nodes.forEach(conflictingNode => {\n          this.addError(createError(conflictingNode));\n        });\n      }\n    });\n    return this;\n  }\n  observeFunctionDeclaration() {\n    this.observeVarBoundary();\n    addEach(this.functionDeclarationNames, this.boundNames);\n    this.boundNames = new MultiMap();\n    return this;\n  }\n  functionDeclarationNamesAreLexical() {\n    addEach(this.lexicallyDeclaredNames, this.functionDeclarationNames);\n    this.functionDeclarationNames = new MultiMap();\n    return this;\n  }\n  observeVarDeclaration() {\n    addEach(this.varDeclaredNames, this.boundNames);\n    this.boundNames = new MultiMap();\n    return this;\n  }\n  recordForOfVars() {\n    this.varDeclaredNames.forEach(bindingIdentifier => {\n      this.forOfVarDeclaredNames.push(bindingIdentifier);\n    });\n    return this;\n  }\n  observeVarBoundary() {\n    this.lexicallyDeclaredNames = new MultiMap();\n    this.functionDeclarationNames = new MultiMap();\n    this.varDeclaredNames = new MultiMap();\n    this.forOfVarDeclaredNames = [];\n    return this;\n  }\n  exportName(name, node) {\n    this.exportedNames.set(name, node);\n    return this;\n  }\n  exportDeclaredNames() {\n    addEach(this.exportedNames, this.lexicallyDeclaredNames, this.varDeclaredNames);\n    addEach(this.exportedBindings, this.lexicallyDeclaredNames, this.varDeclaredNames);\n    return this;\n  }\n  exportBinding(name, node) {\n    this.exportedBindings.set(name, node);\n    return this;\n  }\n  clearExportedBindings() {\n    this.exportedBindings = new MultiMap();\n    return this;\n  }\n  observeYieldExpression(node) {\n    this.yieldExpressions.push(node);\n    return this;\n  }\n  clearYieldExpressions() {\n    this.yieldExpressions = [];\n    return this;\n  }\n  observeAwaitExpression(node) {\n    this.awaitExpressions.push(node);\n    return this;\n  }\n  clearAwaitExpressions() {\n    this.awaitExpressions = [];\n    return this;\n  }\n  addError(e) {\n    this.errors.push(e);\n    return this;\n  }\n  addStrictError(e) {\n    this.strictErrors.push(e);\n    return this;\n  }\n  enforceStrictErrors() {\n    [].push.apply(this.errors, this.strictErrors);\n    this.strictErrors = [];\n    return this;\n  }\n\n  // MONOID IMPLEMENTATION\n\n  static empty() {\n    return identity;\n  }\n  concat(s) {\n    if (this === identity) return s;\n    if (s === identity) return this;\n    [].push.apply(this.errors, s.errors);\n    [].push.apply(this.strictErrors, s.strictErrors);\n    [].push.apply(this.usedLabelNames, s.usedLabelNames);\n    [].push.apply(this.freeBreakStatements, s.freeBreakStatements);\n    [].push.apply(this.freeContinueStatements, s.freeContinueStatements);\n    [].push.apply(this.freeLabeledBreakStatements, s.freeLabeledBreakStatements);\n    [].push.apply(this.freeLabeledContinueStatements, s.freeLabeledContinueStatements);\n    [].push.apply(this.newTargetExpressions, s.newTargetExpressions);\n    addEach(this.boundNames, s.boundNames);\n    addEach(this.lexicallyDeclaredNames, s.lexicallyDeclaredNames);\n    addEach(this.functionDeclarationNames, s.functionDeclarationNames);\n    addEach(this.varDeclaredNames, s.varDeclaredNames);\n    [].push.apply(this.forOfVarDeclaredNames, s.forOfVarDeclaredNames);\n    addEach(this.exportedNames, s.exportedNames);\n    addEach(this.exportedBindings, s.exportedBindings);\n    [].push.apply(this.superCallExpressions, s.superCallExpressions);\n    [].push.apply(this.superCallExpressionsInConstructorMethod, s.superCallExpressionsInConstructorMethod);\n    [].push.apply(this.superPropertyExpressions, s.superPropertyExpressions);\n    [].push.apply(this.yieldExpressions, s.yieldExpressions);\n    [].push.apply(this.awaitExpressions, s.awaitExpressions);\n    return this;\n  }\n}\nidentity = new EarlyErrorState();\nObject.getOwnPropertyNames(EarlyErrorState.prototype).forEach(methodName => {\n  if (methodName === 'constructor') return;\n  Object.defineProperty(identity, methodName, {\n    value() {\n      return EarlyErrorState.prototype[methodName].apply(new EarlyErrorState(), arguments);\n    },\n    enumerable: false,\n    writable: true,\n    configurable: true\n  });\n});\nclass EarlyError extends Error {\n  constructor(node, message) {\n    super(message);\n    this.node = node;\n    this.message = message;\n  }\n}\nmodule.exports = {\n  EarlyErrorState,\n  EarlyError\n};","map":{"version":3,"names":["MultiMap","require","addEach","thisMap","otherMaps","forEach","otherMap","forEachEntry","v","k","set","apply","concat","identity","EarlyErrorState","constructor","errors","strictErrors","usedLabelNames","freeBreakStatements","freeContinueStatements","freeLabeledBreakStatements","freeLabeledContinueStatements","newTargetExpressions","boundNames","lexicallyDeclaredNames","functionDeclarationNames","varDeclaredNames","forOfVarDeclaredNames","exportedNames","exportedBindings","superCallExpressions","superCallExpressionsInConstructorMethod","superPropertyExpressions","yieldExpressions","awaitExpressions","addFreeBreakStatement","s","push","addFreeLabeledBreakStatement","clearFreeBreakStatements","addFreeContinueStatement","addFreeLabeledContinueStatement","clearFreeContinueStatements","enforceFreeBreakStatementErrors","createError","map","enforceFreeLabeledBreakStatementErrors","enforceFreeContinueStatementErrors","enforceFreeLabeledContinueStatementErrors","observeIterationLabel","label","filter","observeNonIterationLabel","clearUsedLabelNames","observeSuperCallExpression","node","observeConstructorMethod","clearSuperCallExpressionsInConstructorMethod","enforceSuperCallExpressions","enforceSuperCallExpressionsInConstructorMethod","observeSuperPropertyExpression","clearSuperPropertyExpressions","enforceSuperPropertyExpressions","observeNewTargetExpression","clearNewTargetExpressions","bindName","name","clearBoundNames","observeLexicalDeclaration","observeLexicalBoundary","previousLexicallyDeclaredNames","enforceDuplicateLexicallyDeclaredNames","nodes","length","slice","dupeNode","addError","enforceConflictingLexicallyDeclaredNames","otherNames","bindingName","has","conflictingNode","observeFunctionDeclaration","observeVarBoundary","functionDeclarationNamesAreLexical","observeVarDeclaration","recordForOfVars","bindingIdentifier","exportName","exportDeclaredNames","exportBinding","clearExportedBindings","observeYieldExpression","clearYieldExpressions","observeAwaitExpression","clearAwaitExpressions","e","addStrictError","enforceStrictErrors","empty","Object","getOwnPropertyNames","prototype","methodName","defineProperty","value","arguments","enumerable","writable","configurable","EarlyError","Error","message","module","exports"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/shift-parser/src/early-error-state.js"],"sourcesContent":["/**\n * Copyright 2014 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst MultiMap = require('multimap');\n\nfunction addEach(thisMap, ...otherMaps) {\n  otherMaps.forEach(otherMap => {\n    otherMap.forEachEntry((v, k) => {\n      thisMap.set.apply(thisMap, [k].concat(v));\n    });\n  });\n  return thisMap;\n}\n\nlet identity; // initialised below EarlyErrorState\n\nclass EarlyErrorState {\n\n  constructor() {\n    this.errors = [];\n    // errors that are only errors in strict mode code\n    this.strictErrors = [];\n\n    // Label values used in LabeledStatement nodes; cleared at function boundaries\n    this.usedLabelNames = [];\n\n    // BreakStatement nodes; cleared at iteration; switch; and function boundaries\n    this.freeBreakStatements = [];\n    // ContinueStatement nodes; cleared at\n    this.freeContinueStatements = [];\n\n    // labeled BreakStatement nodes; cleared at LabeledStatement with same Label and function boundaries\n    this.freeLabeledBreakStatements = [];\n    // labeled ContinueStatement nodes; cleared at labeled iteration statement with same Label and function boundaries\n    this.freeLabeledContinueStatements = [];\n\n    // NewTargetExpression nodes; cleared at function (besides arrow expression) boundaries\n    this.newTargetExpressions = [];\n\n    // BindingIdentifier nodes; cleared at containing declaration node\n    this.boundNames = new MultiMap;\n    // BindingIdentifiers that were found to be in a lexical binding position\n    this.lexicallyDeclaredNames = new MultiMap;\n    // BindingIdentifiers that were the name of a FunctionDeclaration\n    this.functionDeclarationNames = new MultiMap;\n    // BindingIdentifiers that were found to be in a variable binding position\n    this.varDeclaredNames = new MultiMap;\n    // BindingIdentifiers that were found to be in a variable binding position\n    this.forOfVarDeclaredNames = [];\n\n    // Names that this module exports\n    this.exportedNames = new MultiMap;\n    // Locally declared names that are referenced in export declarations\n    this.exportedBindings = new MultiMap;\n\n    // CallExpressions with Super callee\n    this.superCallExpressions = [];\n    // SuperCall expressions in the context of a Method named \"constructor\"\n    this.superCallExpressionsInConstructorMethod = [];\n    // MemberExpressions with Super object\n    this.superPropertyExpressions = [];\n\n    // YieldExpression and YieldGeneratorExpression nodes; cleared at function boundaries\n    this.yieldExpressions = [];\n    // AwaitExpression nodes; cleared at function boundaries\n    this.awaitExpressions = [];\n  }\n\n\n  addFreeBreakStatement(s) {\n    this.freeBreakStatements.push(s);\n    return this;\n  }\n\n  addFreeLabeledBreakStatement(s) {\n    this.freeLabeledBreakStatements.push(s);\n    return this;\n  }\n\n  clearFreeBreakStatements() {\n    this.freeBreakStatements = [];\n    return this;\n  }\n\n  addFreeContinueStatement(s) {\n    this.freeContinueStatements.push(s);\n    return this;\n  }\n\n  addFreeLabeledContinueStatement(s) {\n    this.freeLabeledContinueStatements.push(s);\n    return this;\n  }\n\n  clearFreeContinueStatements() {\n    this.freeContinueStatements = [];\n    return this;\n  }\n\n  enforceFreeBreakStatementErrors(createError) {\n    [].push.apply(this.errors, this.freeBreakStatements.map(createError));\n    this.freeBreakStatements = [];\n    return this;\n  }\n\n  enforceFreeLabeledBreakStatementErrors(createError) {\n    [].push.apply(this.errors, this.freeLabeledBreakStatements.map(createError));\n    this.freeLabeledBreakStatements = [];\n    return this;\n  }\n\n  enforceFreeContinueStatementErrors(createError) {\n    [].push.apply(this.errors, this.freeContinueStatements.map(createError));\n    this.freeContinueStatements = [];\n    return this;\n  }\n\n  enforceFreeLabeledContinueStatementErrors(createError) {\n    [].push.apply(this.errors, this.freeLabeledContinueStatements.map(createError));\n    this.freeLabeledContinueStatements = [];\n    return this;\n  }\n\n\n  observeIterationLabel(label) {\n    this.usedLabelNames.push(label);\n    this.freeLabeledBreakStatements = this.freeLabeledBreakStatements.filter(s => s.label !== label);\n    this.freeLabeledContinueStatements = this.freeLabeledContinueStatements.filter(s => s.label !== label);\n    return this;\n  }\n\n  observeNonIterationLabel(label) {\n    this.usedLabelNames.push(label);\n    this.freeLabeledBreakStatements = this.freeLabeledBreakStatements.filter(s => s.label !== label);\n    return this;\n  }\n\n  clearUsedLabelNames() {\n    this.usedLabelNames = [];\n    return this;\n  }\n\n\n  observeSuperCallExpression(node) {\n    this.superCallExpressions.push(node);\n    return this;\n  }\n\n  observeConstructorMethod() {\n    this.superCallExpressionsInConstructorMethod = this.superCallExpressions;\n    this.superCallExpressions = [];\n    return this;\n  }\n\n  clearSuperCallExpressionsInConstructorMethod() {\n    this.superCallExpressionsInConstructorMethod = [];\n    return this;\n  }\n\n  enforceSuperCallExpressions(createError) {\n    [].push.apply(this.errors, this.superCallExpressions.map(createError));\n    [].push.apply(this.errors, this.superCallExpressionsInConstructorMethod.map(createError));\n    this.superCallExpressions = [];\n    this.superCallExpressionsInConstructorMethod = [];\n    return this;\n  }\n\n  enforceSuperCallExpressionsInConstructorMethod(createError) {\n    [].push.apply(this.errors, this.superCallExpressionsInConstructorMethod.map(createError));\n    this.superCallExpressionsInConstructorMethod = [];\n    return this;\n  }\n\n\n  observeSuperPropertyExpression(node) {\n    this.superPropertyExpressions.push(node);\n    return this;\n  }\n\n  clearSuperPropertyExpressions() {\n    this.superPropertyExpressions = [];\n    return this;\n  }\n\n  enforceSuperPropertyExpressions(createError) {\n    [].push.apply(this.errors, this.superPropertyExpressions.map(createError));\n    this.superPropertyExpressions = [];\n    return this;\n  }\n\n\n  observeNewTargetExpression(node) {\n    this.newTargetExpressions.push(node);\n    return this;\n  }\n\n  clearNewTargetExpressions() {\n    this.newTargetExpressions = [];\n    return this;\n  }\n\n\n  bindName(name, node) {\n    this.boundNames.set(name, node);\n    return this;\n  }\n\n  clearBoundNames() {\n    this.boundNames = new MultiMap;\n    return this;\n  }\n\n  observeLexicalDeclaration() {\n    addEach(this.lexicallyDeclaredNames, this.boundNames);\n    this.boundNames = new MultiMap;\n    return this;\n  }\n\n  observeLexicalBoundary() {\n    this.previousLexicallyDeclaredNames = this.lexicallyDeclaredNames;\n    this.lexicallyDeclaredNames = new MultiMap;\n    this.functionDeclarationNames = new MultiMap;\n    return this;\n  }\n\n  enforceDuplicateLexicallyDeclaredNames(createError) {\n    this.lexicallyDeclaredNames.forEachEntry(nodes => {\n      if (nodes.length > 1) {\n        nodes.slice(1).forEach(dupeNode => {\n          this.addError(createError(dupeNode));\n        });\n      }\n    });\n    return this;\n  }\n\n  enforceConflictingLexicallyDeclaredNames(otherNames, createError) {\n    this.lexicallyDeclaredNames.forEachEntry((nodes, bindingName) => {\n      if (otherNames.has(bindingName)) {\n        nodes.forEach(conflictingNode => {\n          this.addError(createError(conflictingNode));\n        });\n      }\n    });\n    return this;\n  }\n\n  observeFunctionDeclaration() {\n    this.observeVarBoundary();\n    addEach(this.functionDeclarationNames, this.boundNames);\n    this.boundNames = new MultiMap;\n    return this;\n  }\n\n  functionDeclarationNamesAreLexical() {\n    addEach(this.lexicallyDeclaredNames, this.functionDeclarationNames);\n    this.functionDeclarationNames = new MultiMap;\n    return this;\n  }\n\n  observeVarDeclaration() {\n    addEach(this.varDeclaredNames, this.boundNames);\n    this.boundNames = new MultiMap;\n    return this;\n  }\n\n  recordForOfVars() {\n    this.varDeclaredNames.forEach(bindingIdentifier => {\n      this.forOfVarDeclaredNames.push(bindingIdentifier);\n    });\n    return this;\n  }\n\n  observeVarBoundary() {\n    this.lexicallyDeclaredNames = new MultiMap;\n    this.functionDeclarationNames = new MultiMap;\n    this.varDeclaredNames = new MultiMap;\n    this.forOfVarDeclaredNames = [];\n    return this;\n  }\n\n\n  exportName(name, node) {\n    this.exportedNames.set(name, node);\n    return this;\n  }\n\n  exportDeclaredNames() {\n    addEach(this.exportedNames, this.lexicallyDeclaredNames, this.varDeclaredNames);\n    addEach(this.exportedBindings, this.lexicallyDeclaredNames, this.varDeclaredNames);\n    return this;\n  }\n\n  exportBinding(name, node) {\n    this.exportedBindings.set(name, node);\n    return this;\n  }\n\n  clearExportedBindings() {\n    this.exportedBindings = new MultiMap;\n    return this;\n  }\n\n\n  observeYieldExpression(node) {\n    this.yieldExpressions.push(node);\n    return this;\n  }\n\n  clearYieldExpressions() {\n    this.yieldExpressions = [];\n    return this;\n  }\n\n  observeAwaitExpression(node) {\n    this.awaitExpressions.push(node);\n    return this;\n  }\n\n  clearAwaitExpressions() {\n    this.awaitExpressions = [];\n    return this;\n  }\n\n\n  addError(e) {\n    this.errors.push(e);\n    return this;\n  }\n\n  addStrictError(e) {\n    this.strictErrors.push(e);\n    return this;\n  }\n\n  enforceStrictErrors() {\n    [].push.apply(this.errors, this.strictErrors);\n    this.strictErrors = [];\n    return this;\n  }\n\n\n  // MONOID IMPLEMENTATION\n\n  static empty() {\n    return identity;\n  }\n\n  concat(s) {\n    if (this === identity) return s;\n    if (s === identity) return this;\n    [].push.apply(this.errors, s.errors);\n    [].push.apply(this.strictErrors, s.strictErrors);\n    [].push.apply(this.usedLabelNames, s.usedLabelNames);\n    [].push.apply(this.freeBreakStatements, s.freeBreakStatements);\n    [].push.apply(this.freeContinueStatements, s.freeContinueStatements);\n    [].push.apply(this.freeLabeledBreakStatements, s.freeLabeledBreakStatements);\n    [].push.apply(this.freeLabeledContinueStatements, s.freeLabeledContinueStatements);\n    [].push.apply(this.newTargetExpressions, s.newTargetExpressions);\n    addEach(this.boundNames, s.boundNames);\n    addEach(this.lexicallyDeclaredNames, s.lexicallyDeclaredNames);\n    addEach(this.functionDeclarationNames, s.functionDeclarationNames);\n    addEach(this.varDeclaredNames, s.varDeclaredNames);\n    [].push.apply(this.forOfVarDeclaredNames, s.forOfVarDeclaredNames);\n    addEach(this.exportedNames, s.exportedNames);\n    addEach(this.exportedBindings, s.exportedBindings);\n    [].push.apply(this.superCallExpressions, s.superCallExpressions);\n    [].push.apply(this.superCallExpressionsInConstructorMethod, s.superCallExpressionsInConstructorMethod);\n    [].push.apply(this.superPropertyExpressions, s.superPropertyExpressions);\n    [].push.apply(this.yieldExpressions, s.yieldExpressions);\n    [].push.apply(this.awaitExpressions, s.awaitExpressions);\n    return this;\n  }\n\n}\n\nidentity = new EarlyErrorState;\nObject.getOwnPropertyNames(EarlyErrorState.prototype).forEach(methodName => {\n  if (methodName === 'constructor') return;\n  Object.defineProperty(identity, methodName, {\n    value() {\n      return EarlyErrorState.prototype[methodName].apply(new EarlyErrorState, arguments);\n    },\n    enumerable: false,\n    writable: true,\n    configurable: true,\n  });\n});\n\nclass EarlyError extends Error {\n  constructor(node, message) {\n    super(message);\n    this.node = node;\n    this.message = message;\n  }\n}\n\nmodule.exports = {\n  EarlyErrorState,\n  EarlyError,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}