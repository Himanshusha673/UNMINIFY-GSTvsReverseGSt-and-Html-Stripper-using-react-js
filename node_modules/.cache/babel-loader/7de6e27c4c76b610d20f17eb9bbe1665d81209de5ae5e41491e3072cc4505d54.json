{"ast":null,"code":"'use strict';\n\n// Inline constant primitive variables, constant primitive object properties, and constant object properties which are particularly trivial functions.\nconst shiftScope = require('shift-scope');\nconst reducer = require('shift-reducer');\nconst Shift = require('shift-ast/checked');\nconst getParents = require('../../helpers/parents');\nconst inlinable = require('../../helpers/inlinable');\nmodule.exports = function inline(ast) {\n  const globalScope = shiftScope.default(ast);\n  const lookup = new shiftScope.ScopeLookup(globalScope);\n  const parents = getParents(ast);\n  function findScopeForNode(node, scope = globalScope) {\n    // TODO this should live elsewhere\n    if (scope.astNode === node) return scope;\n    for (let child of scope.children) {\n      const r = findScopeForNode(node, child);\n      if (r !== null) return r;\n    }\n    return null;\n  }\n  function isConstantInitializedVariable(v) {\n    if (!isConstantVariable(v)) {\n      return false;\n    }\n    const parent = parents.get(v.declarations[0].node);\n    if (parent.type !== 'VariableDeclarator') {\n      return false;\n    }\n    return parent.init !== null;\n  }\n  function isConstantVariable(v) {\n    // TODO this also needs to check that use-before-def is impossible\n    if (v.declarations.length !== 1) return false;\n    const binding = v.declarations[0].node;\n    const parent = parents.get(binding);\n    if (parent.type !== 'VariableDeclarator' && parent.type !== 'FormalParameters') return false;\n    if (v.references.some(r => r.accessibility.isWrite && r.node !== binding)) return false;\n    return true;\n  }\n  function getConstantObjectVariableObject(_var) {\n    // TODO for this to be actually correct we'd also need to check that none of the properties of the object are functions binding 'this'\n    if (!isConstantInitializedVariable(_var)) return null;\n    const binding = _var.declarations[0].node;\n    const parent = parents.get(binding);\n    if (parent.init == null) return null;\n    if (parent.init.type === 'ObjectExpression' || parent.init.type === 'ArrayExpression') {\n      if (_var.references.some(r => {\n        const rparent = parents.get(r.node);\n        return rparent.type === 'StaticMemberAssignmentTarget' || rparent.type === 'ComputedMemberAssignmentTarget' && rparent.object === r.node;\n      })) return null;\n      const obj = parent.init;\n      if (obj.type === 'ObjectExpression') {\n        return new Map(obj.properties.filter(p => p.type === 'DataProperty' && p.name.type === 'StaticPropertyName').map(p => [p.name.value, p.expression])); // TODO could include methods, in principle\n      } else if (obj.type === 'ArrayExpression') {\n        return new Map(obj.elements.map((v, i) => [i, v]));\n      }\n      throw 'not reached;';\n    } else {\n      return null;\n    }\n  }\n  function findStatementParent(node) {\n    while (!/Statement/.test(node.type) && node.type !== 'FunctionDeclaration') {\n      // eslint-disable-next-line no-param-reassign\n      node = parents.get(node);\n    }\n    return node;\n  }\n  function getInlining(node) {\n    const vars = lookup.lookup(node);\n    if (vars.length !== 1) return null;\n    const v = vars[0];\n    if (!isConstantInitializedVariable(v)) return null;\n    const init = parents.get(v.declarations[0].node).init;\n    if (init.type === 'IdentifierExpression') {\n      const indirectVars = lookup.lookup(init);\n      if (indirectVars.length === 1 && isConstantVariable(indirectVars[0])) {\n        return new Shift.IdentifierExpression(init);\n      }\n    }\n    if (!inlinable.includes(init.type)) return null;\n    return {\n      ...init\n    };\n  }\n  function getTriviallyInlineableFunction(f, arglen) {\n    if (f.type !== 'FunctionExpression') return null;\n    if (f.params.items.length !== arglen) return null;\n    if (f.body.directives.length > 0) return null;\n    if (f.body.statements.length !== 1) return null;\n    if (f.body.statements[0].type !== 'ReturnStatement') return null;\n    if (f.body.statements[0].expression.type !== 'BinaryExpression') return null;\n    const expr = f.body.statements[0].expression;\n    if (arglen === 2) {\n      if (expr.left.type !== 'IdentifierExpression' || lookup.lookup(expr.left)[0] !== lookup.lookup(f.params.items[0])[0]) return null;\n      if (expr.right.type !== 'IdentifierExpression' || lookup.lookup(expr.right)[0] !== lookup.lookup(f.params.items[1])[0]) return null;\n      return (left, right) => new Shift.BinaryExpression({\n        left,\n        operator: expr.operator,\n        right\n      });\n    } else if (arglen === 3) {\n      if (expr.left.type !== 'BinaryExpression') return null;\n      const expr2 = expr.left;\n      if (expr2.left.type !== 'IdentifierExpression' || lookup.lookup(expr2.left)[0] !== lookup.lookup(f.params.items[0])[0]) return null;\n      if (expr2.right.type !== 'IdentifierExpression' || lookup.lookup(expr2.right)[0] !== lookup.lookup(f.params.items[1])[0]) return null;\n      if (expr.right.type !== 'IdentifierExpression' || lookup.lookup(expr.right)[0] !== lookup.lookup(f.params.items[2])[0]) return null;\n      return (a, b, right) => new Shift.BinaryExpression({\n        left: new Shift.BinaryExpression({\n          left: a,\n          operator: expr2.operator,\n          right: b\n        }),\n        operator: expr.operator,\n        right\n      });\n    }\n    return null;\n  }\n  class InliningReducer extends reducer.LazyCloneReducer {\n    reduceExpressionStatement(node, {\n      expression\n    }) {\n      if (expression.type === 'IdentifierExpression') {\n        return new Shift.EmptyStatement();\n      }\n      return super.reduceExpressionStatement(node, {\n        expression\n      });\n    }\n    reduceCallExpression(node, {\n      callee,\n      arguments: _arguments\n    }) {\n      if (callee.type === 'StaticMemberExpression' && callee.object.type === 'IdentifierExpression' && (_arguments.length === 2 || _arguments.length === 3)) {\n        const vs = lookup.lookup(node.callee.object);\n        if (vs.length === 1) {\n          const obj = getConstantObjectVariableObject(vs[0]);\n          if (obj !== null && obj.has(callee.property)) {\n            const val = obj.get(callee.property);\n            const replacer = getTriviallyInlineableFunction(val, _arguments.length);\n            if (replacer !== null) {\n              return replacer(..._arguments);\n            }\n          }\n        }\n      } else if (callee.type === 'IdentifierExpression') {\n        const vs = lookup.lookup(node.callee);\n        if (vs.length === 1 && isConstantInitializedVariable(vs[0]) && lookup.scope.variableList.indexOf(vs[0]) === -1) {\n          const v = vs[0];\n          const decl = parents.get(v.declarations[0].node);\n          if (decl.init.type === 'FunctionExpression') {\n            const f = decl.init;\n            let scope = findScopeForNode(f);\n            if (scope !== null && scope.through.size === 0) {\n              // This is to handle specifically `var x = function (foo) { if (foo == 'bar') { return a; } else { return b; } }; y = x('bar'); z = x('baz'); w = x();`\n              if (f.params.items.length === 1 && _arguments.length <= 1) {\n                const pv = lookup.lookup(f.params.items[0])[0];\n                if (pv.references.length === 1 && f.body.statements.length === 1 && f.body.statements[0].type === 'IfStatement') {\n                  const consequent = f.body.statements[0].consequent;\n                  const alternate = f.body.statements[0].alternate;\n                  if (consequent.type === 'BlockStatement' && consequent.block.statements.length === 1 && consequent.block.statements[0].type === 'ReturnStatement' && alternate.type === 'BlockStatement' && alternate.block.statements.length === 1 && alternate.block.statements[0].type === 'ReturnStatement') {\n                    const test = f.body.statements[0].test;\n                    if (test.type === 'BinaryExpression' && test.operator.slice(0, 2) === '==' && test.left.type === 'IdentifierExpression' && lookup.lookup(test.left)[0] === pv && inlinable.includes(test.right.type)) {\n                      const conditional = new Shift.ConditionalExpression({\n                        test: {\n                          ...test\n                        },\n                        consequent: consequent.block.statements[0].expression,\n                        alternate: alternate.block.statements[0].expression\n                      });\n                      if (_arguments.length === 1) {\n                        conditional.test.left = _arguments[0];\n                      } else {\n                        conditional.test.left = new Shift.UnaryExpression({\n                          operator: 'void',\n                          operand: new Shift.LiteralNumericExpression({\n                            value: 0\n                          })\n                        });\n                      }\n                      return conditional;\n                    }\n                  }\n                }\n              }\n            }\n            if (v.references.length === 2) {\n              // inline functions which are only called once\n              const p1 = findStatementParent(v.references[0].node);\n              const p2 = findStatementParent(v.references[0].node);\n              if (scope.through.size === 0 || parents.get(p1) === parents.get(p2)) {\n                // This ensures any through references get resolved the same after inlining\n                return new Shift.CallExpression({\n                  callee: reducer.default(new reducer.CloneReducer(), f),\n                  arguments: _arguments\n                });\n              }\n            }\n          }\n        }\n      }\n      return super.reduceCallExpression(node, {\n        callee,\n        arguments: _arguments\n      });\n    }\n    reduceIdentifierExpression(node) {\n      const inlining = getInlining(node);\n      if (inlining !== null) return inlining;\n      return super.reduceIdentifierExpression(node);\n    }\n    reduceComputedMemberExpression(node, {\n      object,\n      expression\n    }) {\n      if (node.object.type === 'IdentifierExpression' && expression.type === 'LiteralNumericExpression') {\n        const vs = lookup.lookup(node.object);\n        if (vs.length === 1) {\n          const obj = getConstantObjectVariableObject(vs[0]);\n          if (obj !== null && obj.has(expression.value)) {\n            const val = obj.get(expression.value);\n            if (inlinable.includes(val.type)) {\n              return new Shift[val.type](val);\n            }\n          }\n        }\n      }\n      return super.reduceComputedMemberExpression(node, {\n        object,\n        expression\n      }); // new Shift.ComputedMemberExpression({object, expression});\n    }\n    reduceStaticMemberExpression(node, {\n      object\n    }) {\n      if (node.object.type === 'IdentifierExpression') {\n        const vs = lookup.lookup(node.object);\n        if (vs.length === 1) {\n          const obj = getConstantObjectVariableObject(vs[0]);\n          if (obj !== null && obj.has(node.property)) {\n            const val = obj.get(node.property);\n            if (inlinable.includes(val.type)) {\n              return {\n                ...val\n              };\n            }\n          }\n        }\n      }\n      return super.reduceStaticMemberExpression(node, {\n        object\n      });\n    }\n  }\n  return reducer.default(new InliningReducer(), ast);\n};","map":{"version":3,"names":["shiftScope","require","reducer","Shift","getParents","inlinable","module","exports","inline","ast","globalScope","default","lookup","ScopeLookup","parents","findScopeForNode","node","scope","astNode","child","children","r","isConstantInitializedVariable","v","isConstantVariable","parent","get","declarations","type","init","length","binding","references","some","accessibility","isWrite","getConstantObjectVariableObject","_var","rparent","object","obj","Map","properties","filter","p","name","map","value","expression","elements","i","findStatementParent","test","getInlining","vars","indirectVars","IdentifierExpression","includes","getTriviallyInlineableFunction","f","arglen","params","items","body","directives","statements","expr","left","right","BinaryExpression","operator","expr2","a","b","InliningReducer","LazyCloneReducer","reduceExpressionStatement","EmptyStatement","reduceCallExpression","callee","arguments","_arguments","vs","has","property","val","replacer","variableList","indexOf","decl","through","size","pv","consequent","alternate","block","slice","conditional","ConditionalExpression","UnaryExpression","operand","LiteralNumericExpression","p1","p2","CallExpression","CloneReducer","reduceIdentifierExpression","inlining","reduceComputedMemberExpression","reduceStaticMemberExpression"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/unminify/src/transforms/wildly-unsafe/inline.js"],"sourcesContent":["'use strict';\n\n// Inline constant primitive variables, constant primitive object properties, and constant object properties which are particularly trivial functions.\n\nconst shiftScope = require('shift-scope');\nconst reducer = require('shift-reducer');\nconst Shift = require('shift-ast/checked');\n\nconst getParents = require('../../helpers/parents');\nconst inlinable = require('../../helpers/inlinable');\n\n\nmodule.exports = function inline(ast) {\n\n  const globalScope = shiftScope.default(ast);\n  const lookup = new shiftScope.ScopeLookup(globalScope);\n  const parents = getParents(ast);\n\n  function findScopeForNode(node, scope = globalScope) {\n    // TODO this should live elsewhere\n    if (scope.astNode === node) return scope;\n    for (let child of scope.children) {\n      const r = findScopeForNode(node, child);\n      if (r !== null) return r;\n    }\n    return null;\n  }\n\n  function isConstantInitializedVariable(v) {\n    if (!isConstantVariable(v)) {\n      return false;\n    }\n    const parent = parents.get(v.declarations[0].node);\n    if (parent.type !== 'VariableDeclarator') {\n      return false;\n    }\n    return parent.init !== null;\n  }\n\n  function isConstantVariable(v) {\n    // TODO this also needs to check that use-before-def is impossible\n    if (v.declarations.length !== 1) return false;\n    const binding = v.declarations[0].node;\n    const parent = parents.get(binding);\n    if (parent.type !== 'VariableDeclarator' && parent.type !== 'FormalParameters') return false;\n    if (v.references.some(r => r.accessibility.isWrite && r.node !== binding)) return false;\n    return true;\n  }\n\n  function getConstantObjectVariableObject(_var) {\n    // TODO for this to be actually correct we'd also need to check that none of the properties of the object are functions binding 'this'\n    if (!isConstantInitializedVariable(_var)) return null;\n    const binding = _var.declarations[0].node;\n    const parent = parents.get(binding);\n    if (parent.init == null) return null;\n    if (parent.init.type === 'ObjectExpression' || parent.init.type === 'ArrayExpression') {\n      if (_var.references.some(r => {\n        const rparent = parents.get(r.node);\n        return rparent.type === 'StaticMemberAssignmentTarget' || rparent.type === 'ComputedMemberAssignmentTarget' && rparent.object === r.node;\n      })) return null;\n      const obj = parent.init;\n\n      if (obj.type === 'ObjectExpression') {\n        return new Map(obj.properties.filter(p => p.type === 'DataProperty' && p.name.type === 'StaticPropertyName').map(p => [p.name.value, p.expression])); // TODO could include methods, in principle\n      } else if (obj.type === 'ArrayExpression') {\n        return new Map(obj.elements.map((v, i) => [i, v]));\n      }\n      throw 'not reached;';\n\n    } else {\n      return null;\n    }\n  }\n\n  function findStatementParent(node) {\n    while (!/Statement/.test(node.type) && node.type !== 'FunctionDeclaration') {\n      // eslint-disable-next-line no-param-reassign\n      node = parents.get(node);\n    }\n    return node;\n  }\n\n\n  function getInlining(node) {\n    const vars = lookup.lookup(node);\n    if (vars.length !== 1) return null;\n    const v = vars[0];\n    if (!isConstantInitializedVariable(v)) return null;\n    const init = parents.get(v.declarations[0].node).init;\n    if (init.type === 'IdentifierExpression') {\n      const indirectVars = lookup.lookup(init);\n      if (indirectVars.length === 1 && isConstantVariable(indirectVars[0])) {\n        return new Shift.IdentifierExpression(init);\n      }\n    }\n    if (!inlinable.includes(init.type)) return null;\n\n    return { ...init };\n  }\n\n\n  function getTriviallyInlineableFunction(f, arglen) {\n    if (f.type !== 'FunctionExpression') return null;\n    if (f.params.items.length !== arglen) return null;\n    if (f.body.directives.length > 0) return null;\n    if (f.body.statements.length !== 1) return null;\n    if (f.body.statements[0].type !== 'ReturnStatement') return null;\n    if (f.body.statements[0].expression.type !== 'BinaryExpression') return null;\n    const expr = f.body.statements[0].expression;\n\n    if (arglen === 2) {\n      if (expr.left.type !== 'IdentifierExpression' || lookup.lookup(expr.left)[0] !== lookup.lookup(f.params.items[0])[0]) return null;\n      if (expr.right.type !== 'IdentifierExpression' || lookup.lookup(expr.right)[0] !== lookup.lookup(f.params.items[1])[0]) return null;\n      return (left, right) => new Shift.BinaryExpression({ left, operator: expr.operator, right });\n    } else if (arglen === 3) {\n      if (expr.left.type !== 'BinaryExpression') return null;\n      const expr2 = expr.left;\n      if (expr2.left.type !== 'IdentifierExpression' || lookup.lookup(expr2.left)[0] !== lookup.lookup(f.params.items[0])[0]) return null;\n      if (expr2.right.type !== 'IdentifierExpression' || lookup.lookup(expr2.right)[0] !== lookup.lookup(f.params.items[1])[0]) return null;\n      if (expr.right.type !== 'IdentifierExpression' || lookup.lookup(expr.right)[0] !== lookup.lookup(f.params.items[2])[0]) return null;\n\n      return (a, b, right) => new Shift.BinaryExpression({ left: new Shift.BinaryExpression({ left: a, operator: expr2.operator, right: b }), operator: expr.operator, right });\n    }\n    return null;\n  }\n\n  class InliningReducer extends reducer.LazyCloneReducer {\n    reduceExpressionStatement(node, { expression }) {\n      if (expression.type === 'IdentifierExpression') {\n        return new Shift.EmptyStatement;\n      }\n      return super.reduceExpressionStatement(node, { expression });\n    }\n\n    reduceCallExpression(node, { callee, arguments: _arguments }) {\n      if (callee.type === 'StaticMemberExpression' && callee.object.type === 'IdentifierExpression' && (_arguments.length === 2 || _arguments.length === 3)) {\n        const vs = lookup.lookup(node.callee.object);\n        if (vs.length === 1) {\n          const obj = getConstantObjectVariableObject(vs[0]);\n          if (obj !== null && obj.has(callee.property)) {\n            const val = obj.get(callee.property);\n            const replacer = getTriviallyInlineableFunction(val, _arguments.length);\n            if (replacer !== null) {\n              return replacer(..._arguments);\n            }\n          }\n        }\n      } else if (callee.type === 'IdentifierExpression') {\n        const vs = lookup.lookup(node.callee);\n        if (vs.length === 1 && isConstantInitializedVariable(vs[0]) && lookup.scope.variableList.indexOf(vs[0]) === -1) {\n          const v = vs[0];\n          const decl = parents.get(v.declarations[0].node);\n          if (decl.init.type === 'FunctionExpression') {\n            const f = decl.init;\n            let scope = findScopeForNode(f);\n            if (scope !== null && scope.through.size === 0) {\n\n              // This is to handle specifically `var x = function (foo) { if (foo == 'bar') { return a; } else { return b; } }; y = x('bar'); z = x('baz'); w = x();`\n              if (f.params.items.length === 1 && _arguments.length <= 1) {\n                const pv = lookup.lookup(f.params.items[0])[0];\n                if (pv.references.length === 1 && f.body.statements.length === 1 && f.body.statements[0].type === 'IfStatement') {\n                  const consequent = f.body.statements[0].consequent;\n                  const alternate = f.body.statements[0].alternate;\n                  if (consequent.type === 'BlockStatement' && consequent.block.statements.length === 1 && consequent.block.statements[0].type === 'ReturnStatement' && alternate.type === 'BlockStatement' && alternate.block.statements.length === 1 && alternate.block.statements[0].type === 'ReturnStatement') {\n                    const test = f.body.statements[0].test;\n                    if (test.type === 'BinaryExpression' && test.operator.slice(0, 2) === '==' && test.left.type === 'IdentifierExpression' && lookup.lookup(test.left)[0] === pv && inlinable.includes(test.right.type)) {\n                      const conditional = new Shift.ConditionalExpression({ test: { ...test }, consequent: consequent.block.statements[0].expression, alternate: alternate.block.statements[0].expression });\n                      if (_arguments.length === 1) {\n                        conditional.test.left = _arguments[0];\n                      } else {\n                        conditional.test.left = new Shift.UnaryExpression({ operator: 'void', operand: new Shift.LiteralNumericExpression({ value: 0 }) });\n                      }\n                      return conditional;\n                    }\n                  }\n                }\n              }\n            }\n\n            if (v.references.length === 2) {\n              // inline functions which are only called once\n              const p1 = findStatementParent(v.references[0].node);\n              const p2 = findStatementParent(v.references[0].node);\n              if (scope.through.size === 0 || parents.get(p1) === parents.get(p2)) {\n                // This ensures any through references get resolved the same after inlining\n                return new Shift.CallExpression({ callee: reducer.default(new reducer.CloneReducer, f), arguments: _arguments });\n              }\n            }\n          }\n        }\n      }\n      return super.reduceCallExpression(node, { callee, arguments: _arguments });\n    }\n\n    reduceIdentifierExpression(node) {\n      const inlining = getInlining(node);\n      if (inlining !== null) return inlining;\n      return super.reduceIdentifierExpression(node);\n    }\n\n    reduceComputedMemberExpression(node, { object, expression }) {\n      if (node.object.type === 'IdentifierExpression' && expression.type === 'LiteralNumericExpression') {\n        const vs = lookup.lookup(node.object);\n        if (vs.length === 1) {\n          const obj = getConstantObjectVariableObject(vs[0]);\n          if (obj !== null && obj.has(expression.value)) {\n            const val = obj.get(expression.value);\n            if (inlinable.includes(val.type)) {\n              return new Shift[val.type](val);\n            }\n          }\n        }\n      }\n      return super.reduceComputedMemberExpression(node, { object, expression });// new Shift.ComputedMemberExpression({object, expression});\n    }\n\n    reduceStaticMemberExpression(node, { object }) {\n      if (node.object.type === 'IdentifierExpression') {\n        const vs = lookup.lookup(node.object);\n        if (vs.length === 1) {\n          const obj = getConstantObjectVariableObject(vs[0]);\n          if (obj !== null && obj.has(node.property)) {\n            const val = obj.get(node.property);\n            if (inlinable.includes(val.type)) {\n              return { ...val };\n            }\n          }\n        }\n      }\n      return super.reduceStaticMemberExpression(node, { object });\n    }\n  }\n\n  return reducer.default(new InliningReducer, ast);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}