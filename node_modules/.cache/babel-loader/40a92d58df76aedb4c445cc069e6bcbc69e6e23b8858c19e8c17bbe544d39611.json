{"ast":null,"code":"'use strict';\n\n/* eslint-disable no-param-reassign */\n// Basically de-uglify-js\nconst reducer = require('shift-reducer');\nconst Shift = require('shift-ast/checked');\nconst inlinable = require('../../helpers/inlinable');\nconst {\n  functionContainsWeirdness\n} = require('../../helpers/fn-contains-weirdness');\nconst esutils = require('esutils');\n\n// TODO convert switches to if/else\n\nfunction makeBlock(statement) {\n  return new Shift.BlockStatement({\n    block: new Shift.Block({\n      statements: [statement]\n    })\n  });\n}\nfunction negate(expr, isBooleanContext, requireResult = true) {\n  if (expr.type === 'LiteralBooleanExpression') {\n    return new Shift.LiteralBooleanExpression({\n      value: !expr.value\n    });\n  } else if (expr.type === 'LiteralNumericExpression') {\n    return new Shift.LiteralBooleanExpression({\n      value: !expr.value\n    });\n  } else if (expr.type === 'ArrayExpression' && expr.elements.length === 0) {\n    return new Shift.LiteralBooleanExpression({\n      value: false\n    });\n  } else if (expr.type === 'ObjectExpression' && expr.properties.length === 0) {\n    return new Shift.LiteralBooleanExpression({\n      value: false\n    });\n  } else if (expr.type === 'BinaryExpression') {\n    if (expr.operator === '&&') {\n      return new Shift.BinaryExpression({\n        left: negate(expr.left, isBooleanContext),\n        operator: '||',\n        right: negate(expr.right, isBooleanContext)\n      });\n    } else if (expr.operator === '||') {\n      return new Shift.BinaryExpression({\n        left: negate(expr.left, isBooleanContext),\n        operator: '&&',\n        right: negate(expr.right, isBooleanContext)\n      });\n    } else if (expr.operator === '==') {\n      return new Shift.BinaryExpression({\n        left: expr.left,\n        operator: '!=',\n        right: expr.right\n      });\n    } else if (expr.operator === '===') {\n      return new Shift.BinaryExpression({\n        left: expr.left,\n        operator: '!==',\n        right: expr.right\n      });\n    } else if (expr.operator === '!=') {\n      return new Shift.BinaryExpression({\n        left: expr.left,\n        operator: '==',\n        right: expr.right\n      });\n    } else if (expr.operator === '!==') {\n      return new Shift.BinaryExpression({\n        left: expr.left,\n        operator: '===',\n        right: expr.right\n      });\n    }\n  } else if (expr.type === 'UnaryExpression' && expr.operator === '!' && isBooleanContext) {\n    return {\n      ...expr.operand\n    };\n  }\n  if (!requireResult) {\n    return null;\n  }\n  return new Shift.UnaryExpression({\n    operator: '!',\n    operand: expr\n  });\n}\nfunction isConstant(node) {\n  return inlinable.includes(node.type) || node.type === 'UnaryExpression' && inlinable.includes(node.operand.type);\n}\nfunction isSequence(expr) {\n  return expr != null && expr.type === 'BinaryExpression' && expr.operator === ',';\n}\n\n// NB: only for use with associative operators\nfunction binExprToExprs(expr) {\n  const operator = expr.operator;\n  return [...binExprToExprsHelper(expr.left, operator), ...binExprToExprsHelper(expr.right, operator)];\n}\nfunction binExprToExprsHelper(expr, operator) {\n  if (expr.type === 'BinaryExpression' && expr.operator === operator) {\n    return [...binExprToExprsHelper(expr.left, operator), ...binExprToExprsHelper(expr.right, operator)];\n  }\n  return [expr];\n}\nfunction declaratorsToDeclarationStatements(kind, declarators) {\n  return declarators.map(d => new Shift.VariableDeclarationStatement({\n    declaration: new Shift.VariableDeclaration({\n      kind,\n      declarators: [d]\n    })\n  }));\n}\nclass OnlyReturnUndefined extends reducer.LazyCloneReducer {\n  // TODO this would be better thunked.\n  reduceFunctionBody(node) {\n    return node;\n  }\n  reduceReturnStatement(node, {\n    expression\n  }) {\n    if (expression === null || expression.type === 'UnaryExpression' && expression.operator === 'void') {\n      return node;\n    }\n    if (expression.type === 'UnaryExpression' && expression.operator === 'void') {\n      return node;\n    }\n    const undef = new Shift.UnaryExpression({\n      operator: 'void',\n      operand: expression\n    });\n    return new Shift.ReturnStatement({\n      expression: undef\n    });\n  }\n}\nconst onlyReturnUndefined = new OnlyReturnUndefined();\nfunction makeReturnsUndefined(fnBody) {\n  const fixed = fnBody.statements.map(s => reducer.default(onlyReturnUndefined, s));\n  if (arrayEquals(fixed, fnBody.statements)) {\n    return fnBody;\n  }\n  return new Shift.FunctionBody({\n    directives: fnBody.directives,\n    statements: fixed\n  });\n}\nlet booleanBinOps = ['==', '!=', '===', '!==', '<', '<=', '>', '>=', 'in', 'instanceof'];\nfunction returnsBoolean(expr) {\n  return expr.type === 'LiteralBooleanExpression' || expr.type === 'UnaryExpression' && expr.operator === '!' || expr.type === 'BinaryExpression' && booleanBinOps.includes(expr.operator) || expr.type === 'BinaryExpression' && (expr.operator === '&&' || expr.operator === '||') && returnsBoolean(expr.left) && returnsBoolean(expr.right) || expr.type === 'BinaryExpression' && expr.operator === ',' && returnsBoolean(expr.right) || expr.type === 'ConditionalExpression' && returnsBoolean(expr.consequent) && returnsBoolean(expr.alternate);\n}\n\n/*\nThis function takes an expression like\n\n  a && (b, c, d) && e\n\nand returns an object with three properties:\n\n- prefix, a conjunction of all the clauses before the sequence expression, or `null` if there are none\n- seqs, a list of all expressions in the sequence expression save the last\n- suffix, a conjuction of the last item in the sequence expression with all the clauses after the sequence expression\n\nIf the expression is not a conjunction of clauses at least one of which is a sequence, returns `null`.\n\nIf `isBooleanContext` is true, it will additionally require that each clause in the prefix returns a boolean.\n\nIn this example, assuming `isBooleanContext` is false, it would return\n{\n  prefix: a\n  seqs: [b, c]\n  suffix: d && e\n}\n*/\nfunction extractSequenceFromConjunction(expr, isBooleanContext) {\n  if (expr.type !== 'BinaryExpression' || expr.operator !== '&&') {\n    return null;\n  }\n  const clauses = binExprToExprs(expr);\n  for (let i = 0; i < clauses.length; ++i) {\n    if (isSequence(clauses[i])) {\n      const seqs = binExprToExprs(clauses[i]);\n      const last = seqs.pop();\n      return {\n        prefix: i === 0 ? null : clauses.slice(0, i).reduce((acc, e) => new Shift.BinaryExpression({\n          left: acc,\n          operator: '&&',\n          right: e\n        })),\n        seqs,\n        suffix: clauses.slice(i + 1).reduce((acc, e) => new Shift.BinaryExpression({\n          left: acc,\n          operator: '&&',\n          right: e\n        }), last)\n      };\n    }\n    if (!isBooleanContext && !returnsBoolean(clauses[i])) {\n      break;\n    }\n  }\n  return null;\n}\nfunction fixStatementList(statements) {\n  // strip empty statements\n  // turn sequence expressions in statement position into multiple statements\n  // turn variable declarations with multiple declarators into multiple statements\n  // for (var a, b, c;;); -> var a; var b; for (var c;;);\n  const o = [];\n  for (const s of statements) {\n    switch (s.type) {\n      case 'EmptyStatement':\n        break;\n      case 'TryCatchStatement':\n        if (s.body.statements.length === 0) {\n          o.push(new Shift.IfStatement({\n            test: new Shift.LiteralBooleanExpression({\n              value: false\n            }),\n            consequent: new Shift.BlockStatement({\n              block: s.catchClause.body\n            }),\n            alternate: null\n          }));\n        } else {\n          o.push(s);\n        }\n        break;\n      case 'ExpressionStatement':\n        if (isSequence(s.expression)) {\n          o.push(...binExprToExprs(s.expression).map(e => new Shift.ExpressionStatement({\n            expression: e\n          })));\n        } else if (inlinable.includes(s.expression.type) || s.expression.type === 'ThisExpression' || s.expression.type === 'FunctionExpression') {\n          // TODO local IdentifierExpressions\n          continue;\n        } else if (s.expression.type === 'UnaryExpression' && s.expression.operator === 'void') {\n          if (inlinable.includes(s.expression.operand.type)) {\n            continue;\n          }\n          o.push(new Shift.ExpressionStatement({\n            expression: s.expression.operand\n          }));\n        } else {\n          o.push(s);\n        }\n        break;\n      case 'ThrowStatement':\n        if (isSequence(s.expression)) {\n          const exprs = binExprToExprs(s.expression);\n          const last = exprs.pop();\n          o.push(...exprs.map(e => new Shift.ExpressionStatement({\n            expression: e\n          })));\n          o.push(new Shift.ThrowStatement({\n            expression: last\n          }));\n        } else {\n          o.push(s);\n        }\n        break;\n      case 'ReturnStatement':\n        if (s.expression === null) {\n          o.push(s);\n        } else if (isSequence(s.expression)) {\n          const exprs = binExprToExprs(s.expression);\n          const last = exprs.pop();\n          o.push(...exprs.map(e => new Shift.ExpressionStatement({\n            expression: e\n          })));\n          o.push(new Shift.ReturnStatement({\n            expression: last\n          }));\n        } else if (s.expression.type === 'ConditionalExpression') {\n          const consequent = new Shift.ReturnStatement({\n            expression: s.expression.consequent\n          });\n          const alternate = new Shift.ReturnStatement({\n            expression: s.expression.alternate\n          });\n          o.push(new Shift.IfStatement({\n            test: s.expression.test,\n            consequent,\n            alternate\n          }));\n        } else if (s.expression.type === 'BinaryExpression' && s.expression.operator === '&&') {\n          const extracted = extractSequenceFromConjunction(s.expression, false);\n          if (extracted === null) {\n            o.push(s);\n          } else {\n            const {\n              prefix,\n              seqs,\n              suffix\n            } = extracted;\n            if (prefix !== null) {\n              o.push(new Shift.IfStatement({\n                test: negate(prefix, true),\n                consequent: new Shift.BlockStatement({\n                  block: new Shift.Block({\n                    statements: [new Shift.ReturnStatement({\n                      expression: new Shift.LiteralBooleanExpression({\n                        value: false\n                      })\n                    })]\n                  })\n                }),\n                alternate: null\n              }));\n            }\n            o.push(...seqs.map(e => new Shift.ExpressionStatement({\n              expression: e\n            })));\n            o.push(new Shift.ReturnStatement({\n              expression: suffix\n            }));\n          }\n        } else if (s.expression.type === 'UnaryExpression' && s.expression.operator === 'void') {\n          o.push(new Shift.ExpressionStatement({\n            expression: s.expression.operand\n          }));\n          o.push(new Shift.ReturnStatement({\n            expression: null\n          }));\n        } else {\n          o.push(s);\n        }\n        // TODO: elsewhere, remove statements after returns (while preserving hoisted declarations)\n        break;\n      case 'BlockStatement':\n        if (s.block.statements.every(x => x.type !== 'FunctionDeclaration' && (x.type !== 'VariableDeclarationStatement' || x.declaration.kind === 'var'))) {\n          o.push(...s.block.statements);\n        } else {\n          o.push(s);\n        }\n        break;\n      case 'IfStatement':\n        if (isSequence(s.test)) {\n          const exprs = binExprToExprs(s.test);\n          const last = exprs.pop();\n          o.push(...exprs.map(e => new Shift.ExpressionStatement({\n            expression: e\n          })));\n          o.push(new Shift.IfStatement({\n            test: last,\n            consequent: s.consequent,\n            alternate: s.alternate\n          }));\n        } else if (s.test.type === 'BinaryExpression' && s.test.operator === '&&' && s.alternate == null) {\n          const extracted = extractSequenceFromConjunction(s.test, true);\n          if (extracted === null) {\n            o.push(s);\n          } else {\n            const {\n              prefix,\n              seqs,\n              suffix\n            } = extracted;\n            let newStatements = seqs.map(e => new Shift.ExpressionStatement({\n              expression: e\n            }));\n            newStatements.push(new Shift.IfStatement({\n              test: suffix,\n              consequent: s.consequent,\n              alternate: null\n            }));\n            if (prefix === null) {\n              o.push(...newStatements);\n            } else {\n              o.push(new Shift.IfStatement({\n                test: prefix,\n                consequent: new Shift.BlockStatement({\n                  block: new Shift.Block({\n                    statements: newStatements\n                  })\n                }),\n                alternate: null\n              }));\n            }\n          }\n        } else {\n          o.push(s);\n        }\n        break;\n      case 'VariableDeclarationStatement':\n        if (s.declaration.declarators.length > 1) {\n          o.push(...declaratorsToDeclarationStatements(s.declaration.kind, s.declaration.declarators));\n        } else if (isSequence(s.declaration.declarators[0].init)) {\n          let originalDeclarator = s.declaration.declarators[0];\n          // Yes, these steps could be combined, but /shrug\n          const exprs = binExprToExprs(originalDeclarator.init);\n          const last = exprs.pop();\n          o.push(...exprs.map(e => new Shift.ExpressionStatement({\n            expression: e\n          })));\n          const declarator = new Shift.VariableDeclarator({\n            binding: originalDeclarator.binding,\n            init: last\n          });\n          const declaration = new Shift.VariableDeclaration({\n            kind: s.declaration.kind,\n            declarators: [declarator]\n          });\n          o.push(new Shift.VariableDeclarationStatement({\n            declaration\n          }));\n        } else {\n          o.push(s);\n        }\n        break;\n      case 'ForStatement':\n        if (s.init != null) {\n          if (s.init.type === 'VariableDeclaration' && s.init.declarators.length > 1) {\n            const declarators = [...s.init.declarators];\n            const finalDeclarator = declarators.pop();\n            const newDeclaration = new Shift.VariableDeclaration({\n              kind: s.init.kind,\n              declarators: [finalDeclarator]\n            });\n            o.push(...declaratorsToDeclarationStatements(s.init.kind, declarators));\n            o.push(new Shift.ForStatement({\n              init: newDeclaration,\n              test: s.test,\n              update: s.update,\n              body: s.body\n            }));\n          } else if (isSequence(s.init)) {\n            const exprs = binExprToExprs(s.init);\n            const last = exprs.pop();\n            o.push(...exprs.map(e => new Shift.ExpressionStatement({\n              expression: e\n            })));\n            o.push(new Shift.ForStatement({\n              init: last,\n              test: s.test,\n              update: s.update,\n              body: s.body\n            }));\n          } else {\n            o.push(s);\n          }\n        }\n        break;\n      default:\n        o.push(s);\n    }\n  }\n  if (arrayEquals(o, statements)) {\n    return statements;\n  }\n  return o;\n}\nfunction arrayEquals(a, b) {\n  return a.length === b.length && a.every((v, i) => v === b[i]);\n}\nfunction hoistFunctionDeclarations(statements) {\n  const decls = [];\n  const nonDecls = [];\n  for (const statement of statements) {\n    if (statement.type === 'FunctionDeclaration') {\n      decls.push(statement);\n    } else {\n      nonDecls.push(statement);\n    }\n  }\n  const o = decls.concat(nonDecls);\n  if (arrayEquals(o, statements)) {\n    return statements;\n  }\n  return o;\n}\nclass Cleanup extends reducer.LazyCloneReducer {\n  reduceBlock(node, {\n    statements\n  }) {\n    return super.reduceBlock(node, {\n      statements: fixStatementList(statements)\n    });\n  }\n  reduceSwitchCase(node, {\n    test,\n    consequent\n  }) {\n    return super.reduceSwitchCase(node, {\n      test,\n      consequent: fixStatementList(consequent)\n    });\n  }\n  reduceSwitchDefault(node, {\n    consequent\n  }) {\n    return super.reduceSwitchDefault(node, {\n      consequent: fixStatementList(consequent)\n    });\n  }\n  reduceFunctionBody(node, {\n    directives,\n    statements\n  }) {\n    statements = hoistFunctionDeclarations(fixStatementList(statements));\n    if (directives.length === 0 && statements.length === 1 && (statements[0].type === 'ExpressionStatement' || statements[0].type === 'ReturnStatement') && statements[0].expression != null && statements[0].expression.type === 'CallExpression' && statements[0].expression.arguments.length === 0) {\n      const callee = statements[0].expression.callee;\n      if (callee.type === 'FunctionExpression' && callee.name === null && callee.params.items.length === 0 && callee.params.rest === null && !functionContainsWeirdness(callee)) {\n        return statements[0].type === 'ExpressionStatement' ? makeReturnsUndefined(callee.body) : callee.body;\n      }\n    }\n    if (statements.length > 0 && statements[statements.length - 1].type === 'ReturnStatement' && statements[statements.length - 1].expression == null) {\n      statements = statements.slice(0, -1);\n    }\n    return super.reduceFunctionBody(node, {\n      directives,\n      statements\n    });\n  }\n  reduceScript(node, {\n    directives,\n    statements\n  }) {\n    return super.reduceScript(node, {\n      directives,\n      statements: fixStatementList(statements)\n    });\n  }\n  reduceUnaryExpression(node, {\n    operand\n  }) {\n    if (node.operator === '!') {\n      const negated = negate(operand, false, false);\n      if (negated) {\n        return negated;\n      }\n    }\n    return super.reduceUnaryExpression(node, {\n      operand\n    });\n  }\n  reduceBinaryExpression(node, {\n    left,\n    right\n  }) {\n    // 1 == a -> a == 1\n    if (['==', '===', '!=', '!=='].includes(node.operator) && isConstant(left) && !isConstant(right)) {\n      return new Shift.BinaryExpression({\n        left: right,\n        operator: node.operator,\n        right: left\n      });\n    }\n    if (node.operator === ',' && inlinable.includes(left.type)) {\n      return right;\n    }\n    return super.reduceBinaryExpression(node, {\n      left,\n      right\n    });\n  }\n  reduceExpressionStatement(node, {\n    expression\n  }) {\n    if (expression.type === 'ConditionalExpression') {\n      return new Shift.IfStatement({\n        test: expression.test,\n        consequent: new Shift.ExpressionStatement({\n          expression: expression.consequent\n        }),\n        alternate: new Shift.ExpressionStatement({\n          expression: expression.alternate\n        })\n      });\n    } else if (expression.type === 'BinaryExpression' && expression.operator === '&&') {\n      return new Shift.IfStatement({\n        test: expression.left,\n        consequent: new Shift.ExpressionStatement({\n          expression: expression.right\n        }),\n        alternate: null\n      });\n    } else if (expression.type === 'BinaryExpression' && expression.operator === '||') {\n      return new Shift.IfStatement({\n        test: new Shift.UnaryExpression({\n          operator: '!',\n          operand: expression.left\n        }),\n        consequent: new Shift.ExpressionStatement({\n          expression: expression.right\n        }),\n        alternate: null\n      });\n    } else if (expression.type === 'UnaryExpression' && expression.operator === '!') {\n      return new Shift.ExpressionStatement({\n        expression: expression.operand\n      });\n    }\n    return super.reduceExpressionStatement(node, {\n      expression\n    });\n  }\n  reduceIfStatement(node, {\n    test,\n    consequent,\n    alternate\n  }) {\n    if (test.type === 'UnaryExpression' && test.operator === '!') {\n      test = negate(test.operand, true, false) || test;\n    }\n    if (test.type === 'BinaryExpression' && (test.operator === '!=' || test.operator === '!==') && alternate != null) {\n      test = negate(test, true);\n      [consequent, alternate] = [alternate, consequent];\n    }\n    if (consequent.type !== 'BlockStatement') {\n      consequent = makeBlock(consequent);\n    }\n    if (alternate != null) {\n      if (alternate.type !== 'BlockStatement' && alternate.type !== 'IfStatement') {\n        alternate = makeBlock(alternate);\n      } else if (alternate.type === 'BlockStatement' && alternate.block.statements.length === 1 && alternate.block.statements[0].type === 'IfStatement') {\n        alternate = alternate.block.statements[0];\n      }\n      if (alternate.type === 'BlockStatement' && alternate.block.statements.length === 0) {\n        alternate = null;\n      }\n    }\n    return super.reduceIfStatement(node, {\n      test,\n      consequent,\n      alternate\n    });\n  }\n  reduceConditionalExpression(node, {\n    test,\n    consequent,\n    alternate\n  }) {\n    if (test.type === 'UnaryExpression' && test.operator === '!') {\n      test = negate(test.operand, true, false) || test;\n    }\n    return super.reduceConditionalExpression(node, {\n      test,\n      consequent,\n      alternate\n    });\n  }\n  reduceForStatement(node, {\n    init,\n    test,\n    update,\n    body\n  }) {\n    if (body.type !== 'BlockStatement') {\n      body = makeBlock(body);\n    }\n    if (init == null && test != null && update == null) {\n      return new Shift.WhileStatement({\n        test,\n        body\n      });\n    }\n    return super.reduceForStatement(node, {\n      init,\n      test,\n      update,\n      body\n    });\n  }\n  reduceForInStatement(node, {\n    left,\n    right,\n    body\n  }) {\n    if (body.type !== 'BlockStatement') {\n      body = makeBlock(body);\n    }\n    return super.reduceForInStatement(node, {\n      left,\n      right,\n      body\n    });\n  }\n  reduceForOfStatement(node, {\n    left,\n    right,\n    body\n  }) {\n    if (body.type !== 'BlockStatement') {\n      body = makeBlock(body);\n    }\n    return super.reduceForOfStatement(node, {\n      left,\n      right,\n      body\n    });\n  }\n  reduceWhileStatement(node, {\n    test,\n    body\n  }) {\n    if (body.type !== 'BlockStatement') {\n      body = makeBlock(body);\n    }\n    return super.reduceWhileStatement(node, {\n      test,\n      body\n    });\n  }\n  reduceDoWhileStatement(node, {\n    body,\n    test\n  }) {\n    if (body.type !== 'BlockStatement') {\n      body = makeBlock(body);\n    }\n    return super.reduceDoWhileStatement(node, {\n      body,\n      test\n    });\n  }\n  reduceComputedMemberAssignmentTarget(node, {\n    object,\n    expression\n  }) {\n    if (expression.type === 'LiteralStringExpression' && esutils.keyword.isIdentifierNameES6(expression.value)) {\n      return new Shift.StaticMemberAssignmentTarget({\n        object,\n        property: expression.value\n      });\n    }\n    return super.reduceComputedMemberAssignmentTarget(node, {\n      object,\n      expression\n    });\n  }\n  reduceComputedMemberExpression(node, {\n    object,\n    expression\n  }) {\n    if (expression.type === 'LiteralStringExpression' && esutils.keyword.isIdentifierNameES6(expression.value)) {\n      return new Shift.StaticMemberExpression({\n        object,\n        property: expression.value\n      });\n    }\n    return super.reduceComputedMemberExpression(node, {\n      object,\n      expression\n    });\n  }\n  reduceCallExpression(node, {\n    callee,\n    arguments: _arguments\n  }) {\n    if (callee.type === 'FunctionExpression' && !callee.isGenerator && !functionContainsWeirdness(callee)) {\n      if (_arguments.length === 0 && callee.params.rest === null && callee.params.items.length === 0 && callee.body.directives.length === 0 && callee.body.statements.length <= 1) {\n        // turn iifes with very simple bodies into expressions with no calls\n        if (callee.body.statements.length === 0) {\n          return new Shift.UnaryExpression({\n            operator: 'void',\n            operand: new Shift.LiteralNullExpression()\n          });\n        }\n        const statement = callee.body.statements[0];\n        if (statement.type === 'ReturnStatement') {\n          return statement.expression;\n        }\n        if (statement.type === 'ExpressionStatement') {\n          return new Shift.BinaryExpression({\n            left: statement.expression,\n            operator: ',',\n            right: new Shift.UnaryExpression({\n              operator: 'void',\n              operand: new Shift.LiteralNullExpression()\n            })\n          }); // `(expr, void 0)`\n        }\n      }\n    }\n    return super.reduceCallExpression(node, {\n      callee,\n      arguments: _arguments\n    });\n  }\n}\nconst cleaner = new Cleanup();\nmodule.exports = function cleanup(ast) {\n  return reducer.default(cleaner, ast);\n};","map":{"version":3,"names":["reducer","require","Shift","inlinable","functionContainsWeirdness","esutils","makeBlock","statement","BlockStatement","block","Block","statements","negate","expr","isBooleanContext","requireResult","type","LiteralBooleanExpression","value","elements","length","properties","operator","BinaryExpression","left","right","operand","UnaryExpression","isConstant","node","includes","isSequence","binExprToExprs","binExprToExprsHelper","declaratorsToDeclarationStatements","kind","declarators","map","d","VariableDeclarationStatement","declaration","VariableDeclaration","OnlyReturnUndefined","LazyCloneReducer","reduceFunctionBody","reduceReturnStatement","expression","undef","ReturnStatement","onlyReturnUndefined","makeReturnsUndefined","fnBody","fixed","s","default","arrayEquals","FunctionBody","directives","booleanBinOps","returnsBoolean","consequent","alternate","extractSequenceFromConjunction","clauses","i","seqs","last","pop","prefix","slice","reduce","acc","e","suffix","fixStatementList","o","body","push","IfStatement","test","catchClause","ExpressionStatement","exprs","ThrowStatement","extracted","every","x","newStatements","init","originalDeclarator","declarator","VariableDeclarator","binding","finalDeclarator","newDeclaration","ForStatement","update","a","b","v","hoistFunctionDeclarations","decls","nonDecls","concat","Cleanup","reduceBlock","reduceSwitchCase","reduceSwitchDefault","arguments","callee","name","params","items","rest","reduceScript","reduceUnaryExpression","negated","reduceBinaryExpression","reduceExpressionStatement","reduceIfStatement","reduceConditionalExpression","reduceForStatement","WhileStatement","reduceForInStatement","reduceForOfStatement","reduceWhileStatement","reduceDoWhileStatement","reduceComputedMemberAssignmentTarget","object","keyword","isIdentifierNameES6","StaticMemberAssignmentTarget","property","reduceComputedMemberExpression","StaticMemberExpression","reduceCallExpression","_arguments","isGenerator","LiteralNullExpression","cleaner","module","exports","cleanup","ast"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/unminify/src/transforms/safe/cleanup.js"],"sourcesContent":["'use strict';\n\n/* eslint-disable no-param-reassign */\n// Basically de-uglify-js\n\nconst reducer = require('shift-reducer');\nconst Shift = require('shift-ast/checked');\n\nconst inlinable = require('../../helpers/inlinable');\nconst { functionContainsWeirdness } = require('../../helpers/fn-contains-weirdness');\n\nconst esutils = require('esutils');\n\n\n// TODO convert switches to if/else\n\nfunction makeBlock(statement) {\n  return new Shift.BlockStatement({ block: new Shift.Block({ statements: [statement] }) });\n}\n\nfunction negate(expr, isBooleanContext, requireResult = true) {\n  if (expr.type === 'LiteralBooleanExpression') {\n    return new Shift.LiteralBooleanExpression({ value: !expr.value });\n  } else if (expr.type === 'LiteralNumericExpression') {\n    return new Shift.LiteralBooleanExpression({ value: !expr.value });\n  } else if (expr.type === 'ArrayExpression' && expr.elements.length === 0) {\n    return new Shift.LiteralBooleanExpression({ value: false });\n  } else if (expr.type === 'ObjectExpression' && expr.properties.length === 0) {\n    return new Shift.LiteralBooleanExpression({ value: false });\n  } else if (expr.type === 'BinaryExpression') {\n    if (expr.operator === '&&') {\n      return new Shift.BinaryExpression({ left: negate(expr.left, isBooleanContext), operator: '||', right: negate(expr.right, isBooleanContext) });\n    } else if (expr.operator === '||') {\n      return new Shift.BinaryExpression({ left: negate(expr.left, isBooleanContext), operator: '&&', right: negate(expr.right, isBooleanContext) });\n    } else if (expr.operator === '==') {\n      return new Shift.BinaryExpression({ left: expr.left, operator: '!=', right: expr.right });\n    } else if (expr.operator === '===') {\n      return new Shift.BinaryExpression({ left: expr.left, operator: '!==', right: expr.right });\n    } else if (expr.operator === '!=') {\n      return new Shift.BinaryExpression({ left: expr.left, operator: '==', right: expr.right });\n    } else if (expr.operator === '!==') {\n      return new Shift.BinaryExpression({ left: expr.left, operator: '===', right: expr.right });\n    }\n  } else if (expr.type === 'UnaryExpression' && expr.operator === '!' && isBooleanContext) {\n    return { ...expr.operand };\n  }\n  if (!requireResult) {\n    return null;\n  }\n  return new Shift.UnaryExpression({ operator: '!', operand: expr });\n}\n\nfunction isConstant(node) {\n  return inlinable.includes(node.type)\n    || node.type === 'UnaryExpression' && inlinable.includes(node.operand.type);\n}\n\nfunction isSequence(expr) {\n  return expr != null && expr.type === 'BinaryExpression' && expr.operator === ',';\n}\n\n// NB: only for use with associative operators\nfunction binExprToExprs(expr) {\n  const operator = expr.operator;\n  return [...binExprToExprsHelper(expr.left, operator), ...binExprToExprsHelper(expr.right, operator)];\n}\n\nfunction binExprToExprsHelper(expr, operator) {\n  if (expr.type === 'BinaryExpression' && expr.operator === operator) {\n    return [...binExprToExprsHelper(expr.left, operator), ...binExprToExprsHelper(expr.right, operator)];\n  }\n  return [expr];\n}\n\nfunction declaratorsToDeclarationStatements(kind, declarators) {\n  return declarators.map(d => new Shift.VariableDeclarationStatement({ declaration: new Shift.VariableDeclaration({ kind, declarators: [d] }) }));\n}\n\n\nclass OnlyReturnUndefined extends reducer.LazyCloneReducer { // TODO this would be better thunked.\n  reduceFunctionBody(node) {\n    return node;\n  }\n\n  reduceReturnStatement(node, { expression }) {\n    if (expression === null || expression.type === 'UnaryExpression' && expression.operator === 'void') {\n      return node;\n    }\n    if (expression.type === 'UnaryExpression' && expression.operator === 'void') {\n      return node;\n    }\n    const undef = new Shift.UnaryExpression({ operator: 'void', operand: expression });\n    return new Shift.ReturnStatement({ expression: undef });\n  }\n}\nconst onlyReturnUndefined = new OnlyReturnUndefined;\n\nfunction makeReturnsUndefined(fnBody) {\n  const fixed = fnBody.statements.map(s => reducer.default(onlyReturnUndefined, s));\n  if (arrayEquals(fixed, fnBody.statements)) {\n    return fnBody;\n  }\n  return new Shift.FunctionBody({ directives: fnBody.directives, statements: fixed });\n}\n\nlet booleanBinOps = ['==', '!=', '===', '!==', '<', '<=', '>', '>=', 'in', 'instanceof'];\nfunction returnsBoolean(expr) {\n  return expr.type === 'LiteralBooleanExpression'\n    || expr.type === 'UnaryExpression' && expr.operator === '!'\n    || expr.type === 'BinaryExpression' && booleanBinOps.includes(expr.operator)\n    || expr.type === 'BinaryExpression' && (expr.operator === '&&' || expr.operator === '||') && returnsBoolean(expr.left) && returnsBoolean(expr.right)\n    || expr.type === 'BinaryExpression' && expr.operator === ',' && returnsBoolean(expr.right)\n    || expr.type === 'ConditionalExpression' && returnsBoolean(expr.consequent) && returnsBoolean(expr.alternate);\n}\n\n/*\nThis function takes an expression like\n\n  a && (b, c, d) && e\n\nand returns an object with three properties:\n\n- prefix, a conjunction of all the clauses before the sequence expression, or `null` if there are none\n- seqs, a list of all expressions in the sequence expression save the last\n- suffix, a conjuction of the last item in the sequence expression with all the clauses after the sequence expression\n\nIf the expression is not a conjunction of clauses at least one of which is a sequence, returns `null`.\n\nIf `isBooleanContext` is true, it will additionally require that each clause in the prefix returns a boolean.\n\nIn this example, assuming `isBooleanContext` is false, it would return\n{\n  prefix: a\n  seqs: [b, c]\n  suffix: d && e\n}\n*/\nfunction extractSequenceFromConjunction(expr, isBooleanContext) {\n  if (expr.type !== 'BinaryExpression' || expr.operator !== '&&') {\n    return null;\n  }\n  const clauses = binExprToExprs(expr);\n  for (let i = 0; i < clauses.length; ++i) {\n    if (isSequence(clauses[i])) {\n      const seqs = binExprToExprs(clauses[i]);\n      const last = seqs.pop();\n      return {\n        prefix: i === 0 ? null : clauses.slice(0, i).reduce((acc, e) => new Shift.BinaryExpression({ left: acc, operator: '&&', right: e })),\n        seqs,\n        suffix: clauses.slice(i + 1).reduce((acc, e) => new Shift.BinaryExpression({ left: acc, operator: '&&', right: e }), last),\n      };\n    }\n    if (!isBooleanContext && !returnsBoolean(clauses[i])) {\n      break;\n    }\n  }\n  return null;\n}\n\nfunction fixStatementList(statements) {\n  // strip empty statements\n  // turn sequence expressions in statement position into multiple statements\n  // turn variable declarations with multiple declarators into multiple statements\n  // for (var a, b, c;;); -> var a; var b; for (var c;;);\n  const o = [];\n  for (const s of statements) {\n    switch (s.type) {\n      case 'EmptyStatement':\n        break;\n      case 'TryCatchStatement':\n        if (s.body.statements.length === 0) {\n          o.push(new Shift.IfStatement({ test: new Shift.LiteralBooleanExpression({ value: false }), consequent: new Shift.BlockStatement({ block: s.catchClause.body }), alternate: null }));\n        } else {\n          o.push(s);\n        }\n        break;\n      case 'ExpressionStatement':\n        if (isSequence(s.expression)) {\n          o.push(...binExprToExprs(s.expression).map(e => new Shift.ExpressionStatement({ expression: e })));\n        } else if (inlinable.includes(s.expression.type) || s.expression.type === 'ThisExpression' || s.expression.type === 'FunctionExpression') { // TODO local IdentifierExpressions\n          continue;\n        } else if (s.expression.type === 'UnaryExpression' && s.expression.operator === 'void') {\n          if (inlinable.includes(s.expression.operand.type)) {\n            continue;\n          }\n          o.push(new Shift.ExpressionStatement({ expression: s.expression.operand }));\n        } else {\n          o.push(s);\n        }\n        break;\n      case 'ThrowStatement':\n        if (isSequence(s.expression)) {\n          const exprs = binExprToExprs(s.expression);\n          const last = exprs.pop();\n          o.push(...exprs.map(e => new Shift.ExpressionStatement({ expression: e })));\n          o.push(new Shift.ThrowStatement({ expression: last }));\n        } else {\n          o.push(s);\n        }\n        break;\n      case 'ReturnStatement':\n        if (s.expression === null) {\n          o.push(s);\n        } else if (isSequence(s.expression)) {\n          const exprs = binExprToExprs(s.expression);\n          const last = exprs.pop();\n          o.push(...exprs.map(e => new Shift.ExpressionStatement({ expression: e })));\n          o.push(new Shift.ReturnStatement({ expression: last }));\n        } else if (s.expression.type === 'ConditionalExpression') {\n          const consequent = new Shift.ReturnStatement({ expression: s.expression.consequent });\n          const alternate = new Shift.ReturnStatement({ expression: s.expression.alternate });\n          o.push(new Shift.IfStatement({ test: s.expression.test, consequent, alternate }));\n        } else if (s.expression.type === 'BinaryExpression' && s.expression.operator === '&&') {\n          const extracted = extractSequenceFromConjunction(s.expression, false);\n          if (extracted === null) {\n            o.push(s);\n          } else {\n            const { prefix, seqs, suffix } = extracted;\n            if (prefix !== null) {\n              o.push(new Shift.IfStatement({\n                test: negate(prefix, true),\n                consequent: new Shift.BlockStatement({ block: new Shift.Block({ statements: [new Shift.ReturnStatement({ expression: new Shift.LiteralBooleanExpression({ value: false }) })] }) }),\n                alternate: null,\n              }));\n            }\n            o.push(...seqs.map(e => new Shift.ExpressionStatement({ expression: e })));\n            o.push(new Shift.ReturnStatement({ expression: suffix }));\n          }\n        } else if (s.expression.type === 'UnaryExpression' && s.expression.operator === 'void') {\n          o.push(new Shift.ExpressionStatement({ expression: s.expression.operand }));\n          o.push(new Shift.ReturnStatement({ expression: null }));\n        } else {\n          o.push(s);\n        }\n        // TODO: elsewhere, remove statements after returns (while preserving hoisted declarations)\n        break;\n      case 'BlockStatement':\n        if (s.block.statements.every(x => x.type !== 'FunctionDeclaration' && (x.type !== 'VariableDeclarationStatement' || x.declaration.kind === 'var'))) {\n          o.push(...s.block.statements);\n        } else {\n          o.push(s);\n        }\n        break;\n      case 'IfStatement':\n        if (isSequence(s.test)) {\n          const exprs = binExprToExprs(s.test);\n          const last = exprs.pop();\n          o.push(...exprs.map(e => new Shift.ExpressionStatement({ expression: e })));\n          o.push(new Shift.IfStatement({ test: last, consequent: s.consequent, alternate: s.alternate }));\n        } else if (s.test.type === 'BinaryExpression' && s.test.operator === '&&' && s.alternate == null) {\n          const extracted = extractSequenceFromConjunction(s.test, true);\n          if (extracted === null) {\n            o.push(s);\n          } else {\n            const { prefix, seqs, suffix } = extracted;\n            let newStatements = seqs.map(e => new Shift.ExpressionStatement({ expression: e }));\n            newStatements.push(new Shift.IfStatement({\n              test: suffix,\n              consequent: s.consequent,\n              alternate: null,\n            }));\n            if (prefix === null) {\n              o.push(...newStatements);\n            } else {\n              o.push(new Shift.IfStatement({\n                test: prefix,\n                consequent: new Shift.BlockStatement({ block: new Shift.Block({ statements: newStatements }) }),\n                alternate: null,\n              }));\n            }\n          }\n        } else {\n          o.push(s);\n        }\n        break;\n      case 'VariableDeclarationStatement':\n        if (s.declaration.declarators.length > 1) {\n          o.push(...declaratorsToDeclarationStatements(s.declaration.kind, s.declaration.declarators));\n        } else if (isSequence(s.declaration.declarators[0].init)) {\n          let originalDeclarator = s.declaration.declarators[0];\n          // Yes, these steps could be combined, but /shrug\n          const exprs = binExprToExprs(originalDeclarator.init);\n          const last = exprs.pop();\n          o.push(...exprs.map(e => new Shift.ExpressionStatement({ expression: e })));\n          const declarator = new Shift.VariableDeclarator({ binding: originalDeclarator.binding, init: last });\n          const declaration = new Shift.VariableDeclaration({ kind: s.declaration.kind, declarators: [declarator] });\n          o.push(new Shift.VariableDeclarationStatement({ declaration }));\n        } else {\n          o.push(s);\n        }\n        break;\n      case 'ForStatement':\n        if (s.init != null) {\n          if (s.init.type === 'VariableDeclaration' && s.init.declarators.length > 1) {\n            const declarators = [...s.init.declarators];\n            const finalDeclarator = declarators.pop();\n            const newDeclaration = new Shift.VariableDeclaration({ kind: s.init.kind, declarators: [finalDeclarator] });\n            o.push(...declaratorsToDeclarationStatements(s.init.kind, declarators));\n            o.push(new Shift.ForStatement({ init: newDeclaration, test: s.test, update: s.update, body: s.body }));\n          } else if (isSequence(s.init)) {\n            const exprs = binExprToExprs(s.init);\n            const last = exprs.pop();\n            o.push(...exprs.map(e => new Shift.ExpressionStatement({ expression: e })));\n            o.push(new Shift.ForStatement({ init: last, test: s.test, update: s.update, body: s.body }));\n          } else {\n            o.push(s);\n          }\n        }\n        break;\n      default:\n        o.push(s);\n    }\n  }\n\n  if (arrayEquals(o, statements)) {\n    return statements;\n  }\n  return o;\n}\n\n\nfunction arrayEquals(a, b) {\n  return a.length === b.length && a.every((v, i) => v === b[i]);\n}\n\nfunction hoistFunctionDeclarations(statements) {\n  const decls = [];\n  const nonDecls = [];\n  for (const statement of statements) {\n    if (statement.type === 'FunctionDeclaration') {\n      decls.push(statement);\n    } else {\n      nonDecls.push(statement);\n    }\n  }\n  const o = decls.concat(nonDecls);\n  if (arrayEquals(o, statements)) {\n    return statements;\n  }\n  return o;\n}\n\nclass Cleanup extends reducer.LazyCloneReducer {\n  reduceBlock(node, { statements }) {\n    return super.reduceBlock(node, { statements: fixStatementList(statements) });\n  }\n\n  reduceSwitchCase(node, { test, consequent }) {\n    return super.reduceSwitchCase(node, { test, consequent: fixStatementList(consequent) });\n  }\n\n  reduceSwitchDefault(node, { consequent }) {\n    return super.reduceSwitchDefault(node, { consequent: fixStatementList(consequent) });\n  }\n\n  reduceFunctionBody(node, { directives, statements }) {\n    statements = hoistFunctionDeclarations(fixStatementList(statements));\n    if (directives.length === 0 && statements.length === 1 && (statements[0].type === 'ExpressionStatement' || statements[0].type === 'ReturnStatement') && statements[0].expression != null && statements[0].expression.type === 'CallExpression' && statements[0].expression.arguments.length === 0) {\n      const callee = statements[0].expression.callee;\n      if (callee.type === 'FunctionExpression' && callee.name === null && callee.params.items.length === 0 && callee.params.rest === null && !functionContainsWeirdness(callee)) {\n        return statements[0].type === 'ExpressionStatement' ? makeReturnsUndefined(callee.body) : callee.body;\n      }\n    }\n    if (statements.length > 0 && statements[statements.length - 1].type === 'ReturnStatement' && statements[statements.length - 1].expression == null) {\n      statements = statements.slice(0, -1);\n    }\n    return super.reduceFunctionBody(node, { directives, statements });\n  }\n\n  reduceScript(node, { directives, statements }) {\n    return super.reduceScript(node, { directives, statements: fixStatementList(statements) });\n  }\n\n  reduceUnaryExpression(node, { operand }) {\n    if (node.operator === '!') {\n      const negated = negate(operand, false, false);\n      if (negated) {\n        return negated;\n      }\n    }\n    return super.reduceUnaryExpression(node, { operand });\n  }\n\n  reduceBinaryExpression(node, { left, right }) {\n    // 1 == a -> a == 1\n    if (['==', '===', '!=', '!=='].includes(node.operator) && isConstant(left) && !isConstant(right)) {\n      return new Shift.BinaryExpression({ left: right, operator: node.operator, right: left });\n    }\n    if (node.operator === ',' && inlinable.includes(left.type)) {\n      return right;\n    }\n    return super.reduceBinaryExpression(node, { left, right });\n  }\n\n  reduceExpressionStatement(node, { expression }) {\n    if (expression.type === 'ConditionalExpression') {\n      return new Shift.IfStatement({ test: expression.test, consequent: new Shift.ExpressionStatement({ expression: expression.consequent }), alternate: new Shift.ExpressionStatement({ expression: expression.alternate }) });\n    } else if (expression.type === 'BinaryExpression' && expression.operator === '&&') {\n      return new Shift.IfStatement({ test: expression.left, consequent: new Shift.ExpressionStatement({ expression: expression.right }), alternate: null });\n    } else if (expression.type === 'BinaryExpression' && expression.operator === '||') {\n      return new Shift.IfStatement({ test: new Shift.UnaryExpression({ operator: '!', operand: expression.left }), consequent: new Shift.ExpressionStatement({ expression: expression.right }), alternate: null });\n    } else if (expression.type === 'UnaryExpression' && expression.operator === '!') {\n      return new Shift.ExpressionStatement({ expression: expression.operand });\n    }\n    return super.reduceExpressionStatement(node, { expression });\n  }\n\n  reduceIfStatement(node, { test, consequent, alternate }) {\n    if (test.type === 'UnaryExpression' && test.operator === '!') {\n      test = negate(test.operand, true, false) || test;\n    }\n    if (test.type === 'BinaryExpression' && (test.operator === '!=' || test.operator === '!==') && alternate != null) {\n      test = negate(test, true);\n      [consequent, alternate] = [alternate, consequent];\n    }\n    if (consequent.type !== 'BlockStatement') {\n      consequent = makeBlock(consequent);\n    }\n    if (alternate != null) {\n      if (alternate.type !== 'BlockStatement' && alternate.type !== 'IfStatement') {\n        alternate = makeBlock(alternate);\n      } else if (alternate.type === 'BlockStatement' && alternate.block.statements.length === 1 && alternate.block.statements[0].type === 'IfStatement') {\n        alternate = alternate.block.statements[0];\n      }\n      if (alternate.type === 'BlockStatement' && alternate.block.statements.length === 0) {\n        alternate = null;\n      }\n    }\n    return super.reduceIfStatement(node, { test, consequent, alternate });\n  }\n\n  reduceConditionalExpression(node, { test, consequent, alternate }) {\n    if (test.type === 'UnaryExpression' && test.operator === '!') {\n      test = negate(test.operand, true, false) || test;\n    }\n    return super.reduceConditionalExpression(node, { test, consequent, alternate });\n  }\n\n  reduceForStatement(node, { init, test, update, body }) {\n    if (body.type !== 'BlockStatement') {\n      body = makeBlock(body);\n    }\n    if (init == null && test != null && update == null) {\n      return new Shift.WhileStatement({ test, body });\n    }\n    return super.reduceForStatement(node, { init, test, update, body });\n  }\n\n  reduceForInStatement(node, { left, right, body }) {\n    if (body.type !== 'BlockStatement') {\n      body = makeBlock(body);\n    }\n    return super.reduceForInStatement(node, { left, right, body });\n  }\n\n  reduceForOfStatement(node, { left, right, body }) {\n    if (body.type !== 'BlockStatement') {\n      body = makeBlock(body);\n    }\n    return super.reduceForOfStatement(node, { left, right, body });\n  }\n\n  reduceWhileStatement(node, { test, body }) {\n    if (body.type !== 'BlockStatement') {\n      body = makeBlock(body);\n    }\n    return super.reduceWhileStatement(node, { test, body });\n  }\n\n  reduceDoWhileStatement(node, { body, test }) {\n    if (body.type !== 'BlockStatement') {\n      body = makeBlock(body);\n    }\n    return super.reduceDoWhileStatement(node, { body, test });\n  }\n\n  reduceComputedMemberAssignmentTarget(node, { object, expression }) {\n    if (expression.type === 'LiteralStringExpression' && esutils.keyword.isIdentifierNameES6(expression.value)) {\n      return new Shift.StaticMemberAssignmentTarget({ object, property: expression.value });\n    }\n    return super.reduceComputedMemberAssignmentTarget(node, { object, expression });\n  }\n\n  reduceComputedMemberExpression(node, { object, expression }) {\n    if (expression.type === 'LiteralStringExpression' && esutils.keyword.isIdentifierNameES6(expression.value)) {\n      return new Shift.StaticMemberExpression({ object, property: expression.value });\n    }\n    return super.reduceComputedMemberExpression(node, { object, expression });\n  }\n\n  reduceCallExpression(node, { callee, arguments: _arguments }) {\n    if (callee.type === 'FunctionExpression' && !callee.isGenerator && !functionContainsWeirdness(callee)) {\n      if (_arguments.length === 0 && callee.params.rest === null && callee.params.items.length === 0 && callee.body.directives.length === 0 && callee.body.statements.length <= 1) {\n        // turn iifes with very simple bodies into expressions with no calls\n        if (callee.body.statements.length === 0) {\n          return new Shift.UnaryExpression({ operator: 'void', operand: new Shift.LiteralNullExpression });\n        }\n        const statement = callee.body.statements[0];\n        if (statement.type === 'ReturnStatement') {\n          return statement.expression;\n        }\n        if (statement.type === 'ExpressionStatement') {\n          return new Shift.BinaryExpression({ left: statement.expression, operator: ',', right: new Shift.UnaryExpression({ operator: 'void', operand: new Shift.LiteralNullExpression }) }); // `(expr, void 0)`\n        }\n      }\n    }\n    return super.reduceCallExpression(node, { callee, arguments: _arguments });\n  }\n}\n\n\nconst cleaner = new Cleanup;\n\nmodule.exports = function cleanup(ast) {\n  return reducer.default(cleaner, ast);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}