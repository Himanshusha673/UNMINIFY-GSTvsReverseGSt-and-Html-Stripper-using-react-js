{"ast":null,"code":"'use strict';\n\nconst reducer = require('shift-reducer');\nconst shiftScope = require('shift-scope');\nconst Shift = require('shift-ast/checked');\nconst getParents = require('../../helpers/parents');\nconst {\n  functionContainsWeirdness,\n  expressionContainsWeirdness\n} = require('../../helpers/fn-contains-weirdness');\n\n// TODO rename this to something better expressing \"transform for simpler static analysis\"\nmodule.exports = function cleanupWithState(ast) {\n  const parents = getParents(ast);\n  const globalScope = shiftScope.default(ast);\n  const lookup = new shiftScope.ScopeLookup(globalScope);\n  function findScopeForNode(node, scope = globalScope) {\n    // TODO this should live elsewhere\n    if (scope.astNode === node) return scope;\n    for (let child of scope.children) {\n      const r = findScopeForNode(node, child);\n      if (r !== null) return r;\n    }\n    return null;\n  }\n  function unhoistVarDeclarations(statements) {\n    const out = [];\n    const toRemove = new WeakSet();\n    const toBecomeDecl = new WeakMap(); // ExpressionStatement -> list of other expression statements to remove from this set\n    let touched = false;\n    for (let statement of statements) {\n      if (statement.type === 'VariableDeclarationStatement' && statement.declaration.kind === 'var' && statement.declaration.declarators.length === 1 && statement.declaration.declarators[0].init === null) {\n        const vs = lookup.lookup(statement.declaration.declarators[0].binding);\n        if (vs != null && vs.length === 1) {\n          const v = vs[0];\n          const simpleWrites = v.references.filter(r => r.accessibility.isWrite && !r.accessibility.isRead).map(r => parents.get(r.node)).filter(n => n.type === 'AssignmentExpression').map(n => [n, parents.get(n)]).filter(([n, p]) => p.type === 'ExpressionStatement' || p.type === 'ForStatement' && p.init === n).map(([, p]) => p);\n          const declParent = parents.get(statement);\n          const isSameParent = n => {\n            const parent = parents.get(n);\n            if (parent === declParent) {\n              return true;\n            }\n            const gp = parents.get(parent);\n            if (gp != null && gp.type === 'ForStatement' && gp.init === parent) {\n              return true;\n            }\n            return false;\n          };\n          if (simpleWrites.length > 0 && simpleWrites.every(isSameParent)) {\n            touched = true;\n            toRemove.add(statement);\n            simpleWrites.forEach(s => toBecomeDecl.set(s, simpleWrites));\n          }\n        }\n      }\n    }\n    if (!touched) {\n      return statements;\n    }\n    for (let statement of statements) {\n      if (toRemove.has(statement)) continue;\n      if (toBecomeDecl.has(statement)) {\n        if (statement.type === 'ExpressionStatement') {\n          const declaration = new Shift.VariableDeclaration({\n            kind: 'var',\n            declarators: [new Shift.VariableDeclarator({\n              binding: new Shift.BindingIdentifier({\n                name: statement.expression.binding.name\n              }),\n              init: statement.expression.expression\n            })]\n          });\n          out.push(new Shift.VariableDeclarationStatement({\n            declaration\n          }));\n        } else if (statement.type === 'ForStatement') {\n          const declaration = new Shift.VariableDeclaration({\n            kind: 'var',\n            declarators: [new Shift.VariableDeclarator({\n              binding: new Shift.BindingIdentifier({\n                name: statement.init.binding.name\n              }),\n              init: statement.init.expression\n            })]\n          });\n          out.push(new Shift.ForStatement({\n            init: declaration,\n            test: statement.test,\n            update: statement.update,\n            body: statement.body\n          }));\n        } else {\n          throw new Error('unreachable');\n        }\n        toBecomeDecl.get(statement).forEach(s => toBecomeDecl.delete(s));\n        continue;\n      }\n      out.push(statement);\n    }\n    return out;\n  }\n  class CleanupWithState extends reducer.LazyCloneReducer {\n    reduceFunctionBody(node, {\n      directives,\n      statements\n    }) {\n      // move declarations to first initialization, as long as all writes are in the same statement list as the declaration\n      return super.reduceFunctionBody(node, {\n        directives,\n        statements: unhoistVarDeclarations(statements)\n      });\n    }\n    reduceCallExpression(node, {\n      callee,\n      arguments: _arguments\n    }) {\n      // Turn (function(a){ ... })(b) into (function(){ var a = b; ... })()\n      // Note: not safe if the function contains a direct `eval` which references `arguments` or an argument contains a direct `eval` which references `arguments` or `this`.\n      if (callee.type === 'FunctionExpression' && !callee.isGenerator && !functionContainsWeirdness(callee)) {\n        if (_arguments.length > 0 && _arguments.every(a => a.type !== 'SpreadElement' && !expressionContainsWeirdness(a)) && callee.params.rest === null && callee.params.items.every(p => p.type === 'BindingIdentifier')) {\n          const names = [].concat(...node.arguments.map(collectNames)); // TODO avoid\n          const fnScope = findScopeForNode(node.callee);\n          if (fnScope && !names.some(n => fnScope.variables.has(n))) {\n            // the scope check is to avoid shadowing something in the arguments\n            const newInit = [];\n            let i = 0;\n            for (; i < callee.params.items.length; ++i) {\n              newInit.push(new Shift.VariableDeclarationStatement({\n                declaration: new Shift.VariableDeclaration({\n                  kind: 'var',\n                  declarators: [new Shift.VariableDeclarator({\n                    binding: callee.params.items[i],\n                    init: _arguments[i] || null\n                  })]\n                })\n              }));\n            }\n            for (; i < _arguments.length; ++i) {\n              newInit.push(new Shift.ExpressionStatement({\n                expression: _arguments[i]\n              }));\n            }\n            const fn = new Shift.FunctionExpression({\n              name: callee.name,\n              isGenerator: false,\n              isAsync: false,\n              params: new Shift.FormalParameters({\n                items: [],\n                rest: null\n              }),\n              body: new Shift.FunctionBody({\n                directives: [],\n                statements: newInit.concat(callee.body.statements)\n              })\n            });\n            return new Shift.CallExpression({\n              callee: fn,\n              arguments: []\n            });\n          }\n        }\n      }\n      return super.reduceCallExpression(node, {\n        callee,\n        arguments: _arguments\n      });\n    }\n  }\n  class NameCollector extends reducer.MonoidalReducer {\n    constructor() {\n      super({\n        empty: () => [],\n        concat: (a, b) => a.concat(b)\n      });\n    }\n    reduceIdentifierExpression(node) {\n      return [node.name];\n    }\n    reduceAssignmentTargetIdentifier(node) {\n      return [node.name];\n    }\n    reduceBindingIdentifier(node) {\n      return [node.name];\n    }\n    reduceFunctionExpression(node, state) {\n      // TODO it would be nice for this to be thunked\n      const scope = findScopeForNode(node);\n      if (scope !== null) {\n        return [...scope.through.keys()];\n      }\n      return super.reduceFunctionExpression(node, state); // better than nothing\n    }\n\n    /*\n      Maybe this is a thing which should be exposed by the scope analyzer? through references for individual nodes, not just scopes?\n    */\n  }\n  function collectNames(node) {\n    return reducer.default(new NameCollector(), node);\n  }\n  return reducer.default(new CleanupWithState(), ast);\n};","map":{"version":3,"names":["reducer","require","shiftScope","Shift","getParents","functionContainsWeirdness","expressionContainsWeirdness","module","exports","cleanupWithState","ast","parents","globalScope","default","lookup","ScopeLookup","findScopeForNode","node","scope","astNode","child","children","r","unhoistVarDeclarations","statements","out","toRemove","WeakSet","toBecomeDecl","WeakMap","touched","statement","type","declaration","kind","declarators","length","init","vs","binding","v","simpleWrites","references","filter","accessibility","isWrite","isRead","map","get","n","p","declParent","isSameParent","parent","gp","every","add","forEach","s","set","has","VariableDeclaration","VariableDeclarator","BindingIdentifier","name","expression","push","VariableDeclarationStatement","ForStatement","test","update","body","Error","delete","CleanupWithState","LazyCloneReducer","reduceFunctionBody","directives","reduceCallExpression","callee","arguments","_arguments","isGenerator","a","params","rest","items","names","concat","collectNames","fnScope","some","variables","newInit","i","ExpressionStatement","fn","FunctionExpression","isAsync","FormalParameters","FunctionBody","CallExpression","NameCollector","MonoidalReducer","constructor","empty","b","reduceIdentifierExpression","reduceAssignmentTargetIdentifier","reduceBindingIdentifier","reduceFunctionExpression","state","through","keys"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/unminify/src/transforms/safe/cleanup-with-state.js"],"sourcesContent":["'use strict';\n\nconst reducer = require('shift-reducer');\nconst shiftScope = require('shift-scope');\nconst Shift = require('shift-ast/checked');\n\nconst getParents = require('../../helpers/parents');\nconst { functionContainsWeirdness, expressionContainsWeirdness } = require('../../helpers/fn-contains-weirdness');\n\n// TODO rename this to something better expressing \"transform for simpler static analysis\"\nmodule.exports = function cleanupWithState(ast) {\n  const parents = getParents(ast);\n  const globalScope = shiftScope.default(ast);\n  const lookup = new shiftScope.ScopeLookup(globalScope);\n\n  function findScopeForNode(node, scope = globalScope) {\n    // TODO this should live elsewhere\n    if (scope.astNode === node) return scope;\n    for (let child of scope.children) {\n      const r = findScopeForNode(node, child);\n      if (r !== null) return r;\n    }\n    return null;\n  }\n\n  function unhoistVarDeclarations(statements) {\n    const out = [];\n    const toRemove = new WeakSet;\n    const toBecomeDecl = new WeakMap; // ExpressionStatement -> list of other expression statements to remove from this set\n    let touched = false;\n    for (let statement of statements) {\n      if (statement.type === 'VariableDeclarationStatement' && statement.declaration.kind === 'var' && statement.declaration.declarators.length === 1 && statement.declaration.declarators[0].init === null) {\n        const vs = lookup.lookup(statement.declaration.declarators[0].binding);\n        if (vs != null && vs.length === 1) {\n          const v = vs[0];\n          const simpleWrites = v.references\n            .filter(r => r.accessibility.isWrite && !r.accessibility.isRead)\n            .map(r => parents.get(r.node))\n            .filter(n => n.type === 'AssignmentExpression')\n            .map(n => [n, parents.get(n)])\n            .filter(([n, p]) => p.type === 'ExpressionStatement' || p.type === 'ForStatement' && p.init === n)\n            .map(([, p]) => p);\n          const declParent = parents.get(statement);\n          const isSameParent = n => {\n            const parent = parents.get(n);\n            if (parent === declParent) {\n              return true;\n            }\n            const gp = parents.get(parent);\n            if (gp != null && gp.type === 'ForStatement' && gp.init === parent) {\n              return true;\n            }\n            return false;\n          };\n          if (simpleWrites.length > 0 && simpleWrites.every(isSameParent)) {\n            touched = true;\n            toRemove.add(statement);\n            simpleWrites.forEach(s => toBecomeDecl.set(s, simpleWrites));\n          }\n        }\n      }\n    }\n\n    if (!touched) {\n      return statements;\n    }\n\n    for (let statement of statements) {\n      if (toRemove.has(statement)) continue;\n      if (toBecomeDecl.has(statement)) {\n        if (statement.type === 'ExpressionStatement') {\n          const declaration = new Shift.VariableDeclaration({ kind: 'var', declarators: [new Shift.VariableDeclarator({\n            binding: new Shift.BindingIdentifier({ name: statement.expression.binding.name }),\n            init: statement.expression.expression,\n          })] });\n          out.push(new Shift.VariableDeclarationStatement({ declaration }));\n        } else if (statement.type === 'ForStatement') {\n          const declaration = new Shift.VariableDeclaration({ kind: 'var', declarators: [new Shift.VariableDeclarator({\n            binding: new Shift.BindingIdentifier({ name: statement.init.binding.name }),\n            init: statement.init.expression,\n          })] });\n          out.push(new Shift.ForStatement({ init: declaration, test: statement.test, update: statement.update, body: statement.body }));\n        } else {\n          throw new Error('unreachable');\n        }\n        toBecomeDecl.get(statement).forEach(s => toBecomeDecl.delete(s));\n        continue;\n      }\n      out.push(statement);\n    }\n\n    return out;\n  }\n\n  class CleanupWithState extends reducer.LazyCloneReducer {\n    reduceFunctionBody(node, { directives, statements }) {\n      // move declarations to first initialization, as long as all writes are in the same statement list as the declaration\n      return super.reduceFunctionBody(node, { directives, statements: unhoistVarDeclarations(statements) });\n    }\n\n    reduceCallExpression(node, { callee, arguments: _arguments }) {\n      // Turn (function(a){ ... })(b) into (function(){ var a = b; ... })()\n      // Note: not safe if the function contains a direct `eval` which references `arguments` or an argument contains a direct `eval` which references `arguments` or `this`.\n      if (callee.type === 'FunctionExpression' && !callee.isGenerator && !functionContainsWeirdness(callee)) {\n        if (_arguments.length > 0 && _arguments.every(a => a.type !== 'SpreadElement' && !expressionContainsWeirdness(a)) && callee.params.rest === null && callee.params.items.every(p => p.type === 'BindingIdentifier')) {\n          const names = [].concat(...node.arguments.map(collectNames)); // TODO avoid\n          const fnScope = findScopeForNode(node.callee);\n          if (fnScope && !names.some(n => fnScope.variables.has(n))) {\n            // the scope check is to avoid shadowing something in the arguments\n            const newInit = [];\n            let i = 0;\n            for (; i < callee.params.items.length; ++i) {\n              newInit.push(new Shift.VariableDeclarationStatement({ declaration: new Shift.VariableDeclaration({\n                kind: 'var',\n                declarators: [\n                  new Shift.VariableDeclarator({ binding: callee.params.items[i], init: _arguments[i] || null }),\n                ],\n              }) }));\n            }\n            for (; i < _arguments.length; ++i) {\n              newInit.push(new Shift.ExpressionStatement({ expression: _arguments[i] }));\n            }\n            const fn = new Shift.FunctionExpression({ name: callee.name, isGenerator: false, isAsync: false, params: new Shift.FormalParameters({ items: [], rest: null }), body: new Shift.FunctionBody({\n              directives: [],\n              statements: newInit.concat(callee.body.statements),\n            }) });\n            return new Shift.CallExpression({ callee: fn, arguments: [] });\n          }\n        }\n      }\n      return super.reduceCallExpression(node, { callee, arguments: _arguments });\n    }\n  }\n\n\n  class NameCollector extends reducer.MonoidalReducer {\n    constructor() {\n      super({ empty: () => [], concat: (a, b) => a.concat(b) });\n    }\n\n    reduceIdentifierExpression(node) {\n      return [node.name];\n    }\n\n    reduceAssignmentTargetIdentifier(node) {\n      return [node.name];\n    }\n\n    reduceBindingIdentifier(node) {\n      return [node.name];\n    }\n\n    reduceFunctionExpression(node, state) { // TODO it would be nice for this to be thunked\n      const scope = findScopeForNode(node);\n      if (scope !== null) {\n        return [...scope.through.keys()];\n      }\n      return super.reduceFunctionExpression(node, state); // better than nothing\n    }\n\n    /*\n      Maybe this is a thing which should be exposed by the scope analyzer? through references for individual nodes, not just scopes?\n    */\n  }\n\n  function collectNames(node) {\n    return reducer.default(new NameCollector, node);\n  }\n\n\n  return reducer.default(new CleanupWithState, ast);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}