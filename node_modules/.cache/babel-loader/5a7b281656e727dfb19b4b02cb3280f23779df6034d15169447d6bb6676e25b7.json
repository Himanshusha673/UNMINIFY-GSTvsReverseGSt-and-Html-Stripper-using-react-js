{"ast":null,"code":"/**\n * Copyright 2014 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {\n  reduce,\n  MonoidalReducer\n} = require('shift-reducer');\nconst {\n  isStrictModeReservedWord\n} = require('./utils');\nconst {\n  ErrorMessages\n} = require('./errors');\nconst {\n  EarlyErrorState,\n  EarlyError\n} = require('./early-error-state');\nfunction isStrictFunctionBody({\n  directives\n}) {\n  return directives.some(directive => directive.rawValue === 'use strict');\n}\nfunction isLabelledFunction(node) {\n  return node.type === 'LabeledStatement' && (node.body.type === 'FunctionDeclaration' || isLabelledFunction(node.body));\n}\nfunction isIterationStatement(node) {\n  switch (node.type) {\n    case 'LabeledStatement':\n      return isIterationStatement(node.body);\n    case 'DoWhileStatement':\n    case 'ForInStatement':\n    case 'ForOfStatement':\n    case 'ForStatement':\n    case 'WhileStatement':\n      return true;\n  }\n  return false;\n}\nfunction isSpecialMethod(methodDefinition) {\n  if (methodDefinition.name.type !== 'StaticPropertyName' || methodDefinition.name.value !== 'constructor') {\n    return false;\n  }\n  switch (methodDefinition.type) {\n    case 'Getter':\n    case 'Setter':\n      return true;\n    case 'Method':\n      return methodDefinition.isGenerator || methodDefinition.isAsync;\n  }\n  /* istanbul ignore next */\n  throw new Error('not reached');\n}\nfunction enforceDuplicateConstructorMethods(node, s) {\n  let ctors = node.elements.filter(e => !e.isStatic && e.method.type === 'Method' && !e.method.isGenerator && e.method.name.type === 'StaticPropertyName' && e.method.name.value === 'constructor');\n  if (ctors.length > 1) {\n    ctors.slice(1).forEach(ctor => {\n      s = s.addError(new EarlyError(ctor, 'Duplicate constructor method in class'));\n    });\n  }\n  return s;\n}\nconst SUPERCALL_ERROR = node => new EarlyError(node, ErrorMessages.ILLEGAL_SUPER_CALL);\nconst SUPERPROPERTY_ERROR = node => new EarlyError(node, 'Member access on super must be in a method');\nconst DUPLICATE_BINDING = node => new EarlyError(node, `Duplicate binding ${JSON.stringify(node.name)}`);\nconst FREE_CONTINUE = node => new EarlyError(node, 'Continue statement must be nested within an iteration statement');\nconst UNBOUND_CONTINUE = node => new EarlyError(node, `Continue statement must be nested within an iteration statement with label ${JSON.stringify(node.label)}`);\nconst FREE_BREAK = node => new EarlyError(node, 'Break statement must be nested within an iteration statement or a switch statement');\nconst UNBOUND_BREAK = node => new EarlyError(node, `Break statement must be nested within a statement with label ${JSON.stringify(node.label)}`);\nclass EarlyErrorChecker extends MonoidalReducer {\n  constructor() {\n    super(EarlyErrorState);\n  }\n  reduceAssignmentExpression() {\n    return super.reduceAssignmentExpression(...arguments).clearBoundNames();\n  }\n  reduceAssignmentTargetIdentifier(node) {\n    let s = this.identity;\n    if (node.name === 'eval' || node.name === 'arguments' || isStrictModeReservedWord(node.name)) {\n      s = s.addStrictError(new EarlyError(node, `The identifier ${JSON.stringify(node.name)} must not be in binding position in strict mode`));\n    }\n    return s;\n  }\n  reduceArrowExpression(node, {\n    params,\n    body\n  }) {\n    let isSimpleParameterList = node.params.rest == null && node.params.items.every(i => i.type === 'BindingIdentifier');\n    params = params.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    if (node.body.type === 'FunctionBody') {\n      body = body.enforceConflictingLexicallyDeclaredNames(params.lexicallyDeclaredNames, DUPLICATE_BINDING);\n      if (isStrictFunctionBody(node.body)) {\n        params = params.enforceStrictErrors();\n        body = body.enforceStrictErrors();\n      }\n    }\n    params.yieldExpressions.forEach(n => {\n      params = params.addError(new EarlyError(n, 'Arrow parameters must not contain yield expressions'));\n    });\n    params.awaitExpressions.forEach(n => {\n      params = params.addError(new EarlyError(n, 'Arrow parameters must not contain await expressions'));\n    });\n    let s = super.reduceArrowExpression(node, {\n      params,\n      body\n    });\n    if (!isSimpleParameterList && node.body.type === 'FunctionBody' && isStrictFunctionBody(node.body)) {\n      s = s.addError(new EarlyError(node, 'Functions with non-simple parameter lists may not contain a \"use strict\" directive'));\n    }\n    s = s.clearYieldExpressions();\n    s = s.clearAwaitExpressions();\n    s = s.observeVarBoundary();\n    return s;\n  }\n  reduceAwaitExpression(node, {\n    expression\n  }) {\n    return expression.observeAwaitExpression(node);\n  }\n  reduceBindingIdentifier(node) {\n    let s = this.identity;\n    if (node.name === 'eval' || node.name === 'arguments' || isStrictModeReservedWord(node.name)) {\n      s = s.addStrictError(new EarlyError(node, `The identifier ${JSON.stringify(node.name)} must not be in binding position in strict mode`));\n    }\n    s = s.bindName(node.name, node);\n    return s;\n  }\n  reduceBlock() {\n    let s = super.reduceBlock(...arguments);\n    s = s.functionDeclarationNamesAreLexical();\n    s = s.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    s = s.enforceConflictingLexicallyDeclaredNames(s.varDeclaredNames, DUPLICATE_BINDING);\n    s = s.observeLexicalBoundary();\n    return s;\n  }\n  reduceBreakStatement(node) {\n    let s = super.reduceBreakStatement(...arguments);\n    s = node.label == null ? s.addFreeBreakStatement(node) : s.addFreeLabeledBreakStatement(node);\n    return s;\n  }\n  reduceCallExpression(node) {\n    let s = super.reduceCallExpression(...arguments);\n    if (node.callee.type === 'Super') {\n      s = s.observeSuperCallExpression(node);\n    }\n    return s;\n  }\n  reduceCatchClause(node, {\n    binding,\n    body\n  }) {\n    if (binding != null) {\n      binding = binding.observeLexicalDeclaration();\n      binding = binding.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n      binding = binding.enforceConflictingLexicallyDeclaredNames(body.previousLexicallyDeclaredNames, DUPLICATE_BINDING);\n    }\n    let s = super.reduceCatchClause(node, {\n      binding,\n      body\n    });\n    s = s.observeLexicalBoundary();\n    return s;\n  }\n  reduceClassDeclaration(node, {\n    name,\n    super: _super,\n    elements\n  }) {\n    let s = name.enforceStrictErrors();\n    let sElements = this.append(...elements);\n    sElements = sElements.enforceStrictErrors();\n    if (node.super != null) {\n      _super = _super.enforceStrictErrors();\n      s = this.append(s, _super);\n      sElements = sElements.clearSuperCallExpressionsInConstructorMethod();\n    }\n    s = this.append(s, sElements);\n    s = enforceDuplicateConstructorMethods(node, s);\n    s = s.observeLexicalDeclaration();\n    return s;\n  }\n  reduceClassElement(node) {\n    let s = super.reduceClassElement(...arguments);\n    if (!node.isStatic && isSpecialMethod(node.method)) {\n      s = s.addError(new EarlyError(node, ErrorMessages.ILLEGAL_CONSTRUCTORS));\n    }\n    if (node.isStatic && node.method.name.type === 'StaticPropertyName' && node.method.name.value === 'prototype') {\n      s = s.addError(new EarlyError(node, 'Static class methods cannot be named \"prototype\"'));\n    }\n    return s;\n  }\n  reduceClassExpression(node, {\n    name,\n    super: _super,\n    elements\n  }) {\n    let s = node.name == null ? this.identity : name.enforceStrictErrors();\n    let sElements = this.append(...elements);\n    sElements = sElements.enforceStrictErrors();\n    if (node.super != null) {\n      _super = _super.enforceStrictErrors();\n      s = this.append(s, _super);\n      sElements = sElements.clearSuperCallExpressionsInConstructorMethod();\n    }\n    s = this.append(s, sElements);\n    s = enforceDuplicateConstructorMethods(node, s);\n    s = s.clearBoundNames();\n    return s;\n  }\n  reduceCompoundAssignmentExpression() {\n    return super.reduceCompoundAssignmentExpression(...arguments).clearBoundNames();\n  }\n  reduceComputedMemberExpression(node) {\n    let s = super.reduceComputedMemberExpression(...arguments);\n    if (node.object.type === 'Super') {\n      s = s.observeSuperPropertyExpression(node);\n    }\n    return s;\n  }\n  reduceContinueStatement(node) {\n    let s = super.reduceContinueStatement(...arguments);\n    s = node.label == null ? s.addFreeContinueStatement(node) : s.addFreeLabeledContinueStatement(node);\n    return s;\n  }\n  reduceDoWhileStatement(node) {\n    let s = super.reduceDoWhileStatement(...arguments);\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a do-while statement must not be a labeled function declaration'));\n    }\n    s = s.clearFreeContinueStatements();\n    s = s.clearFreeBreakStatements();\n    return s;\n  }\n  reduceExport() {\n    let s = super.reduceExport(...arguments);\n    s = s.functionDeclarationNamesAreLexical();\n    s = s.exportDeclaredNames();\n    return s;\n  }\n  reduceExportFrom() {\n    let s = super.reduceExportFrom(...arguments);\n    s = s.clearExportedBindings();\n    return s;\n  }\n  reduceExportFromSpecifier(node) {\n    let s = super.reduceExportFromSpecifier(...arguments);\n    s = s.exportName(node.exportedName || node.name, node);\n    s = s.exportBinding(node.name, node);\n    return s;\n  }\n  reduceExportLocalSpecifier(node) {\n    let s = super.reduceExportLocalSpecifier(...arguments);\n    s = s.exportName(node.exportedName || node.name.name, node);\n    s = s.exportBinding(node.name.name, node);\n    return s;\n  }\n  reduceExportDefault(node) {\n    let s = super.reduceExportDefault(...arguments);\n    s = s.functionDeclarationNamesAreLexical();\n    s = s.exportName('default', node);\n    return s;\n  }\n  reduceFormalParameters() {\n    let s = super.reduceFormalParameters(...arguments);\n    s = s.observeLexicalDeclaration();\n    return s;\n  }\n  reduceForStatement(node, {\n    init,\n    test,\n    update,\n    body\n  }) {\n    if (init != null) {\n      init = init.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n      init = init.enforceConflictingLexicallyDeclaredNames(body.varDeclaredNames, DUPLICATE_BINDING);\n    }\n    let s = super.reduceForStatement(node, {\n      init,\n      test,\n      update,\n      body\n    });\n    if (node.init != null && node.init.type === 'VariableDeclaration' && node.init.kind === 'const') {\n      node.init.declarators.forEach(declarator => {\n        if (declarator.init == null) {\n          s = s.addError(new EarlyError(declarator, 'Constant lexical declarations must have an initialiser'));\n        }\n      });\n    }\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a for statement must not be a labeled function declaration'));\n    }\n    s = s.clearFreeContinueStatements();\n    s = s.clearFreeBreakStatements();\n    s = s.observeLexicalBoundary();\n    return s;\n  }\n  reduceForInStatement(node, {\n    left,\n    right,\n    body\n  }) {\n    left = left.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    left = left.enforceConflictingLexicallyDeclaredNames(body.varDeclaredNames, DUPLICATE_BINDING);\n    let s = super.reduceForInStatement(node, {\n      left,\n      right,\n      body\n    });\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a for-in statement must not be a labeled function declaration'));\n    }\n    s = s.clearFreeContinueStatements();\n    s = s.clearFreeBreakStatements();\n    s = s.observeLexicalBoundary();\n    return s;\n  }\n  reduceForOfStatement(node, {\n    left,\n    right,\n    body\n  }) {\n    left = left.recordForOfVars();\n    left = left.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    left = left.enforceConflictingLexicallyDeclaredNames(body.varDeclaredNames, DUPLICATE_BINDING);\n    let s = super.reduceForOfStatement(node, {\n      left,\n      right,\n      body\n    });\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a for-of statement must not be a labeled function declaration'));\n    }\n    s = s.clearFreeContinueStatements();\n    s = s.clearFreeBreakStatements();\n    s = s.observeLexicalBoundary();\n    return s;\n  }\n  reduceForAwaitStatement(node, {\n    left,\n    right,\n    body\n  }) {\n    left = left.recordForOfVars();\n    left = left.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    left = left.enforceConflictingLexicallyDeclaredNames(body.varDeclaredNames, DUPLICATE_BINDING);\n    let s = super.reduceForOfStatement(node, {\n      left,\n      right,\n      body\n    });\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a for-await statement must not be a labeled function declaration'));\n    }\n    s = s.clearFreeContinueStatements();\n    s = s.clearFreeBreakStatements();\n    s = s.observeLexicalBoundary();\n    return s;\n  }\n  reduceFunctionBody(node) {\n    let s = super.reduceFunctionBody(...arguments);\n    s = s.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    s = s.enforceConflictingLexicallyDeclaredNames(s.varDeclaredNames, DUPLICATE_BINDING);\n    s = s.enforceFreeContinueStatementErrors(FREE_CONTINUE);\n    s = s.enforceFreeLabeledContinueStatementErrors(UNBOUND_CONTINUE);\n    s = s.enforceFreeBreakStatementErrors(FREE_BREAK);\n    s = s.enforceFreeLabeledBreakStatementErrors(UNBOUND_BREAK);\n    s = s.clearUsedLabelNames();\n    s = s.clearYieldExpressions();\n    s = s.clearAwaitExpressions();\n    if (isStrictFunctionBody(node)) {\n      s = s.enforceStrictErrors();\n    }\n    return s;\n  }\n  reduceFunctionDeclaration(node, {\n    name,\n    params,\n    body\n  }) {\n    let isSimpleParameterList = node.params.rest == null && node.params.items.every(i => i.type === 'BindingIdentifier');\n    let addError = !isSimpleParameterList || node.isGenerator ? 'addError' : 'addStrictError';\n    params.lexicallyDeclaredNames.forEachEntry(nodes => {\n      if (nodes.length > 1) {\n        nodes.slice(1).forEach(dupeNode => {\n          params = params[addError](DUPLICATE_BINDING(dupeNode));\n        });\n      }\n    });\n    body = body.enforceConflictingLexicallyDeclaredNames(params.lexicallyDeclaredNames, DUPLICATE_BINDING);\n    body = body.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    body = body.enforceSuperPropertyExpressions(SUPERPROPERTY_ERROR);\n    params = params.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    params = params.enforceSuperPropertyExpressions(SUPERPROPERTY_ERROR);\n    if (node.isGenerator) {\n      params.yieldExpressions.forEach(n => {\n        params = params.addError(new EarlyError(n, 'Generator parameters must not contain yield expressions'));\n      });\n    }\n    if (node.isAsync) {\n      params.awaitExpressions.forEach(n => {\n        params = params.addError(new EarlyError(n, 'Async function parameters must not contain await expressions'));\n      });\n    }\n    params = params.clearNewTargetExpressions();\n    body = body.clearNewTargetExpressions();\n    if (isStrictFunctionBody(node.body)) {\n      params = params.enforceStrictErrors();\n      body = body.enforceStrictErrors();\n    }\n    let s = super.reduceFunctionDeclaration(node, {\n      name,\n      params,\n      body\n    });\n    if (!isSimpleParameterList && isStrictFunctionBody(node.body)) {\n      s = s.addError(new EarlyError(node, 'Functions with non-simple parameter lists may not contain a \"use strict\" directive'));\n    }\n    s = s.clearYieldExpressions();\n    s = s.clearAwaitExpressions();\n    s = s.observeFunctionDeclaration();\n    return s;\n  }\n  reduceFunctionExpression(node, {\n    name,\n    params,\n    body\n  }) {\n    let isSimpleParameterList = node.params.rest == null && node.params.items.every(i => i.type === 'BindingIdentifier');\n    let addError = !isSimpleParameterList || node.isGenerator ? 'addError' : 'addStrictError';\n    params.lexicallyDeclaredNames.forEachEntry((nodes, bindingName) => {\n      if (nodes.length > 1) {\n        nodes.slice(1).forEach(dupeNode => {\n          params = params[addError](new EarlyError(dupeNode, `Duplicate binding ${JSON.stringify(bindingName)}`));\n        });\n      }\n    });\n    body = body.enforceConflictingLexicallyDeclaredNames(params.lexicallyDeclaredNames, DUPLICATE_BINDING);\n    body = body.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    body = body.enforceSuperPropertyExpressions(SUPERPROPERTY_ERROR);\n    params = params.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    params = params.enforceSuperPropertyExpressions(SUPERPROPERTY_ERROR);\n    if (node.isGenerator) {\n      params.yieldExpressions.forEach(n => {\n        params = params.addError(new EarlyError(n, 'Generator parameters must not contain yield expressions'));\n      });\n    }\n    if (node.isAsync) {\n      params.awaitExpressions.forEach(n => {\n        params = params.addError(new EarlyError(n, 'Async function parameters must not contain await expressions'));\n      });\n    }\n    params = params.clearNewTargetExpressions();\n    body = body.clearNewTargetExpressions();\n    if (isStrictFunctionBody(node.body)) {\n      params = params.enforceStrictErrors();\n      body = body.enforceStrictErrors();\n    }\n    let s = super.reduceFunctionExpression(node, {\n      name,\n      params,\n      body\n    });\n    if (!isSimpleParameterList && isStrictFunctionBody(node.body)) {\n      s = s.addError(new EarlyError(node, 'Functions with non-simple parameter lists may not contain a \"use strict\" directive'));\n    }\n    s = s.clearBoundNames();\n    s = s.clearYieldExpressions();\n    s = s.clearAwaitExpressions();\n    s = s.observeVarBoundary();\n    return s;\n  }\n  reduceGetter(node, {\n    name,\n    body\n  }) {\n    body = body.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    body = body.clearSuperPropertyExpressions();\n    body = body.clearNewTargetExpressions();\n    if (isStrictFunctionBody(node.body)) {\n      body = body.enforceStrictErrors();\n    }\n    let s = super.reduceGetter(node, {\n      name,\n      body\n    });\n    s = s.observeVarBoundary();\n    return s;\n  }\n  reduceIdentifierExpression(node) {\n    let s = this.identity;\n    if (isStrictModeReservedWord(node.name)) {\n      s = s.addStrictError(new EarlyError(node, `The identifier ${JSON.stringify(node.name)} must not be in expression position in strict mode`));\n    }\n    return s;\n  }\n  reduceIfStatement(node, {\n    test,\n    consequent,\n    alternate\n  }) {\n    if (isLabelledFunction(node.consequent)) {\n      consequent = consequent.addError(new EarlyError(node.consequent, 'The consequent of an if statement must not be a labeled function declaration'));\n    }\n    if (node.alternate != null && isLabelledFunction(node.alternate)) {\n      alternate = alternate.addError(new EarlyError(node.alternate, 'The alternate of an if statement must not be a labeled function declaration'));\n    }\n    if (node.consequent.type === 'FunctionDeclaration') {\n      consequent = consequent.addStrictError(new EarlyError(node.consequent, 'FunctionDeclarations in IfStatements are disallowed in strict mode'));\n      consequent = consequent.observeLexicalBoundary();\n    }\n    if (node.alternate != null && node.alternate.type === 'FunctionDeclaration') {\n      alternate = alternate.addStrictError(new EarlyError(node.alternate, 'FunctionDeclarations in IfStatements are disallowed in strict mode'));\n      alternate = alternate.observeLexicalBoundary();\n    }\n    return super.reduceIfStatement(node, {\n      test,\n      consequent,\n      alternate\n    });\n  }\n  reduceImport() {\n    let s = super.reduceImport(...arguments);\n    s = s.observeLexicalDeclaration();\n    return s;\n  }\n  reduceImportNamespace() {\n    let s = super.reduceImportNamespace(...arguments);\n    s = s.observeLexicalDeclaration();\n    return s;\n  }\n  reduceLabeledStatement(node) {\n    let s = super.reduceLabeledStatement(...arguments);\n    if (node.label === 'yield' || isStrictModeReservedWord(node.label)) {\n      s = s.addStrictError(new EarlyError(node, `The identifier ${JSON.stringify(node.label)} must not be in label position in strict mode`));\n    }\n    if (s.usedLabelNames.indexOf(node.label) >= 0) {\n      s = s.addError(new EarlyError(node, `Label ${JSON.stringify(node.label)} has already been declared`));\n    }\n    if (node.body.type === 'FunctionDeclaration') {\n      s = s.addStrictError(new EarlyError(node, 'Labeled FunctionDeclarations are disallowed in strict mode'));\n    }\n    s = isIterationStatement(node.body) ? s.observeIterationLabel(node.label) : s.observeNonIterationLabel(node.label);\n    return s;\n  }\n  reduceLiteralRegExpExpression() {\n    let s = this.identity;\n    // NOTE: the RegExp pattern acceptor is disabled until we have more confidence in its correctness (more tests)\n    // if (!PatternAcceptor.test(node.pattern, node.flags.indexOf(\"u\") >= 0)) {\n    //  s = s.addError(new EarlyError(node, \"Invalid regular expression pattern\"));\n    // }\n    return s;\n  }\n  reduceMethod(node, {\n    name,\n    params,\n    body\n  }) {\n    let isSimpleParameterList = node.params.rest == null && node.params.items.every(i => i.type === 'BindingIdentifier');\n    params = params.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    body = body.enforceConflictingLexicallyDeclaredNames(params.lexicallyDeclaredNames, DUPLICATE_BINDING);\n    if (node.name.type === 'StaticPropertyName' && node.name.value === 'constructor') {\n      body = body.observeConstructorMethod();\n      params = params.observeConstructorMethod();\n    } else {\n      body = body.enforceSuperCallExpressions(SUPERCALL_ERROR);\n      params = params.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    }\n    if (node.isGenerator) {\n      params.yieldExpressions.forEach(n => {\n        params = params.addError(new EarlyError(n, 'Generator parameters must not contain yield expressions'));\n      });\n    }\n    if (node.isAsync) {\n      params.awaitExpressions.forEach(n => {\n        params = params.addError(new EarlyError(n, 'Async function parameters must not contain await expressions'));\n      });\n    }\n    body = body.clearSuperPropertyExpressions();\n    params = params.clearSuperPropertyExpressions();\n    params = params.clearNewTargetExpressions();\n    body = body.clearNewTargetExpressions();\n    if (isStrictFunctionBody(node.body)) {\n      params = params.enforceStrictErrors();\n      body = body.enforceStrictErrors();\n    }\n    let s = super.reduceMethod(node, {\n      name,\n      params,\n      body\n    });\n    if (!isSimpleParameterList && isStrictFunctionBody(node.body)) {\n      s = s.addError(new EarlyError(node, 'Functions with non-simple parameter lists may not contain a \"use strict\" directive'));\n    }\n    s = s.clearYieldExpressions();\n    s = s.clearAwaitExpressions();\n    s = s.observeVarBoundary();\n    return s;\n  }\n  reduceModule() {\n    let s = super.reduceModule(...arguments);\n    s = s.functionDeclarationNamesAreLexical();\n    s = s.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    s = s.enforceConflictingLexicallyDeclaredNames(s.varDeclaredNames, DUPLICATE_BINDING);\n    s.exportedNames.forEachEntry((nodes, bindingName) => {\n      if (nodes.length > 1) {\n        nodes.slice(1).forEach(dupeNode => {\n          s = s.addError(new EarlyError(dupeNode, `Duplicate export ${JSON.stringify(bindingName)}`));\n        });\n      }\n    });\n    s.exportedBindings.forEachEntry((nodes, bindingName) => {\n      if (!s.lexicallyDeclaredNames.has(bindingName) && !s.varDeclaredNames.has(bindingName)) {\n        nodes.forEach(undeclaredNode => {\n          s = s.addError(new EarlyError(undeclaredNode, `Exported binding ${JSON.stringify(bindingName)} is not declared`));\n        });\n      }\n    });\n    s.newTargetExpressions.forEach(node => {\n      s = s.addError(new EarlyError(node, 'new.target must be within function (but not arrow expression) code'));\n    });\n    s = s.enforceFreeContinueStatementErrors(FREE_CONTINUE);\n    s = s.enforceFreeLabeledContinueStatementErrors(UNBOUND_CONTINUE);\n    s = s.enforceFreeBreakStatementErrors(FREE_BREAK);\n    s = s.enforceFreeLabeledBreakStatementErrors(UNBOUND_BREAK);\n    s = s.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    s = s.enforceSuperPropertyExpressions(SUPERPROPERTY_ERROR);\n    s = s.enforceStrictErrors();\n    return s;\n  }\n  reduceNewTargetExpression(node) {\n    return this.identity.observeNewTargetExpression(node);\n  }\n  reduceObjectExpression(node) {\n    let s = super.reduceObjectExpression(...arguments);\n    s = s.enforceSuperCallExpressionsInConstructorMethod(SUPERCALL_ERROR);\n    let protos = node.properties.filter(p => p.type === 'DataProperty' && p.name.type === 'StaticPropertyName' && p.name.value === '__proto__');\n    protos.slice(1).forEach(n => {\n      s = s.addError(new EarlyError(n, 'Duplicate __proto__ property in object literal not allowed'));\n    });\n    return s;\n  }\n  reduceUpdateExpression() {\n    let s = super.reduceUpdateExpression(...arguments);\n    s = s.clearBoundNames();\n    return s;\n  }\n  reduceUnaryExpression(node) {\n    let s = super.reduceUnaryExpression(...arguments);\n    if (node.operator === 'delete' && node.operand.type === 'IdentifierExpression') {\n      s = s.addStrictError(new EarlyError(node, 'Identifier expressions must not be deleted in strict mode'));\n    }\n    return s;\n  }\n  reduceScript(node) {\n    let s = super.reduceScript(...arguments);\n    s = s.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    s = s.enforceConflictingLexicallyDeclaredNames(s.varDeclaredNames, DUPLICATE_BINDING);\n    s.newTargetExpressions.forEach(n => {\n      s = s.addError(new EarlyError(n, 'new.target must be within function (but not arrow expression) code'));\n    });\n    s = s.enforceFreeContinueStatementErrors(FREE_CONTINUE);\n    s = s.enforceFreeLabeledContinueStatementErrors(UNBOUND_CONTINUE);\n    s = s.enforceFreeBreakStatementErrors(FREE_BREAK);\n    s = s.enforceFreeLabeledBreakStatementErrors(UNBOUND_BREAK);\n    s = s.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    s = s.enforceSuperPropertyExpressions(SUPERPROPERTY_ERROR);\n    if (isStrictFunctionBody(node)) {\n      s = s.enforceStrictErrors();\n    }\n    return s;\n  }\n  reduceSetter(node, {\n    name,\n    param,\n    body\n  }) {\n    let isSimpleParameterList = node.param.type === 'BindingIdentifier';\n    param = param.observeLexicalDeclaration();\n    param = param.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    body = body.enforceConflictingLexicallyDeclaredNames(param.lexicallyDeclaredNames, DUPLICATE_BINDING);\n    param = param.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    body = body.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    param = param.clearSuperPropertyExpressions();\n    body = body.clearSuperPropertyExpressions();\n    param = param.clearNewTargetExpressions();\n    body = body.clearNewTargetExpressions();\n    if (isStrictFunctionBody(node.body)) {\n      param = param.enforceStrictErrors();\n      body = body.enforceStrictErrors();\n    }\n    let s = super.reduceSetter(node, {\n      name,\n      param,\n      body\n    });\n    if (!isSimpleParameterList && isStrictFunctionBody(node.body)) {\n      s = s.addError(new EarlyError(node, 'Functions with non-simple parameter lists may not contain a \"use strict\" directive'));\n    }\n    s = s.observeVarBoundary();\n    return s;\n  }\n  reduceStaticMemberExpression(node) {\n    let s = super.reduceStaticMemberExpression(...arguments);\n    if (node.object.type === 'Super') {\n      s = s.observeSuperPropertyExpression(node);\n    }\n    return s;\n  }\n  reduceSwitchStatement(node, {\n    discriminant,\n    cases\n  }) {\n    let sCases = this.append(...cases);\n    sCases = sCases.functionDeclarationNamesAreLexical();\n    sCases = sCases.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    sCases = sCases.enforceConflictingLexicallyDeclaredNames(sCases.varDeclaredNames, DUPLICATE_BINDING);\n    sCases = sCases.observeLexicalBoundary();\n    let s = this.append(discriminant, sCases);\n    s = s.clearFreeBreakStatements();\n    return s;\n  }\n  reduceSwitchStatementWithDefault(node, {\n    discriminant,\n    preDefaultCases,\n    defaultCase,\n    postDefaultCases\n  }) {\n    let sCases = this.append(defaultCase, ...preDefaultCases, ...postDefaultCases);\n    sCases = sCases.functionDeclarationNamesAreLexical();\n    sCases = sCases.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    sCases = sCases.enforceConflictingLexicallyDeclaredNames(sCases.varDeclaredNames, DUPLICATE_BINDING);\n    sCases = sCases.observeLexicalBoundary();\n    let s = this.append(discriminant, sCases);\n    s = s.clearFreeBreakStatements();\n    return s;\n  }\n  reduceVariableDeclaration(node) {\n    let s = super.reduceVariableDeclaration(...arguments);\n    switch (node.kind) {\n      case 'const':\n      case 'let':\n        {\n          s = s.observeLexicalDeclaration();\n          if (s.lexicallyDeclaredNames.has('let')) {\n            s.lexicallyDeclaredNames.get('let').forEach(n => {\n              s = s.addError(new EarlyError(n, 'Lexical declarations must not have a binding named \"let\"'));\n            });\n          }\n          break;\n        }\n      case 'var':\n        s = s.observeVarDeclaration();\n        break;\n    }\n    return s;\n  }\n  reduceVariableDeclarationStatement(node) {\n    let s = super.reduceVariableDeclarationStatement(...arguments);\n    if (node.declaration.kind === 'const') {\n      node.declaration.declarators.forEach(declarator => {\n        if (declarator.init == null) {\n          s = s.addError(new EarlyError(declarator, 'Constant lexical declarations must have an initialiser'));\n        }\n      });\n    }\n    return s;\n  }\n  reduceWhileStatement(node) {\n    let s = super.reduceWhileStatement(...arguments);\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a while statement must not be a labeled function declaration'));\n    }\n    s = s.clearFreeContinueStatements().clearFreeBreakStatements();\n    return s;\n  }\n  reduceWithStatement(node) {\n    let s = super.reduceWithStatement(...arguments);\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a with statement must not be a labeled function declaration'));\n    }\n    s = s.addStrictError(new EarlyError(node, 'Strict mode code must not include a with statement'));\n    return s;\n  }\n  reduceYieldExpression(node) {\n    let s = super.reduceYieldExpression(...arguments);\n    s = s.observeYieldExpression(node);\n    return s;\n  }\n  reduceYieldGeneratorExpression(node) {\n    let s = super.reduceYieldGeneratorExpression(...arguments);\n    s = s.observeYieldExpression(node);\n    return s;\n  }\n  static check(node) {\n    return reduce(new EarlyErrorChecker(), node).errors;\n  }\n}\nmodule.exports = {\n  EarlyErrorChecker\n};","map":{"version":3,"names":["reduce","MonoidalReducer","require","isStrictModeReservedWord","ErrorMessages","EarlyErrorState","EarlyError","isStrictFunctionBody","directives","some","directive","rawValue","isLabelledFunction","node","type","body","isIterationStatement","isSpecialMethod","methodDefinition","name","value","isGenerator","isAsync","Error","enforceDuplicateConstructorMethods","s","ctors","elements","filter","e","isStatic","method","length","slice","forEach","ctor","addError","SUPERCALL_ERROR","ILLEGAL_SUPER_CALL","SUPERPROPERTY_ERROR","DUPLICATE_BINDING","JSON","stringify","FREE_CONTINUE","UNBOUND_CONTINUE","label","FREE_BREAK","UNBOUND_BREAK","EarlyErrorChecker","constructor","reduceAssignmentExpression","arguments","clearBoundNames","reduceAssignmentTargetIdentifier","identity","addStrictError","reduceArrowExpression","params","isSimpleParameterList","rest","items","every","i","enforceDuplicateLexicallyDeclaredNames","enforceConflictingLexicallyDeclaredNames","lexicallyDeclaredNames","enforceStrictErrors","yieldExpressions","n","awaitExpressions","clearYieldExpressions","clearAwaitExpressions","observeVarBoundary","reduceAwaitExpression","expression","observeAwaitExpression","reduceBindingIdentifier","bindName","reduceBlock","functionDeclarationNamesAreLexical","varDeclaredNames","observeLexicalBoundary","reduceBreakStatement","addFreeBreakStatement","addFreeLabeledBreakStatement","reduceCallExpression","callee","observeSuperCallExpression","reduceCatchClause","binding","observeLexicalDeclaration","previousLexicallyDeclaredNames","reduceClassDeclaration","super","_super","sElements","append","clearSuperCallExpressionsInConstructorMethod","reduceClassElement","ILLEGAL_CONSTRUCTORS","reduceClassExpression","reduceCompoundAssignmentExpression","reduceComputedMemberExpression","object","observeSuperPropertyExpression","reduceContinueStatement","addFreeContinueStatement","addFreeLabeledContinueStatement","reduceDoWhileStatement","clearFreeContinueStatements","clearFreeBreakStatements","reduceExport","exportDeclaredNames","reduceExportFrom","clearExportedBindings","reduceExportFromSpecifier","exportName","exportedName","exportBinding","reduceExportLocalSpecifier","reduceExportDefault","reduceFormalParameters","reduceForStatement","init","test","update","kind","declarators","declarator","reduceForInStatement","left","right","reduceForOfStatement","recordForOfVars","reduceForAwaitStatement","reduceFunctionBody","enforceFreeContinueStatementErrors","enforceFreeLabeledContinueStatementErrors","enforceFreeBreakStatementErrors","enforceFreeLabeledBreakStatementErrors","clearUsedLabelNames","reduceFunctionDeclaration","forEachEntry","nodes","dupeNode","enforceSuperCallExpressions","enforceSuperPropertyExpressions","clearNewTargetExpressions","observeFunctionDeclaration","reduceFunctionExpression","bindingName","reduceGetter","clearSuperPropertyExpressions","reduceIdentifierExpression","reduceIfStatement","consequent","alternate","reduceImport","reduceImportNamespace","reduceLabeledStatement","usedLabelNames","indexOf","observeIterationLabel","observeNonIterationLabel","reduceLiteralRegExpExpression","reduceMethod","observeConstructorMethod","reduceModule","exportedNames","exportedBindings","has","undeclaredNode","newTargetExpressions","reduceNewTargetExpression","observeNewTargetExpression","reduceObjectExpression","enforceSuperCallExpressionsInConstructorMethod","protos","properties","p","reduceUpdateExpression","reduceUnaryExpression","operator","operand","reduceScript","reduceSetter","param","reduceStaticMemberExpression","reduceSwitchStatement","discriminant","cases","sCases","reduceSwitchStatementWithDefault","preDefaultCases","defaultCase","postDefaultCases","reduceVariableDeclaration","get","observeVarDeclaration","reduceVariableDeclarationStatement","declaration","reduceWhileStatement","reduceWithStatement","reduceYieldExpression","observeYieldExpression","reduceYieldGeneratorExpression","check","errors","module","exports"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/shift-parser/src/early-errors.js"],"sourcesContent":["/**\n * Copyright 2014 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { reduce, MonoidalReducer } = require('shift-reducer');\nconst { isStrictModeReservedWord } = require('./utils');\nconst { ErrorMessages } = require('./errors');\n\nconst { EarlyErrorState, EarlyError } = require('./early-error-state');\n\nfunction isStrictFunctionBody({ directives }) {\n  return directives.some(directive => directive.rawValue === 'use strict');\n}\n\nfunction isLabelledFunction(node) {\n  return node.type === 'LabeledStatement' &&\n    (node.body.type === 'FunctionDeclaration' || isLabelledFunction(node.body));\n}\n\nfunction isIterationStatement(node) {\n  switch (node.type) {\n    case 'LabeledStatement':\n      return isIterationStatement(node.body);\n    case 'DoWhileStatement':\n    case 'ForInStatement':\n    case 'ForOfStatement':\n    case 'ForStatement':\n    case 'WhileStatement':\n      return true;\n  }\n  return false;\n}\n\nfunction isSpecialMethod(methodDefinition) {\n  if (methodDefinition.name.type !== 'StaticPropertyName' || methodDefinition.name.value !== 'constructor') {\n    return false;\n  }\n  switch (methodDefinition.type) {\n    case 'Getter':\n    case 'Setter':\n      return true;\n    case 'Method':\n      return methodDefinition.isGenerator || methodDefinition.isAsync;\n  }\n  /* istanbul ignore next */\n  throw new Error('not reached');\n}\n\n\nfunction enforceDuplicateConstructorMethods(node, s) {\n  let ctors = node.elements.filter(e =>\n    !e.isStatic &&\n    e.method.type === 'Method' &&\n    !e.method.isGenerator &&\n    e.method.name.type === 'StaticPropertyName' &&\n    e.method.name.value === 'constructor'\n  );\n  if (ctors.length > 1) {\n    ctors.slice(1).forEach(ctor => {\n      s = s.addError(new EarlyError(ctor, 'Duplicate constructor method in class'));\n    });\n  }\n  return s;\n}\n\nconst SUPERCALL_ERROR = node => new EarlyError(node, ErrorMessages.ILLEGAL_SUPER_CALL);\nconst SUPERPROPERTY_ERROR = node => new EarlyError(node, 'Member access on super must be in a method');\nconst DUPLICATE_BINDING = node => new EarlyError(node, `Duplicate binding ${JSON.stringify(node.name)}`);\nconst FREE_CONTINUE = node => new EarlyError(node, 'Continue statement must be nested within an iteration statement');\nconst UNBOUND_CONTINUE = node => new EarlyError(node, `Continue statement must be nested within an iteration statement with label ${JSON.stringify(node.label)}`);\nconst FREE_BREAK = node => new EarlyError(node, 'Break statement must be nested within an iteration statement or a switch statement');\nconst UNBOUND_BREAK = node => new EarlyError(node, `Break statement must be nested within a statement with label ${JSON.stringify(node.label)}`);\n\nclass EarlyErrorChecker extends MonoidalReducer {\n  constructor() {\n    super(EarlyErrorState);\n  }\n\n  reduceAssignmentExpression() {\n    return super.reduceAssignmentExpression(...arguments).clearBoundNames();\n  }\n\n  reduceAssignmentTargetIdentifier(node) {\n    let s = this.identity;\n    if (node.name === 'eval' || node.name === 'arguments' || isStrictModeReservedWord(node.name)) {\n      s = s.addStrictError(new EarlyError(node, `The identifier ${JSON.stringify(node.name)} must not be in binding position in strict mode`));\n    }\n    return s;\n  }\n\n  reduceArrowExpression(node, { params, body }) {\n    let isSimpleParameterList = node.params.rest == null && node.params.items.every(i => i.type === 'BindingIdentifier');\n    params = params.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    if (node.body.type === 'FunctionBody') {\n      body = body.enforceConflictingLexicallyDeclaredNames(params.lexicallyDeclaredNames, DUPLICATE_BINDING);\n      if (isStrictFunctionBody(node.body)) {\n        params = params.enforceStrictErrors();\n        body = body.enforceStrictErrors();\n      }\n    }\n    params.yieldExpressions.forEach(n => {\n      params = params.addError(new EarlyError(n, 'Arrow parameters must not contain yield expressions'));\n    });\n    params.awaitExpressions.forEach(n => {\n      params = params.addError(new EarlyError(n, 'Arrow parameters must not contain await expressions'));\n    });\n    let s = super.reduceArrowExpression(node, { params, body });\n    if (!isSimpleParameterList && node.body.type === 'FunctionBody' && isStrictFunctionBody(node.body)) {\n      s = s.addError(new EarlyError(node, 'Functions with non-simple parameter lists may not contain a \"use strict\" directive'));\n    }\n    s = s.clearYieldExpressions();\n    s = s.clearAwaitExpressions();\n    s = s.observeVarBoundary();\n    return s;\n  }\n\n  reduceAwaitExpression(node, { expression }) {\n    return expression.observeAwaitExpression(node);\n  }\n\n  reduceBindingIdentifier(node) {\n    let s = this.identity;\n    if (node.name === 'eval' || node.name === 'arguments' || isStrictModeReservedWord(node.name)) {\n      s = s.addStrictError(new EarlyError(node, `The identifier ${JSON.stringify(node.name)} must not be in binding position in strict mode`));\n    }\n    s = s.bindName(node.name, node);\n    return s;\n  }\n\n  reduceBlock() {\n    let s = super.reduceBlock(...arguments);\n    s = s.functionDeclarationNamesAreLexical();\n    s = s.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    s = s.enforceConflictingLexicallyDeclaredNames(s.varDeclaredNames, DUPLICATE_BINDING);\n    s = s.observeLexicalBoundary();\n    return s;\n  }\n\n  reduceBreakStatement(node) {\n    let s = super.reduceBreakStatement(...arguments);\n    s = node.label == null\n      ? s.addFreeBreakStatement(node)\n      : s.addFreeLabeledBreakStatement(node);\n    return s;\n  }\n\n  reduceCallExpression(node) {\n    let s = super.reduceCallExpression(...arguments);\n    if (node.callee.type === 'Super') {\n      s = s.observeSuperCallExpression(node);\n    }\n    return s;\n  }\n\n  reduceCatchClause(node, { binding, body }) {\n    if (binding != null) {\n      binding = binding.observeLexicalDeclaration();\n      binding = binding.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n      binding = binding.enforceConflictingLexicallyDeclaredNames(body.previousLexicallyDeclaredNames, DUPLICATE_BINDING);\n    }\n    let s = super.reduceCatchClause(node, { binding, body });\n    s = s.observeLexicalBoundary();\n    return s;\n  }\n\n  reduceClassDeclaration(node, { name, super: _super, elements }) {\n    let s = name.enforceStrictErrors();\n    let sElements = this.append(...elements);\n    sElements = sElements.enforceStrictErrors();\n    if (node.super != null) {\n      _super = _super.enforceStrictErrors();\n      s = this.append(s, _super);\n      sElements = sElements.clearSuperCallExpressionsInConstructorMethod();\n    }\n    s = this.append(s, sElements);\n    s = enforceDuplicateConstructorMethods(node, s);\n    s = s.observeLexicalDeclaration();\n    return s;\n  }\n\n  reduceClassElement(node) {\n    let s = super.reduceClassElement(...arguments);\n    if (!node.isStatic && isSpecialMethod(node.method)) {\n      s = s.addError(new EarlyError(node, ErrorMessages.ILLEGAL_CONSTRUCTORS));\n    }\n    if (node.isStatic && node.method.name.type === 'StaticPropertyName' && node.method.name.value === 'prototype') {\n      s = s.addError(new EarlyError(node, 'Static class methods cannot be named \"prototype\"'));\n    }\n    return s;\n  }\n\n  reduceClassExpression(node, { name, super: _super, elements }) {\n    let s = node.name == null ? this.identity : name.enforceStrictErrors();\n    let sElements = this.append(...elements);\n    sElements = sElements.enforceStrictErrors();\n    if (node.super != null) {\n      _super = _super.enforceStrictErrors();\n      s = this.append(s, _super);\n      sElements = sElements.clearSuperCallExpressionsInConstructorMethod();\n    }\n    s = this.append(s, sElements);\n    s = enforceDuplicateConstructorMethods(node, s);\n    s = s.clearBoundNames();\n    return s;\n  }\n\n  reduceCompoundAssignmentExpression() {\n    return super.reduceCompoundAssignmentExpression(...arguments).clearBoundNames();\n  }\n\n  reduceComputedMemberExpression(node) {\n    let s = super.reduceComputedMemberExpression(...arguments);\n    if (node.object.type === 'Super') {\n      s = s.observeSuperPropertyExpression(node);\n    }\n    return s;\n  }\n\n  reduceContinueStatement(node) {\n    let s = super.reduceContinueStatement(...arguments);\n    s = node.label == null\n      ? s.addFreeContinueStatement(node)\n      : s.addFreeLabeledContinueStatement(node);\n    return s;\n  }\n\n  reduceDoWhileStatement(node) {\n    let s = super.reduceDoWhileStatement(...arguments);\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a do-while statement must not be a labeled function declaration'));\n    }\n    s = s.clearFreeContinueStatements();\n    s = s.clearFreeBreakStatements();\n    return s;\n  }\n\n  reduceExport() {\n    let s = super.reduceExport(...arguments);\n    s = s.functionDeclarationNamesAreLexical();\n    s = s.exportDeclaredNames();\n    return s;\n  }\n\n  reduceExportFrom() {\n    let s = super.reduceExportFrom(...arguments);\n    s = s.clearExportedBindings();\n    return s;\n  }\n\n  reduceExportFromSpecifier(node) {\n    let s = super.reduceExportFromSpecifier(...arguments);\n    s = s.exportName(node.exportedName || node.name, node);\n    s = s.exportBinding(node.name, node);\n    return s;\n  }\n\n  reduceExportLocalSpecifier(node) {\n    let s = super.reduceExportLocalSpecifier(...arguments);\n    s = s.exportName(node.exportedName || node.name.name, node);\n    s = s.exportBinding(node.name.name, node);\n    return s;\n  }\n\n  reduceExportDefault(node) {\n    let s = super.reduceExportDefault(...arguments);\n    s = s.functionDeclarationNamesAreLexical();\n    s = s.exportName('default', node);\n    return s;\n  }\n\n  reduceFormalParameters() {\n    let s = super.reduceFormalParameters(...arguments);\n    s = s.observeLexicalDeclaration();\n    return s;\n  }\n\n  reduceForStatement(node, { init, test, update, body }) {\n    if (init != null) {\n      init = init.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n      init = init.enforceConflictingLexicallyDeclaredNames(body.varDeclaredNames, DUPLICATE_BINDING);\n    }\n    let s = super.reduceForStatement(node, { init, test, update, body });\n    if (node.init != null && node.init.type === 'VariableDeclaration' && node.init.kind === 'const') {\n      node.init.declarators.forEach(declarator => {\n        if (declarator.init == null) {\n          s = s.addError(new EarlyError(declarator, 'Constant lexical declarations must have an initialiser'));\n        }\n      });\n    }\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a for statement must not be a labeled function declaration'));\n    }\n    s = s.clearFreeContinueStatements();\n    s = s.clearFreeBreakStatements();\n    s = s.observeLexicalBoundary();\n    return s;\n  }\n\n  reduceForInStatement(node, { left, right, body }) {\n    left = left.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    left = left.enforceConflictingLexicallyDeclaredNames(body.varDeclaredNames, DUPLICATE_BINDING);\n    let s = super.reduceForInStatement(node, { left, right, body });\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a for-in statement must not be a labeled function declaration'));\n    }\n    s = s.clearFreeContinueStatements();\n    s = s.clearFreeBreakStatements();\n    s = s.observeLexicalBoundary();\n    return s;\n  }\n\n  reduceForOfStatement(node, { left, right, body }) {\n    left = left.recordForOfVars();\n    left = left.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    left = left.enforceConflictingLexicallyDeclaredNames(body.varDeclaredNames, DUPLICATE_BINDING);\n    let s = super.reduceForOfStatement(node, { left, right, body });\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a for-of statement must not be a labeled function declaration'));\n    }\n    s = s.clearFreeContinueStatements();\n    s = s.clearFreeBreakStatements();\n    s = s.observeLexicalBoundary();\n    return s;\n  }\n\n  reduceForAwaitStatement(node, { left, right, body }) {\n    left = left.recordForOfVars();\n    left = left.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    left = left.enforceConflictingLexicallyDeclaredNames(body.varDeclaredNames, DUPLICATE_BINDING);\n    let s = super.reduceForOfStatement(node, { left, right, body });\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a for-await statement must not be a labeled function declaration'));\n    }\n    s = s.clearFreeContinueStatements();\n    s = s.clearFreeBreakStatements();\n    s = s.observeLexicalBoundary();\n    return s;\n  }\n\n  reduceFunctionBody(node) {\n    let s = super.reduceFunctionBody(...arguments);\n    s = s.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    s = s.enforceConflictingLexicallyDeclaredNames(s.varDeclaredNames, DUPLICATE_BINDING);\n    s = s.enforceFreeContinueStatementErrors(FREE_CONTINUE);\n    s = s.enforceFreeLabeledContinueStatementErrors(UNBOUND_CONTINUE);\n    s = s.enforceFreeBreakStatementErrors(FREE_BREAK);\n    s = s.enforceFreeLabeledBreakStatementErrors(UNBOUND_BREAK);\n    s = s.clearUsedLabelNames();\n    s = s.clearYieldExpressions();\n    s = s.clearAwaitExpressions();\n    if (isStrictFunctionBody(node)) {\n      s = s.enforceStrictErrors();\n    }\n    return s;\n  }\n\n  reduceFunctionDeclaration(node, { name, params, body }) {\n    let isSimpleParameterList = node.params.rest == null && node.params.items.every(i => i.type === 'BindingIdentifier');\n    let addError = !isSimpleParameterList || node.isGenerator ? 'addError' : 'addStrictError';\n    params.lexicallyDeclaredNames.forEachEntry(nodes => {\n      if (nodes.length > 1) {\n        nodes.slice(1).forEach(dupeNode => {\n          params = params[addError](DUPLICATE_BINDING(dupeNode));\n        });\n      }\n    });\n    body = body.enforceConflictingLexicallyDeclaredNames(params.lexicallyDeclaredNames, DUPLICATE_BINDING);\n    body = body.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    body = body.enforceSuperPropertyExpressions(SUPERPROPERTY_ERROR);\n    params = params.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    params = params.enforceSuperPropertyExpressions(SUPERPROPERTY_ERROR);\n    if (node.isGenerator) {\n      params.yieldExpressions.forEach(n => {\n        params = params.addError(new EarlyError(n, 'Generator parameters must not contain yield expressions'));\n      });\n    }\n    if (node.isAsync) {\n      params.awaitExpressions.forEach(n => {\n        params = params.addError(new EarlyError(n, 'Async function parameters must not contain await expressions'));\n      });\n    }\n    params = params.clearNewTargetExpressions();\n    body = body.clearNewTargetExpressions();\n    if (isStrictFunctionBody(node.body)) {\n      params = params.enforceStrictErrors();\n      body = body.enforceStrictErrors();\n    }\n    let s = super.reduceFunctionDeclaration(node, { name, params, body });\n    if (!isSimpleParameterList && isStrictFunctionBody(node.body)) {\n      s = s.addError(new EarlyError(node, 'Functions with non-simple parameter lists may not contain a \"use strict\" directive'));\n    }\n    s = s.clearYieldExpressions();\n    s = s.clearAwaitExpressions();\n    s = s.observeFunctionDeclaration();\n    return s;\n  }\n\n  reduceFunctionExpression(node, { name, params, body }) {\n    let isSimpleParameterList = node.params.rest == null && node.params.items.every(i => i.type === 'BindingIdentifier');\n    let addError = !isSimpleParameterList || node.isGenerator ? 'addError' : 'addStrictError';\n    params.lexicallyDeclaredNames.forEachEntry((nodes, bindingName) => {\n      if (nodes.length > 1) {\n        nodes.slice(1).forEach(dupeNode => {\n          params = params[addError](new EarlyError(dupeNode, `Duplicate binding ${JSON.stringify(bindingName)}`));\n        });\n      }\n    });\n    body = body.enforceConflictingLexicallyDeclaredNames(params.lexicallyDeclaredNames, DUPLICATE_BINDING);\n    body = body.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    body = body.enforceSuperPropertyExpressions(SUPERPROPERTY_ERROR);\n    params = params.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    params = params.enforceSuperPropertyExpressions(SUPERPROPERTY_ERROR);\n    if (node.isGenerator) {\n      params.yieldExpressions.forEach(n => {\n        params = params.addError(new EarlyError(n, 'Generator parameters must not contain yield expressions'));\n      });\n    }\n    if (node.isAsync) {\n      params.awaitExpressions.forEach(n => {\n        params = params.addError(new EarlyError(n, 'Async function parameters must not contain await expressions'));\n      });\n    }\n    params = params.clearNewTargetExpressions();\n    body = body.clearNewTargetExpressions();\n    if (isStrictFunctionBody(node.body)) {\n      params = params.enforceStrictErrors();\n      body = body.enforceStrictErrors();\n    }\n    let s = super.reduceFunctionExpression(node, { name, params, body });\n    if (!isSimpleParameterList && isStrictFunctionBody(node.body)) {\n      s = s.addError(new EarlyError(node, 'Functions with non-simple parameter lists may not contain a \"use strict\" directive'));\n    }\n    s = s.clearBoundNames();\n    s = s.clearYieldExpressions();\n    s = s.clearAwaitExpressions();\n    s = s.observeVarBoundary();\n    return s;\n  }\n\n  reduceGetter(node, { name, body }) {\n    body = body.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    body = body.clearSuperPropertyExpressions();\n    body = body.clearNewTargetExpressions();\n    if (isStrictFunctionBody(node.body)) {\n      body = body.enforceStrictErrors();\n    }\n    let s = super.reduceGetter(node, { name, body });\n    s = s.observeVarBoundary();\n    return s;\n  }\n\n  reduceIdentifierExpression(node) {\n    let s = this.identity;\n    if (isStrictModeReservedWord(node.name)) {\n      s = s.addStrictError(new EarlyError(node, `The identifier ${JSON.stringify(node.name)} must not be in expression position in strict mode`));\n    }\n    return s;\n  }\n\n  reduceIfStatement(node, { test, consequent, alternate }) {\n    if (isLabelledFunction(node.consequent)) {\n      consequent = consequent.addError(new EarlyError(node.consequent, 'The consequent of an if statement must not be a labeled function declaration'));\n    }\n    if (node.alternate != null && isLabelledFunction(node.alternate)) {\n      alternate = alternate.addError(new EarlyError(node.alternate, 'The alternate of an if statement must not be a labeled function declaration'));\n    }\n    if (node.consequent.type === 'FunctionDeclaration') {\n      consequent = consequent.addStrictError(new EarlyError(node.consequent, 'FunctionDeclarations in IfStatements are disallowed in strict mode'));\n      consequent = consequent.observeLexicalBoundary();\n    }\n    if (node.alternate != null && node.alternate.type === 'FunctionDeclaration') {\n      alternate = alternate.addStrictError(new EarlyError(node.alternate, 'FunctionDeclarations in IfStatements are disallowed in strict mode'));\n      alternate = alternate.observeLexicalBoundary();\n    }\n    return super.reduceIfStatement(node, { test, consequent, alternate });\n  }\n\n  reduceImport() {\n    let s = super.reduceImport(...arguments);\n    s = s.observeLexicalDeclaration();\n    return s;\n  }\n\n  reduceImportNamespace() {\n    let s = super.reduceImportNamespace(...arguments);\n    s = s.observeLexicalDeclaration();\n    return s;\n  }\n\n  reduceLabeledStatement(node) {\n    let s = super.reduceLabeledStatement(...arguments);\n    if (node.label === 'yield' || isStrictModeReservedWord(node.label)) {\n      s = s.addStrictError(new EarlyError(node, `The identifier ${JSON.stringify(node.label)} must not be in label position in strict mode`));\n    }\n    if (s.usedLabelNames.indexOf(node.label) >= 0) {\n      s = s.addError(new EarlyError(node, `Label ${JSON.stringify(node.label)} has already been declared`));\n    }\n    if (node.body.type === 'FunctionDeclaration') {\n      s = s.addStrictError(new EarlyError(node, 'Labeled FunctionDeclarations are disallowed in strict mode'));\n    }\n    s = isIterationStatement(node.body)\n      ? s.observeIterationLabel(node.label)\n      : s.observeNonIterationLabel(node.label);\n    return s;\n  }\n\n  reduceLiteralRegExpExpression() {\n    let s = this.identity;\n    // NOTE: the RegExp pattern acceptor is disabled until we have more confidence in its correctness (more tests)\n    // if (!PatternAcceptor.test(node.pattern, node.flags.indexOf(\"u\") >= 0)) {\n    //  s = s.addError(new EarlyError(node, \"Invalid regular expression pattern\"));\n    // }\n    return s;\n  }\n\n  reduceMethod(node, { name, params, body }) {\n    let isSimpleParameterList = node.params.rest == null && node.params.items.every(i => i.type === 'BindingIdentifier');\n    params = params.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    body = body.enforceConflictingLexicallyDeclaredNames(params.lexicallyDeclaredNames, DUPLICATE_BINDING);\n    if (node.name.type === 'StaticPropertyName' && node.name.value === 'constructor') {\n      body = body.observeConstructorMethod();\n      params = params.observeConstructorMethod();\n    } else {\n      body = body.enforceSuperCallExpressions(SUPERCALL_ERROR);\n      params = params.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    }\n    if (node.isGenerator) {\n      params.yieldExpressions.forEach(n => {\n        params = params.addError(new EarlyError(n, 'Generator parameters must not contain yield expressions'));\n      });\n    }\n    if (node.isAsync) {\n      params.awaitExpressions.forEach(n => {\n        params = params.addError(new EarlyError(n, 'Async function parameters must not contain await expressions'));\n      });\n    }\n    body = body.clearSuperPropertyExpressions();\n    params = params.clearSuperPropertyExpressions();\n    params = params.clearNewTargetExpressions();\n    body = body.clearNewTargetExpressions();\n    if (isStrictFunctionBody(node.body)) {\n      params = params.enforceStrictErrors();\n      body = body.enforceStrictErrors();\n    }\n    let s = super.reduceMethod(node, { name, params, body });\n    if (!isSimpleParameterList && isStrictFunctionBody(node.body)) {\n      s = s.addError(new EarlyError(node, 'Functions with non-simple parameter lists may not contain a \"use strict\" directive'));\n    }\n    s = s.clearYieldExpressions();\n    s = s.clearAwaitExpressions();\n    s = s.observeVarBoundary();\n    return s;\n  }\n\n  reduceModule() {\n    let s = super.reduceModule(...arguments);\n    s = s.functionDeclarationNamesAreLexical();\n    s = s.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    s = s.enforceConflictingLexicallyDeclaredNames(s.varDeclaredNames, DUPLICATE_BINDING);\n    s.exportedNames.forEachEntry((nodes, bindingName) => {\n      if (nodes.length > 1) {\n        nodes.slice(1).forEach(dupeNode => {\n          s = s.addError(new EarlyError(dupeNode, `Duplicate export ${JSON.stringify(bindingName)}`));\n        });\n      }\n    });\n    s.exportedBindings.forEachEntry((nodes, bindingName) => {\n      if (!s.lexicallyDeclaredNames.has(bindingName) && !s.varDeclaredNames.has(bindingName)) {\n        nodes.forEach(undeclaredNode => {\n          s = s.addError(new EarlyError(undeclaredNode, `Exported binding ${JSON.stringify(bindingName)} is not declared`));\n        });\n      }\n    });\n    s.newTargetExpressions.forEach(node => {\n      s = s.addError(new EarlyError(node, 'new.target must be within function (but not arrow expression) code'));\n    });\n    s = s.enforceFreeContinueStatementErrors(FREE_CONTINUE);\n    s = s.enforceFreeLabeledContinueStatementErrors(UNBOUND_CONTINUE);\n    s = s.enforceFreeBreakStatementErrors(FREE_BREAK);\n    s = s.enforceFreeLabeledBreakStatementErrors(UNBOUND_BREAK);\n    s = s.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    s = s.enforceSuperPropertyExpressions(SUPERPROPERTY_ERROR);\n    s = s.enforceStrictErrors();\n    return s;\n  }\n\n  reduceNewTargetExpression(node) {\n    return this.identity.observeNewTargetExpression(node);\n  }\n\n  reduceObjectExpression(node) {\n    let s = super.reduceObjectExpression(...arguments);\n    s = s.enforceSuperCallExpressionsInConstructorMethod(SUPERCALL_ERROR);\n    let protos = node.properties.filter(p => p.type === 'DataProperty' && p.name.type === 'StaticPropertyName' && p.name.value === '__proto__');\n    protos.slice(1).forEach(n => {\n      s = s.addError(new EarlyError(n, 'Duplicate __proto__ property in object literal not allowed'));\n    });\n    return s;\n  }\n\n  reduceUpdateExpression() {\n    let s = super.reduceUpdateExpression(...arguments);\n    s = s.clearBoundNames();\n    return s;\n  }\n\n  reduceUnaryExpression(node) {\n    let s = super.reduceUnaryExpression(...arguments);\n    if (node.operator === 'delete' && node.operand.type === 'IdentifierExpression') {\n      s = s.addStrictError(new EarlyError(node, 'Identifier expressions must not be deleted in strict mode'));\n    }\n    return s;\n  }\n\n  reduceScript(node) {\n    let s = super.reduceScript(...arguments);\n    s = s.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    s = s.enforceConflictingLexicallyDeclaredNames(s.varDeclaredNames, DUPLICATE_BINDING);\n    s.newTargetExpressions.forEach(n => {\n      s = s.addError(new EarlyError(n, 'new.target must be within function (but not arrow expression) code'));\n    });\n    s = s.enforceFreeContinueStatementErrors(FREE_CONTINUE);\n    s = s.enforceFreeLabeledContinueStatementErrors(UNBOUND_CONTINUE);\n    s = s.enforceFreeBreakStatementErrors(FREE_BREAK);\n    s = s.enforceFreeLabeledBreakStatementErrors(UNBOUND_BREAK);\n    s = s.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    s = s.enforceSuperPropertyExpressions(SUPERPROPERTY_ERROR);\n    if (isStrictFunctionBody(node)) {\n      s = s.enforceStrictErrors();\n    }\n    return s;\n  }\n\n  reduceSetter(node, { name, param, body }) {\n    let isSimpleParameterList = node.param.type === 'BindingIdentifier';\n    param = param.observeLexicalDeclaration();\n    param = param.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    body = body.enforceConflictingLexicallyDeclaredNames(param.lexicallyDeclaredNames, DUPLICATE_BINDING);\n    param = param.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    body = body.enforceSuperCallExpressions(SUPERCALL_ERROR);\n    param = param.clearSuperPropertyExpressions();\n    body = body.clearSuperPropertyExpressions();\n    param = param.clearNewTargetExpressions();\n    body = body.clearNewTargetExpressions();\n    if (isStrictFunctionBody(node.body)) {\n      param = param.enforceStrictErrors();\n      body = body.enforceStrictErrors();\n    }\n    let s = super.reduceSetter(node, { name, param, body });\n    if (!isSimpleParameterList && isStrictFunctionBody(node.body)) {\n      s = s.addError(new EarlyError(node, 'Functions with non-simple parameter lists may not contain a \"use strict\" directive'));\n    }\n    s = s.observeVarBoundary();\n    return s;\n  }\n\n  reduceStaticMemberExpression(node) {\n    let s = super.reduceStaticMemberExpression(...arguments);\n    if (node.object.type === 'Super') {\n      s = s.observeSuperPropertyExpression(node);\n    }\n    return s;\n  }\n\n  reduceSwitchStatement(node, { discriminant, cases }) {\n    let sCases = this.append(...cases);\n    sCases = sCases.functionDeclarationNamesAreLexical();\n    sCases = sCases.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    sCases = sCases.enforceConflictingLexicallyDeclaredNames(sCases.varDeclaredNames, DUPLICATE_BINDING);\n    sCases = sCases.observeLexicalBoundary();\n    let s = this.append(discriminant, sCases);\n    s = s.clearFreeBreakStatements();\n    return s;\n  }\n\n  reduceSwitchStatementWithDefault(node, { discriminant, preDefaultCases, defaultCase, postDefaultCases }) {\n    let sCases = this.append(defaultCase, ...preDefaultCases, ...postDefaultCases);\n    sCases = sCases.functionDeclarationNamesAreLexical();\n    sCases = sCases.enforceDuplicateLexicallyDeclaredNames(DUPLICATE_BINDING);\n    sCases = sCases.enforceConflictingLexicallyDeclaredNames(sCases.varDeclaredNames, DUPLICATE_BINDING);\n    sCases = sCases.observeLexicalBoundary();\n    let s = this.append(discriminant, sCases);\n    s = s.clearFreeBreakStatements();\n    return s;\n  }\n\n  reduceVariableDeclaration(node) {\n    let s = super.reduceVariableDeclaration(...arguments);\n    switch (node.kind) {\n      case 'const':\n      case 'let': {\n        s = s.observeLexicalDeclaration();\n        if (s.lexicallyDeclaredNames.has('let')) {\n          s.lexicallyDeclaredNames.get('let').forEach(n => {\n            s = s.addError(new EarlyError(n, 'Lexical declarations must not have a binding named \"let\"'));\n          });\n        }\n        break;\n      }\n      case 'var':\n        s = s.observeVarDeclaration();\n        break;\n    }\n    return s;\n  }\n\n  reduceVariableDeclarationStatement(node) {\n    let s = super.reduceVariableDeclarationStatement(...arguments);\n    if (node.declaration.kind === 'const') {\n      node.declaration.declarators.forEach(declarator => {\n        if (declarator.init == null) {\n          s = s.addError(new EarlyError(declarator, 'Constant lexical declarations must have an initialiser'));\n        }\n      });\n    }\n    return s;\n  }\n\n  reduceWhileStatement(node) {\n    let s = super.reduceWhileStatement(...arguments);\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a while statement must not be a labeled function declaration'));\n    }\n    s = s.clearFreeContinueStatements().clearFreeBreakStatements();\n    return s;\n  }\n\n  reduceWithStatement(node) {\n    let s = super.reduceWithStatement(...arguments);\n    if (isLabelledFunction(node.body)) {\n      s = s.addError(new EarlyError(node.body, 'The body of a with statement must not be a labeled function declaration'));\n    }\n    s = s.addStrictError(new EarlyError(node, 'Strict mode code must not include a with statement'));\n    return s;\n  }\n\n  reduceYieldExpression(node) {\n    let s = super.reduceYieldExpression(...arguments);\n    s = s.observeYieldExpression(node);\n    return s;\n  }\n\n  reduceYieldGeneratorExpression(node) {\n    let s = super.reduceYieldGeneratorExpression(...arguments);\n    s = s.observeYieldExpression(node);\n    return s;\n  }\n\n\n  static check(node) {\n    return reduce(new EarlyErrorChecker, node).errors;\n  }\n}\n\nmodule.exports = { EarlyErrorChecker };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}