{"ast":null,"code":"/**\n * Copyright 2018 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable no-use-before-define */\n\nconst matchPropertyValue = require('unicode-match-property-value-ecmascript');\nconst matchPropertyValueMappings = require('unicode-match-property-value-ecmascript/data/mappings');\nconst matchProperty = require('unicode-match-property-ecmascript');\nconst propertyAliases = require('unicode-property-aliases-ecmascript');\nconst {\n  idContinueBool,\n  idContinueLargeRegex,\n  idStartBool,\n  idStartLargeRegex\n} = require('./unicode');\nconst catchIsFalse = predicate => {\n  try {\n    return !!predicate();\n  } catch (e) {\n    return false;\n  }\n};\nconst syntaxCharacters = '^$\\\\.*+?()[]{}|'.split('');\nconst extendedSyntaxCharacters = '^$\\\\.*+?()[|'.split('');\nconst controlEscapeCharacters = 'fnrtv'.split('');\nconst controlEscapeCharacterValues = {\n  'f': '\\f'.charCodeAt(0),\n  'n': '\\n'.charCodeAt(0),\n  'r': '\\r'.charCodeAt(0),\n  't': '\\t'.charCodeAt(0),\n  'v': '\\v'.charCodeAt(0)\n};\nconst controlCharacters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\nconst hexDigits = '0123456789abcdefABCDEF'.split('');\nconst decimalDigits = '0123456789'.split('');\nconst octalDigits = '01234567'.split('');\nconst INVALID_NAMED_BACKREFERENCE_SENTINEL = {};\nfunction isIdentifierStart(ch) {\n  return ch < 128 ? idStartBool[ch] : idStartLargeRegex.test(String.fromCodePoint(ch));\n}\nfunction isIdentifierPart(ch) {\n  return ch < 128 ? idContinueBool[ch] : idContinueLargeRegex.test(String.fromCodePoint(ch));\n}\nclass PatternAcceptorState {\n  constructor(pattern, unicode) {\n    this.pattern = pattern;\n    this.unicode = unicode;\n    this.index = 0;\n    this.largestBackreference = 0;\n    this.backreferenceNames = [];\n    this.groupingNames = [];\n    this.capturingGroups = 0;\n  }\n  empty() {\n    return this.index >= this.pattern.length;\n  }\n  backreference(ref) {\n    if (ref > this.largestBackreference) {\n      this.largestBackreference = ref;\n    }\n  }\n  nextCodePoint() {\n    if (this.empty()) {\n      return null;\n    }\n    if (this.unicode) {\n      return String.fromCodePoint(this.pattern.codePointAt(this.index));\n    }\n    return this.pattern.charAt(this.index);\n  }\n  skipCodePoint() {\n    this.index += this.nextCodePoint().length;\n  }\n  eat(str) {\n    if (this.index + str.length > this.pattern.length || this.pattern.slice(this.index, this.index + str.length) !== str) {\n      return false;\n    }\n    this.index += str.length;\n    return true;\n  }\n  eatIdentifierCodePoint() {\n    let characterValue;\n    let originalIndex = this.index;\n    let character;\n    if (this.match('\\\\u')) {\n      this.skipCodePoint();\n      characterValue = acceptUnicodeEscape(this);\n      if (!characterValue.matched) {\n        this.index = originalIndex;\n        return null;\n      }\n      characterValue = characterValue.value;\n      character = String.fromCodePoint(characterValue);\n    } else {\n      character = this.nextCodePoint();\n      if (character == null) {\n        this.index = originalIndex;\n        return null;\n      }\n      this.index += character.length;\n      characterValue = character.codePointAt(0);\n    }\n    return {\n      character,\n      characterValue\n    };\n  }\n  eatIdentifierStart() {\n    let originalIndex = this.index;\n    let codePoint = this.eatIdentifierCodePoint();\n    if (codePoint === null) {\n      this.index = originalIndex;\n      return null;\n    }\n    if (codePoint.character === '_' || codePoint.character === '$' || isIdentifierStart(codePoint.characterValue)) {\n      return codePoint.character;\n    }\n    this.index = originalIndex;\n    return null;\n  }\n  eatIdentifierPart() {\n    let originalIndex = this.index;\n    let codePoint = this.eatIdentifierCodePoint();\n    if (codePoint === null) {\n      this.index = originalIndex;\n      return null;\n    }\n    // ZWNJ / ZWJ\n    if (codePoint.character === '\\u200C' || codePoint.character === '\\u200D' || codePoint.character === '$' || isIdentifierPart(codePoint.characterValue)) {\n      return codePoint.character;\n    }\n    this.index = originalIndex;\n    return null;\n  }\n  eatAny(...strs) {\n    for (let str of strs) {\n      if (this.eat(str)) {\n        return str;\n      }\n    }\n    return null;\n  }\n  match(str) {\n    return this.index + str.length <= this.pattern.length && this.pattern.slice(this.index, this.index + str.length) === str;\n  }\n  matchAny(...strs) {\n    for (let str of strs) {\n      if (this.match(str)) {\n        return true;\n      }\n    }\n    return false;\n  }\n  eatNaturalNumber() {\n    let characters = [];\n    let eatNumber = () => {\n      for (let str of decimalDigits) {\n        if (this.eat(str)) {\n          characters.push(str);\n          return true;\n        }\n      }\n      return false;\n    };\n    while (eatNumber());\n    return characters.length === 0 ? null : characters.join('');\n  }\n}\n\n// acceptRegex\nmodule.exports = (pattern, {\n  unicode = false\n} = {}) => {\n  let state = new PatternAcceptorState(pattern, unicode);\n  let accepted = acceptDisjunction(state);\n  if (accepted.matched) {\n    if (state.unicode) {\n      if (state.largestBackreference > state.capturingGroups) {\n        return false;\n      }\n    }\n    if (state.groupingNames.length > 0 || state.unicode) {\n      for (let backreferenceName of state.backreferenceNames) {\n        if (state.groupingNames.indexOf(backreferenceName) === -1) {\n          return false;\n        }\n      }\n    }\n  }\n  return accepted.matched;\n};\nconst backtrackOnFailure = func => state => {\n  let savedIndex = state.index;\n  let oldBackreference = state.largestBackreference;\n  let oldCapturingGroups = state.capturingGroups;\n  let val = func(state);\n  if (!val.matched) {\n    state.index = savedIndex;\n    state.largestBackreference = oldBackreference;\n    state.capturingGroups = oldCapturingGroups;\n  }\n  return val;\n};\nconst acceptUnicodeEscape = backtrackOnFailure(state => {\n  if (!state.eat('u')) {\n    return {\n      matched: false\n    };\n  }\n  if (state.unicode && state.eat('{')) {\n    let digits = [];\n    while (!state.eat('}')) {\n      let digit = state.eatAny(...hexDigits);\n      if (digit === null) {\n        return {\n          matched: false\n        };\n      }\n      digits.push(digit);\n    }\n    let value = parseInt(digits.join(''), 16);\n    return value > 0x10FFFF ? {\n      matched: false\n    } : {\n      matched: true,\n      value\n    };\n  }\n  let digits = [0, 0, 0, 0].map(() => state.eatAny(...hexDigits));\n  if (digits.some(digit => digit === null)) {\n    return {\n      matched: false\n    };\n  }\n  let value = parseInt(digits.join(''), 16);\n  if (state.unicode && value >= 0xD800 && value <= 0xDBFF) {\n    let surrogatePairValue = backtrackOnFailure(subState => {\n      if (!subState.eat('\\\\u')) {\n        return {\n          matched: false\n        };\n      }\n      let digits2 = [0, 0, 0, 0].map(() => subState.eatAny(...hexDigits));\n      if (digits2.some(digit => digit === null)) {\n        return {\n          matched: false\n        };\n      }\n      let value2 = parseInt(digits2.join(''), 16);\n      if (value2 < 0xDC00 || value2 >= 0xE000) {\n        return {\n          matched: false\n        };\n      }\n      return {\n        matched: true,\n        value: 0x10000 + ((value & 0x03FF) << 10) + (value2 & 0x03FF)\n      };\n    })(state);\n    if (surrogatePairValue.matched) {\n      return surrogatePairValue;\n    }\n  }\n  return {\n    matched: true,\n    value\n  };\n});\nconst acceptDisjunction = (state, terminator) => {\n  do {\n    if (terminator !== void 0 && state.eat(terminator)) {\n      return {\n        matched: true\n      };\n    } else if (state.match('|')) {\n      continue;\n    }\n    if (!acceptAlternative(state, terminator).matched) {\n      return {\n        matched: false\n      };\n    }\n  } while (state.eat('|'));\n  return {\n    matched: terminator === void 0 || !!state.eat(terminator)\n  };\n};\nconst acceptAlternative = (state, terminator) => {\n  while (!state.match('|') && !state.empty() && (terminator === void 0 || !state.match(terminator))) {\n    if (!acceptTerm(state).matched) {\n      return {\n        matched: false\n      };\n    }\n  }\n  return {\n    matched: true\n  };\n};\nconst anyOf = (...acceptors) => state => {\n  for (let predicate of acceptors) {\n    let value = predicate(state);\n    if (value.matched) {\n      return value;\n    }\n  }\n  return {\n    matched: false\n  };\n};\nconst acceptTerm = state => {\n  // non-quantified references are rolled into quantified accepts to improve performance significantly.\n  if (state.unicode) {\n    return anyOf(acceptAssertion, acceptQuantified(acceptAtom))(state);\n  }\n  return anyOf(acceptQuantified(acceptQuantifiableAssertion), acceptAssertion, acceptQuantified(acceptAtom))(state);\n};\nconst acceptLabeledGroup = predicate => backtrackOnFailure(state => {\n  if (!state.eat('(')) {\n    return {\n      matched: false\n    };\n  }\n  if (predicate(state)) {\n    return acceptDisjunction(state, ')');\n  }\n  return {\n    matched: false\n  };\n});\nconst acceptQuantifiableAssertion = acceptLabeledGroup(state => !!state.eatAny('?=', '?!'));\nconst acceptAssertion = state => {\n  if (state.eatAny('^', '$', '\\\\b', '\\\\B')) {\n    return {\n      matched: true\n    };\n  }\n  return acceptLabeledGroup(subState => subState.unicode ? !!subState.eatAny('?=', '?!', '?<=', '?<!') : !!subState.eatAny('?<=', '?<!'))(state);\n};\nconst acceptDecimal = state => {\n  return {\n    matched: state.eatNaturalNumber() !== null\n  };\n};\nconst acceptQuantified = acceptor => backtrackOnFailure(state => {\n  if (!acceptor(state).matched) {\n    return {\n      matched: false\n    };\n  }\n  if (state.match('{')) {\n    let value = backtrackOnFailure(subState => {\n      subState.eat('{');\n      let num1 = subState.eatNaturalNumber();\n      if (num1 === null) {\n        return {\n          matched: false\n        };\n      }\n      if (subState.eat(',') && subState.matchAny(...decimalDigits)) {\n        let num2 = subState.eatNaturalNumber();\n        if (num2 === null || parseInt(num1) > parseInt(num2)) {\n          return {\n            matched: false\n          };\n        }\n      }\n      if (!subState.eat('}')) {\n        return {\n          matched: false\n        };\n      }\n      subState.eat('?');\n      return {\n        matched: true\n      };\n    })(state);\n    if (!value.matched) {\n      return {\n        matched: !state.unicode\n      };\n    }\n    return value;\n  } else if (state.eatAny('*', '+', '?')) {\n    state.eat('?');\n  }\n  return {\n    matched: true\n  };\n});\nconst acceptCharacterExcept = characters => state => {\n  let nextCodePoint = state.nextCodePoint();\n  if (nextCodePoint === null || characters.indexOf(nextCodePoint) !== -1) {\n    return {\n      matched: false\n    };\n  }\n  state.skipCodePoint();\n  return {\n    matched: true\n  };\n};\nconst acceptPatternCharacter = acceptCharacterExcept(syntaxCharacters);\nconst acceptExtendedPatternCharacter = acceptCharacterExcept(extendedSyntaxCharacters);\nconst acceptInvalidBracedQuantifier = state => {\n  return backtrackOnFailure(subState => {\n    return {\n      matched: !!(subState.eat('{') && acceptDecimal(subState).matched && (!subState.eat(',') || subState.match('}') || acceptDecimal(subState).matched) && subState.eat('}'))\n    };\n  })(state);\n};\nconst acceptAtom = state => {\n  if (state.unicode) {\n    return anyOf(acceptPatternCharacter, subState => ({\n      matched: !!subState.eat('.')\n    }), backtrackOnFailure(subState => subState.eat('\\\\') ? acceptAtomEscape(subState) : {\n      matched: false\n    }), acceptCharacterClass, acceptLabeledGroup(subState => subState.eat('?:')), acceptGrouping)(state);\n  }\n  let matched = anyOf(subState => ({\n    matched: !!subState.eat('.')\n  }), backtrackOnFailure(subState => subState.eat('\\\\') ? acceptAtomEscape(subState) : {\n    matched: false\n  }), backtrackOnFailure(subState => ({\n    matched: subState.eat('\\\\') && subState.match('c')\n  })), acceptCharacterClass, acceptLabeledGroup(subState => subState.eat('?:')), acceptGrouping)(state);\n  if (!matched.matched && acceptInvalidBracedQuantifier(state).matched) {\n    return {\n      matched: false\n    };\n  }\n  return matched.matched ? matched : acceptExtendedPatternCharacter(state);\n};\nconst acceptGrouping = backtrackOnFailure(state => {\n  if (!state.eat('(')) {\n    return {\n      matched: false\n    };\n  }\n  let groupName = backtrackOnFailure(subState => {\n    if (!state.eat('?')) {\n      return {\n        matched: false\n      };\n    }\n    return acceptGroupName(subState);\n  })(state);\n  if (!acceptDisjunction(state, ')').matched) {\n    return {\n      matched: false\n    };\n  }\n  if (groupName.matched) {\n    if (state.groupingNames.indexOf(groupName.data) !== -1) {\n      return {\n        matched: false\n      };\n    }\n    state.groupingNames.push(groupName.data);\n  }\n  state.capturingGroups++;\n  return {\n    matched: true\n  };\n});\nconst acceptDecimalEscape = backtrackOnFailure(state => {\n  let firstDecimal = state.eatAny(...decimalDigits);\n  if (firstDecimal === null) {\n    return {\n      matched: false\n    };\n  }\n  if (firstDecimal === '0') {\n    return {\n      matched: true\n    };\n  }\n  // we also accept octal escapes here, but it is impossible to tell if it is a octal escape until all parsing is complete.\n  // octal escapes are handled in acceptCharacterEscape for classes\n  state.backreference(parseInt(firstDecimal + (state.eatNaturalNumber() || '')));\n  return {\n    matched: true\n  };\n});\nconst acceptCharacterClassEscape = state => {\n  if (state.eatAny('d', 'D', 's', 'S', 'w', 'W')) {\n    return {\n      matched: true\n    };\n  }\n  if (state.unicode) {\n    return backtrackOnFailure(subState => {\n      if (!subState.eat('p{') && !subState.eat('P{')) {\n        return {\n          matched: false\n        };\n      }\n      if (!acceptUnicodePropertyValueExpression(subState).matched) {\n        return {\n          matched: false\n        };\n      }\n      return {\n        matched: !!subState.eat('}')\n      };\n    })(state);\n  }\n  return {\n    matched: false\n  };\n};\nconst acceptUnicodePropertyName = state => {\n  let characters = [];\n  let character;\n  while (character = state.eatAny(...controlCharacters, '_')) {\n    // eslint-disable-line no-cond-assign\n    characters.push(character);\n  }\n  return {\n    matched: characters.length > 0,\n    data: characters.join('')\n  };\n};\nconst acceptUnicodePropertyValue = state => {\n  let characters = [];\n  let character;\n  while (character = state.eatAny(...controlCharacters, ...decimalDigits, '_')) {\n    // eslint-disable-line no-cond-assign\n    characters.push(character);\n  }\n  return {\n    matched: characters.length > 0,\n    data: characters.join('')\n  };\n};\n\n// excluding nonbinary properties from mathias' list\n// https://www.ecma-international.org/ecma-262/9.0/index.html#table-nonbinary-unicode-properties\nconst illegalLoneUnicodePropertyNames = ['General_Category', 'Script', 'Script_Extensions', 'scx', 'sc', 'gc'];\nconst generalCategoryValues = matchPropertyValueMappings.get('General_Category');\nconst acceptLoneUnicodePropertyNameOrValue = state => {\n  let loneValue = acceptUnicodePropertyValue(state);\n  if (!loneValue.matched || illegalLoneUnicodePropertyNames.includes(loneValue.data)) {\n    return {\n      matched: false\n    };\n  }\n  return {\n    matched: catchIsFalse(() => matchProperty(loneValue.data)) || generalCategoryValues.get(loneValue.data) != null\n  };\n};\nconst acceptUnicodePropertyValueExpression = state => anyOf(backtrackOnFailure(subState => {\n  let name = acceptUnicodePropertyName(subState);\n  if (!name.matched || !subState.eat('=')) {\n    return {\n      matched: false\n    };\n  }\n  let value = acceptUnicodePropertyValue(subState);\n  if (!value.matched) {\n    return {\n      matched: false\n    };\n  }\n  return {\n    matched: catchIsFalse(() => matchPropertyValue(propertyAliases.get(name.data) || name.data, value.data))\n  };\n}), backtrackOnFailure(acceptLoneUnicodePropertyNameOrValue))(state);\nconst acceptCharacterEscape = anyOf(state => {\n  let eaten = state.eatAny(...controlEscapeCharacters);\n  if (eaten === null) {\n    return {\n      matched: false\n    };\n  }\n  return {\n    matched: true,\n    value: controlEscapeCharacterValues[eaten]\n  };\n}, backtrackOnFailure(state => {\n  if (!state.eat('c')) {\n    return {\n      matched: false\n    };\n  }\n  let character = state.eatAny(...controlCharacters);\n  if (character === null) {\n    return {\n      matched: false\n    };\n  }\n  return {\n    matched: true,\n    value: character.charCodeAt(0) % 32\n  };\n}), backtrackOnFailure(state => {\n  if (!state.eat('0') || state.eatAny(...decimalDigits)) {\n    return {\n      matched: false\n    };\n  }\n  return {\n    matched: true,\n    value: 0\n  };\n}), backtrackOnFailure(state => {\n  if (!state.eat('x')) {\n    return {\n      matched: false\n    };\n  }\n  let digits = [0, 0].map(() => state.eatAny(...hexDigits));\n  if (digits.some(value => value === null)) {\n    return {\n      matched: false\n    };\n  }\n  return {\n    matched: true,\n    value: parseInt(digits.join(''), 16)\n  };\n}), acceptUnicodeEscape, backtrackOnFailure(state => {\n  if (state.unicode) {\n    return {\n      matched: false\n    };\n  }\n  let octal1 = state.eatAny(...octalDigits);\n  if (octal1 === null) {\n    return {\n      matched: false\n    };\n  }\n  let octal1Value = parseInt(octal1, 8);\n  if (octalDigits.indexOf(state.nextCodePoint()) === -1) {\n    return {\n      matched: true,\n      value: octal1Value\n    };\n  }\n  let octal2 = state.eatAny(...octalDigits);\n  let octal2Value = parseInt(octal2, 8);\n  if (octal1Value < 4) {\n    if (octalDigits.indexOf(state.nextCodePoint()) === -1) {\n      return {\n        matched: true,\n        value: octal1Value << 3 | octal2Value\n      };\n    }\n    let octal3 = state.eatAny(...octalDigits);\n    let octal3Value = parseInt(octal3, 8);\n    return {\n      matched: true,\n      value: octal1Value << 6 | octal2Value << 3 | octal3Value\n    };\n  }\n  return {\n    matched: true,\n    value: octal1Value << 3 | octal2Value\n  };\n}), backtrackOnFailure(state => {\n  if (!state.unicode) {\n    return {\n      matched: false\n    };\n  }\n  let value = state.eatAny(...syntaxCharacters);\n  if (value === null) {\n    return {\n      matched: false\n    };\n  }\n  return {\n    matched: true,\n    value: value.charCodeAt(0)\n  };\n}), state => {\n  if (!state.unicode || !state.eat('/')) {\n    return {\n      matched: false\n    };\n  }\n  return {\n    matched: true,\n    value: '/'.charCodeAt(0)\n  };\n}, backtrackOnFailure(state => {\n  if (state.unicode) {\n    return {\n      matched: false\n    };\n  }\n  let next = state.nextCodePoint();\n  if (next !== null && next !== 'c' && next !== 'k') {\n    state.skipCodePoint();\n    return {\n      matched: true,\n      value: next.codePointAt(0)\n    };\n  }\n  return {\n    matched: false\n  };\n}));\nconst acceptGroupNameBackreference = backtrackOnFailure(state => {\n  if (!state.eat('k')) {\n    return {\n      matched: false\n    };\n  }\n  let name = acceptGroupName(state);\n  if (!name.matched) {\n    state.backreferenceNames.push(INVALID_NAMED_BACKREFERENCE_SENTINEL);\n    return {\n      matched: true\n    };\n  }\n  state.backreferenceNames.push(name.data);\n  return {\n    matched: true\n  };\n});\nconst acceptGroupName = backtrackOnFailure(state => {\n  if (!state.eat('<')) {\n    return {\n      matched: false\n    };\n  }\n  let characters = [];\n  let start = state.eatIdentifierStart();\n  if (!start) {\n    return {\n      matched: false\n    };\n  }\n  characters.push(start);\n  let part;\n  while (part = state.eatIdentifierPart()) {\n    // eslint-disable-line no-cond-assign\n    characters.push(part);\n  }\n  if (!state.eat('>')) {\n    return {\n      matched: false\n    };\n  }\n  return {\n    matched: characters.length > 0,\n    data: characters.join('')\n  };\n});\nconst acceptAtomEscape = anyOf(acceptDecimalEscape, acceptCharacterClassEscape, acceptCharacterEscape, acceptGroupNameBackreference);\nconst acceptCharacterClass = backtrackOnFailure(state => {\n  if (!state.eat('[')) {\n    return {\n      matched: false\n    };\n  }\n  state.eat('^');\n  const acceptClassEscape = anyOf(subState => {\n    return {\n      matched: !!subState.eat('b'),\n      value: 0x0008\n    };\n  }, subState => {\n    return {\n      matched: subState.unicode && !!subState.eat('-'),\n      value: '-'.charCodeAt(0)\n    };\n  }, backtrackOnFailure(subState => {\n    if (subState.unicode || !subState.eat('c')) {\n      return {\n        matched: false\n      };\n    }\n    let character = subState.eatAny(...decimalDigits, '_');\n    if (character === null) {\n      return {\n        matched: false\n      };\n    }\n    return {\n      matched: true,\n      value: character.charCodeAt(0) % 32\n    };\n  }), acceptCharacterClassEscape, acceptCharacterEscape,\n  // We special-case `\\k` because `acceptCharacterEscape` rejects `\\k` unconditionally,\n  // deferring `\\k` to acceptGroupNameBackreference, which is not called here.\n  // See also https://github.com/tc39/ecma262/issues/2037. This code takes the route of\n  // making it unconditionally legal, rather than legal only in the absence of a group name.\n  subState => {\n    return {\n      matched: !subState.unicode && !!subState.eat('k'),\n      value: 107\n    };\n  });\n  const acceptClassAtomNoDash = localState => {\n    let nextCodePoint = localState.nextCodePoint();\n    if (nextCodePoint === ']' || nextCodePoint === '-' || nextCodePoint === null) {\n      return {\n        matched: false\n      };\n    }\n    if (nextCodePoint !== '\\\\') {\n      localState.skipCodePoint();\n      return {\n        matched: true,\n        value: nextCodePoint.codePointAt(0)\n      };\n    }\n    localState.eat('\\\\');\n    let classEscape = acceptClassEscape(localState);\n    if (!classEscape.matched && localState.nextCodePoint() === 'c' && !localState.unicode) {\n      return {\n        matched: true,\n        value: '\\\\'.charCodeAt(0)\n      };\n    }\n    return classEscape;\n  };\n  const acceptClassAtom = localState => {\n    if (localState.eat('-')) {\n      return {\n        matched: true,\n        value: '-'.charCodeAt(0)\n      };\n    }\n    return acceptClassAtomNoDash(localState);\n  };\n  const finishClassRange = (localState, atom) => {\n    const isUnvaluedPassedAtom = subAtom => {\n      return subAtom.value === void 0 && subAtom.matched;\n    };\n    if (localState.eat('-')) {\n      if (localState.match(']')) {\n        return {\n          matched: true\n        };\n      }\n      let otherAtom = acceptClassAtom(localState);\n      if (!otherAtom.matched) {\n        return {\n          matched: false\n        };\n      }\n      if (localState.unicode && (isUnvaluedPassedAtom(atom) || isUnvaluedPassedAtom(otherAtom))) {\n        return {\n          matched: false\n        };\n      } else if (!(!localState.unicode && (isUnvaluedPassedAtom(atom) || isUnvaluedPassedAtom(otherAtom))) && atom.value > otherAtom.value) {\n        return {\n          matched: false\n        };\n      } else if (localState.match(']')) {\n        return {\n          matched: true\n        };\n      }\n      return acceptNonEmptyClassRanges(localState);\n    }\n    if (localState.match(']')) {\n      return {\n        matched: true\n      };\n    }\n    return acceptNonEmptyClassRangesNoDash(localState);\n  };\n  const acceptNonEmptyClassRanges = localState => {\n    let atom = acceptClassAtom(localState);\n    return atom.matched ? finishClassRange(localState, atom) : {\n      matched: false\n    };\n  };\n  const acceptNonEmptyClassRangesNoDash = localState => {\n    let atom = acceptClassAtomNoDash(localState);\n    return atom.matched ? finishClassRange(localState, atom) : {\n      matched: false\n    };\n  };\n  if (state.eat(']')) {\n    return {\n      matched: true\n    };\n  }\n  let value = acceptNonEmptyClassRanges(state);\n  if (value.matched) {\n    state.eat(']'); // cannot fail, as above will not return matched if it is not seen in advance\n  }\n  return value;\n});","map":{"version":3,"names":["matchPropertyValue","require","matchPropertyValueMappings","matchProperty","propertyAliases","idContinueBool","idContinueLargeRegex","idStartBool","idStartLargeRegex","catchIsFalse","predicate","e","syntaxCharacters","split","extendedSyntaxCharacters","controlEscapeCharacters","controlEscapeCharacterValues","charCodeAt","controlCharacters","hexDigits","decimalDigits","octalDigits","INVALID_NAMED_BACKREFERENCE_SENTINEL","isIdentifierStart","ch","test","String","fromCodePoint","isIdentifierPart","PatternAcceptorState","constructor","pattern","unicode","index","largestBackreference","backreferenceNames","groupingNames","capturingGroups","empty","length","backreference","ref","nextCodePoint","codePointAt","charAt","skipCodePoint","eat","str","slice","eatIdentifierCodePoint","characterValue","originalIndex","character","match","acceptUnicodeEscape","matched","value","eatIdentifierStart","codePoint","eatIdentifierPart","eatAny","strs","matchAny","eatNaturalNumber","characters","eatNumber","push","join","module","exports","state","accepted","acceptDisjunction","backreferenceName","indexOf","backtrackOnFailure","func","savedIndex","oldBackreference","oldCapturingGroups","val","digits","digit","parseInt","map","some","surrogatePairValue","subState","digits2","value2","terminator","acceptAlternative","acceptTerm","anyOf","acceptors","acceptAssertion","acceptQuantified","acceptAtom","acceptQuantifiableAssertion","acceptLabeledGroup","acceptDecimal","acceptor","num1","num2","acceptCharacterExcept","acceptPatternCharacter","acceptExtendedPatternCharacter","acceptInvalidBracedQuantifier","acceptAtomEscape","acceptCharacterClass","acceptGrouping","groupName","acceptGroupName","data","acceptDecimalEscape","firstDecimal","acceptCharacterClassEscape","acceptUnicodePropertyValueExpression","acceptUnicodePropertyName","acceptUnicodePropertyValue","illegalLoneUnicodePropertyNames","generalCategoryValues","get","acceptLoneUnicodePropertyNameOrValue","loneValue","includes","name","acceptCharacterEscape","eaten","octal1","octal1Value","octal2","octal2Value","octal3","octal3Value","next","acceptGroupNameBackreference","start","part","acceptClassEscape","acceptClassAtomNoDash","localState","classEscape","acceptClassAtom","finishClassRange","atom","isUnvaluedPassedAtom","subAtom","otherAtom","acceptNonEmptyClassRanges","acceptNonEmptyClassRangesNoDash"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/shift-regexp-acceptor/src/index.js"],"sourcesContent":["/**\n * Copyright 2018 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* eslint-disable no-use-before-define */\n\nconst matchPropertyValue = require('unicode-match-property-value-ecmascript');\n\nconst matchPropertyValueMappings = require('unicode-match-property-value-ecmascript/data/mappings');\n\nconst matchProperty = require('unicode-match-property-ecmascript');\n\nconst propertyAliases = require('unicode-property-aliases-ecmascript');\n\nconst { idContinueBool, idContinueLargeRegex, idStartBool, idStartLargeRegex } = require('./unicode');\n\nconst catchIsFalse = predicate => {\n  try {\n    return !!predicate();\n  } catch (e) {\n    return false;\n  }\n};\n\nconst syntaxCharacters = '^$\\\\.*+?()[]{}|'.split('');\nconst extendedSyntaxCharacters = '^$\\\\.*+?()[|'.split('');\n\nconst controlEscapeCharacters = 'fnrtv'.split('');\nconst controlEscapeCharacterValues = { 'f': '\\f'.charCodeAt(0), 'n': '\\n'.charCodeAt(0), 'r': '\\r'.charCodeAt(0), 't': '\\t'.charCodeAt(0), 'v': '\\v'.charCodeAt(0) };\n\nconst controlCharacters = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');\nconst hexDigits = '0123456789abcdefABCDEF'.split('');\nconst decimalDigits = '0123456789'.split('');\nconst octalDigits = '01234567'.split('');\n\nconst INVALID_NAMED_BACKREFERENCE_SENTINEL = {};\n\nfunction isIdentifierStart(ch) {\n  return ch < 128 ? idStartBool[ch] : idStartLargeRegex.test(String.fromCodePoint(ch));\n}\n\nfunction isIdentifierPart(ch) {\n  return ch < 128 ? idContinueBool[ch] : idContinueLargeRegex.test(String.fromCodePoint(ch));\n}\n\nclass PatternAcceptorState {\n  constructor(pattern, unicode) {\n    this.pattern = pattern;\n    this.unicode = unicode;\n    this.index = 0;\n    this.largestBackreference = 0;\n    this.backreferenceNames = [];\n    this.groupingNames = [];\n    this.capturingGroups = 0;\n  }\n\n  empty() {\n    return this.index >= this.pattern.length;\n  }\n\n  backreference(ref) {\n    if (ref > this.largestBackreference) {\n      this.largestBackreference = ref;\n    }\n  }\n\n  nextCodePoint() {\n    if (this.empty()) {\n      return null;\n    }\n    if (this.unicode) {\n      return String.fromCodePoint(this.pattern.codePointAt(this.index));\n    }\n    return this.pattern.charAt(this.index);\n  }\n\n  skipCodePoint() {\n    this.index += this.nextCodePoint().length;\n  }\n\n  eat(str) {\n    if (this.index + str.length > this.pattern.length || this.pattern.slice(this.index, this.index + str.length) !== str) {\n      return false;\n    }\n    this.index += str.length;\n    return true;\n  }\n\n  eatIdentifierCodePoint() {\n    let characterValue;\n    let originalIndex = this.index;\n    let character;\n    if (this.match('\\\\u')) {\n      this.skipCodePoint();\n      characterValue = acceptUnicodeEscape(this);\n      if (!characterValue.matched) {\n        this.index = originalIndex;\n        return null;\n      }\n      characterValue = characterValue.value;\n      character = String.fromCodePoint(characterValue);\n    } else {\n      character = this.nextCodePoint();\n      if (character == null) {\n        this.index = originalIndex;\n        return null;\n      }\n      this.index += character.length;\n      characterValue = character.codePointAt(0);\n    }\n    return { character, characterValue };\n  }\n\n  eatIdentifierStart() {\n    let originalIndex = this.index;\n    let codePoint = this.eatIdentifierCodePoint();\n    if (codePoint === null) {\n      this.index = originalIndex;\n      return null;\n    }\n    if (codePoint.character === '_' || codePoint.character === '$' || isIdentifierStart(codePoint.characterValue)) {\n      return codePoint.character;\n    }\n    this.index = originalIndex;\n    return null;\n  }\n\n  eatIdentifierPart() {\n    let originalIndex = this.index;\n    let codePoint = this.eatIdentifierCodePoint();\n    if (codePoint === null) {\n      this.index = originalIndex;\n      return null;\n    }\n    // ZWNJ / ZWJ\n    if (codePoint.character === '\\u200C' || codePoint.character === '\\u200D' || codePoint.character === '$' || isIdentifierPart(codePoint.characterValue)) {\n      return codePoint.character;\n    }\n    this.index = originalIndex;\n    return null;\n  }\n\n  eatAny(...strs) {\n    for (let str of strs) {\n      if (this.eat(str)) {\n        return str;\n      }\n    }\n    return null;\n  }\n\n  match(str) {\n    return this.index + str.length <= this.pattern.length && this.pattern.slice(this.index, this.index + str.length) === str;\n  }\n\n  matchAny(...strs) {\n    for (let str of strs) {\n      if (this.match(str)) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  eatNaturalNumber() {\n    let characters = [];\n    let eatNumber = () => {\n      for (let str of decimalDigits) {\n        if (this.eat(str)) {\n          characters.push(str);\n          return true;\n        }\n      }\n      return false;\n    };\n    while (eatNumber());\n    return characters.length === 0 ? null : characters.join('');\n  }\n}\n\n// acceptRegex\nmodule.exports = (pattern, { unicode = false } = {}) => {\n  let state = new PatternAcceptorState(pattern, unicode);\n  let accepted = acceptDisjunction(state);\n  if (accepted.matched) {\n    if (state.unicode) {\n      if (state.largestBackreference > state.capturingGroups) {\n        return false;\n      }\n    }\n    if (state.groupingNames.length > 0 || state.unicode) {\n      for (let backreferenceName of state.backreferenceNames) {\n        if (state.groupingNames.indexOf(backreferenceName) === -1) {\n          return false;\n        }\n      }\n    }\n  }\n  return accepted.matched;\n};\n\nconst backtrackOnFailure = func => state => {\n  let savedIndex = state.index;\n  let oldBackreference = state.largestBackreference;\n  let oldCapturingGroups = state.capturingGroups;\n  let val = func(state);\n  if (!val.matched) {\n    state.index = savedIndex;\n    state.largestBackreference = oldBackreference;\n    state.capturingGroups = oldCapturingGroups;\n  }\n  return val;\n};\n\nconst acceptUnicodeEscape = backtrackOnFailure(state => {\n  if (!state.eat('u')) {\n    return { matched: false };\n  }\n  if (state.unicode && state.eat('{')) {\n    let digits = [];\n    while (!state.eat('}')) {\n      let digit = state.eatAny(...hexDigits);\n      if (digit === null) {\n        return { matched: false };\n      }\n      digits.push(digit);\n    }\n    let value = parseInt(digits.join(''), 16);\n    return value > 0x10FFFF ? { matched: false } : { matched: true, value };\n  }\n  let digits = [0, 0, 0, 0].map(() => state.eatAny(...hexDigits));\n  if (digits.some(digit => digit === null)) {\n    return { matched: false };\n  }\n  let value = parseInt(digits.join(''), 16);\n  if (state.unicode && value >= 0xD800 && value <= 0xDBFF) {\n    let surrogatePairValue = backtrackOnFailure(subState => {\n      if (!subState.eat('\\\\u')) {\n        return { matched: false };\n      }\n      let digits2 = [0, 0, 0, 0].map(() => subState.eatAny(...hexDigits));\n      if (digits2.some(digit => digit === null)) {\n        return { matched: false };\n      }\n      let value2 = parseInt(digits2.join(''), 16);\n      if (value2 < 0xDC00 || value2 >= 0xE000) {\n        return { matched: false };\n      }\n      return { matched: true, value: 0x10000 + ((value & 0x03FF) << 10) + (value2 & 0x03FF) };\n    })(state);\n    if (surrogatePairValue.matched) {\n      return surrogatePairValue;\n    }\n  }\n  return { matched: true, value };\n});\n\nconst acceptDisjunction = (state, terminator) => {\n  do {\n    if (terminator !== void 0 && state.eat(terminator)) {\n      return { matched: true };\n    } else if (state.match('|')) {\n      continue;\n    }\n    if (!acceptAlternative(state, terminator).matched) {\n      return { matched: false };\n    }\n  } while (state.eat('|'));\n  return { matched: terminator === void 0 || !!state.eat(terminator) };\n};\n\nconst acceptAlternative = (state, terminator) => {\n  while (!state.match('|') && !state.empty() && (terminator === void 0 || !state.match(terminator))) {\n    if (!acceptTerm(state).matched) {\n      return { matched: false };\n    }\n  }\n  return { matched: true };\n};\n\nconst anyOf = (...acceptors) => state => {\n  for (let predicate of acceptors) {\n    let value = predicate(state);\n    if (value.matched) {\n      return value;\n    }\n  }\n  return { matched: false };\n};\n\nconst acceptTerm = state => {\n  // non-quantified references are rolled into quantified accepts to improve performance significantly.\n  if (state.unicode) {\n    return anyOf(acceptAssertion, acceptQuantified(acceptAtom))(state);\n  }\n  return anyOf(acceptQuantified(acceptQuantifiableAssertion),\n    acceptAssertion,\n    acceptQuantified(acceptAtom))(state);\n};\n\nconst acceptLabeledGroup = predicate => backtrackOnFailure(state => {\n  if (!state.eat('(')) {\n    return { matched: false };\n  }\n  if (predicate(state)) {\n    return acceptDisjunction(state, ')');\n  }\n  return { matched: false };\n});\n\nconst acceptQuantifiableAssertion = acceptLabeledGroup(state => !!state.eatAny('?=', '?!'));\n\nconst acceptAssertion = state => {\n  if (state.eatAny('^', '$', '\\\\b', '\\\\B')) {\n    return { matched: true };\n  }\n  return acceptLabeledGroup(subState => subState.unicode ? !!subState.eatAny('?=', '?!', '?<=', '?<!') : !!subState.eatAny('?<=', '?<!'))(state);\n};\n\nconst acceptDecimal = state => {\n  return { matched: state.eatNaturalNumber() !== null };\n};\n\nconst acceptQuantified = acceptor => backtrackOnFailure(state => {\n  if (!acceptor(state).matched) {\n    return { matched: false };\n  }\n  if (state.match('{')) {\n    let value = backtrackOnFailure(subState => {\n      subState.eat('{');\n      let num1 = subState.eatNaturalNumber();\n      if (num1 === null) {\n        return { matched: false };\n      }\n      if (subState.eat(',') && subState.matchAny(...decimalDigits)) {\n        let num2 = subState.eatNaturalNumber();\n        if (num2 === null || parseInt(num1) > parseInt(num2)) {\n          return { matched: false };\n        }\n      }\n      if (!subState.eat('}')) {\n        return { matched: false };\n      }\n      subState.eat('?');\n      return { matched: true };\n    })(state);\n    if (!value.matched) {\n      return { matched: !state.unicode };\n    }\n    return value;\n  } else if (state.eatAny('*', '+', '?')) {\n    state.eat('?');\n  }\n  return { matched: true };\n});\n\nconst acceptCharacterExcept = characters => state => {\n  let nextCodePoint = state.nextCodePoint();\n  if (nextCodePoint === null || characters.indexOf(nextCodePoint) !== -1) {\n    return { matched: false };\n  }\n  state.skipCodePoint();\n  return { matched: true };\n};\n\nconst acceptPatternCharacter = acceptCharacterExcept(syntaxCharacters);\n\nconst acceptExtendedPatternCharacter = acceptCharacterExcept(extendedSyntaxCharacters);\n\nconst acceptInvalidBracedQuantifier = state => {\n  return backtrackOnFailure(subState => {\n    return { matched: !!(subState.eat('{') && acceptDecimal(subState).matched && (!subState.eat(',') || subState.match('}') || acceptDecimal(subState).matched) && subState.eat('}')) };\n  })(state);\n};\n\nconst acceptAtom = state => {\n  if (state.unicode) {\n    return anyOf(acceptPatternCharacter,\n      subState => ({ matched: !!subState.eat('.') }),\n      backtrackOnFailure(subState => subState.eat('\\\\') ? acceptAtomEscape(subState) : { matched: false }),\n      acceptCharacterClass,\n      acceptLabeledGroup(subState => subState.eat('?:')),\n      acceptGrouping)(state);\n  }\n  let matched = anyOf(\n    subState => ({ matched: !!subState.eat('.') }),\n    backtrackOnFailure(subState => subState.eat('\\\\') ? acceptAtomEscape(subState) : { matched: false }),\n    backtrackOnFailure(subState => ({ matched: subState.eat('\\\\') && subState.match('c') })),\n    acceptCharacterClass,\n    acceptLabeledGroup(subState => subState.eat('?:')),\n    acceptGrouping)(state);\n  if (!matched.matched && acceptInvalidBracedQuantifier(state).matched) {\n    return { matched: false };\n  }\n  return matched.matched ? matched : acceptExtendedPatternCharacter(state);\n\n};\n\nconst acceptGrouping = backtrackOnFailure(state => {\n  if (!state.eat('(')) {\n    return { matched: false };\n  }\n  let groupName = backtrackOnFailure(subState => {\n    if (!state.eat('?')) {\n      return { matched: false };\n    }\n    return acceptGroupName(subState);\n  })(state);\n  if (!acceptDisjunction(state, ')').matched) {\n    return { matched: false };\n  }\n  if (groupName.matched) {\n    if (state.groupingNames.indexOf(groupName.data) !== -1) {\n      return { matched: false };\n    }\n    state.groupingNames.push(groupName.data);\n  }\n  state.capturingGroups++;\n  return { matched: true };\n});\n\nconst acceptDecimalEscape = backtrackOnFailure(state => {\n  let firstDecimal = state.eatAny(...decimalDigits);\n  if (firstDecimal === null) {\n    return { matched: false };\n  }\n  if (firstDecimal === '0') {\n    return { matched: true };\n  }\n  // we also accept octal escapes here, but it is impossible to tell if it is a octal escape until all parsing is complete.\n  // octal escapes are handled in acceptCharacterEscape for classes\n  state.backreference(parseInt(firstDecimal + (state.eatNaturalNumber() || '')));\n  return { matched: true };\n});\n\nconst acceptCharacterClassEscape = state => {\n  if (state.eatAny('d', 'D', 's', 'S', 'w', 'W')) {\n    return { matched: true };\n  }\n  if (state.unicode) {\n    return backtrackOnFailure(subState => {\n      if (!subState.eat('p{') && !subState.eat('P{')) {\n        return { matched: false };\n      }\n      if (!acceptUnicodePropertyValueExpression(subState).matched) {\n        return { matched: false };\n      }\n      return { matched: !!subState.eat('}') };\n    })(state);\n  }\n  return { matched: false };\n};\n\nconst acceptUnicodePropertyName = state => {\n  let characters = [];\n  let character;\n  while (character = state.eatAny(...controlCharacters, '_')) { // eslint-disable-line no-cond-assign\n    characters.push(character);\n  }\n  return { matched: characters.length > 0, data: characters.join('') };\n};\n\nconst acceptUnicodePropertyValue = state => {\n  let characters = [];\n  let character;\n  while (character = state.eatAny(...controlCharacters, ...decimalDigits, '_')) { // eslint-disable-line no-cond-assign\n    characters.push(character);\n  }\n  return { matched: characters.length > 0, data: characters.join('') };\n};\n\n// excluding nonbinary properties from mathias' list\n// https://www.ecma-international.org/ecma-262/9.0/index.html#table-nonbinary-unicode-properties\nconst illegalLoneUnicodePropertyNames = [\n  'General_Category',\n  'Script',\n  'Script_Extensions',\n  'scx',\n  'sc',\n  'gc',\n];\n\nconst generalCategoryValues = matchPropertyValueMappings.get('General_Category');\n\nconst acceptLoneUnicodePropertyNameOrValue = state => {\n  let loneValue = acceptUnicodePropertyValue(state);\n  if (!loneValue.matched || illegalLoneUnicodePropertyNames.includes(loneValue.data)) {\n    return { matched: false };\n  }\n\n  return { matched: catchIsFalse(() => matchProperty(loneValue.data)) || generalCategoryValues.get(loneValue.data) != null };\n};\n\nconst acceptUnicodePropertyValueExpression = state =>\n  anyOf(backtrackOnFailure(subState => {\n    let name = acceptUnicodePropertyName(subState);\n    if (!name.matched || !subState.eat('=')) {\n      return { matched: false };\n    }\n    let value = acceptUnicodePropertyValue(subState);\n    if (!value.matched) {\n      return { matched: false };\n    }\n    return { matched: catchIsFalse(() => matchPropertyValue(propertyAliases.get(name.data) || name.data, value.data)) };\n  }),\n  backtrackOnFailure(acceptLoneUnicodePropertyNameOrValue))(state);\n\nconst acceptCharacterEscape = anyOf(\n  state => {\n    let eaten = state.eatAny(...controlEscapeCharacters);\n    if (eaten === null) {\n      return { matched: false };\n    }\n    return { matched: true, value: controlEscapeCharacterValues[eaten] };\n  },\n  backtrackOnFailure(state => {\n    if (!state.eat('c')) {\n      return { matched: false };\n    }\n    let character = state.eatAny(...controlCharacters);\n    if (character === null) {\n      return { matched: false };\n    }\n    return { matched: true, value: character.charCodeAt(0) % 32 };\n  }),\n  backtrackOnFailure(state => {\n    if (!state.eat('0') || state.eatAny(...decimalDigits)) {\n      return { matched: false };\n    }\n    return { matched: true, value: 0 };\n  }),\n  backtrackOnFailure(state => {\n    if (!state.eat('x')) {\n      return { matched: false };\n    }\n    let digits = [0, 0].map(() => state.eatAny(...hexDigits));\n    if (digits.some(value => value === null)) {\n      return { matched: false };\n    }\n    return { matched: true, value: parseInt(digits.join(''), 16) };\n  }),\n  acceptUnicodeEscape,\n  backtrackOnFailure(state => {\n    if (state.unicode) {\n      return { matched: false };\n    }\n    let octal1 = state.eatAny(...octalDigits);\n    if (octal1 === null) {\n      return { matched: false };\n    }\n    let octal1Value = parseInt(octal1, 8);\n    if (octalDigits.indexOf(state.nextCodePoint()) === -1) {\n      return { matched: true, value: octal1Value };\n    }\n    let octal2 = state.eatAny(...octalDigits);\n    let octal2Value = parseInt(octal2, 8);\n    if (octal1Value < 4) {\n      if (octalDigits.indexOf(state.nextCodePoint()) === -1) {\n        return { matched: true, value: octal1Value << 3 | octal2Value };\n      }\n      let octal3 = state.eatAny(...octalDigits);\n      let octal3Value = parseInt(octal3, 8);\n      return { matched: true, value: octal1Value << 6 | octal2Value << 3 | octal3Value };\n    }\n    return { matched: true, value: octal1Value << 3 | octal2Value };\n  }),\n  backtrackOnFailure(state => {\n    if (!state.unicode) {\n      return { matched: false };\n    }\n    let value = state.eatAny(...syntaxCharacters);\n    if (value === null) {\n      return { matched: false };\n    }\n    return { matched: true, value: value.charCodeAt(0) };\n  }),\n  state => {\n    if (!state.unicode || !state.eat('/')) {\n      return { matched: false };\n    }\n    return { matched: true, value: '/'.charCodeAt(0) };\n  },\n  backtrackOnFailure(state => {\n    if (state.unicode) {\n      return { matched: false };\n    }\n    let next = state.nextCodePoint();\n    if (next !== null && next !== 'c' && next !== 'k') {\n      state.skipCodePoint();\n      return { matched: true, value: next.codePointAt(0) };\n    }\n    return { matched: false };\n  })\n);\n\nconst acceptGroupNameBackreference = backtrackOnFailure(state => {\n  if (!state.eat('k')) {\n    return { matched: false };\n  }\n  let name = acceptGroupName(state);\n  if (!name.matched) {\n    state.backreferenceNames.push(INVALID_NAMED_BACKREFERENCE_SENTINEL);\n    return { matched: true };\n  }\n  state.backreferenceNames.push(name.data);\n  return { matched: true };\n});\n\nconst acceptGroupName = backtrackOnFailure(state => {\n  if (!state.eat('<')) {\n    return { matched: false };\n  }\n  let characters = [];\n  let start = state.eatIdentifierStart();\n  if (!start) {\n    return { matched: false };\n  }\n  characters.push(start);\n  let part;\n  while (part = state.eatIdentifierPart()) { // eslint-disable-line no-cond-assign\n    characters.push(part);\n  }\n  if (!state.eat('>')) {\n    return { matched: false };\n  }\n  return { matched: characters.length > 0, data: characters.join('') };\n});\n\nconst acceptAtomEscape = anyOf(\n  acceptDecimalEscape,\n  acceptCharacterClassEscape,\n  acceptCharacterEscape,\n  acceptGroupNameBackreference\n);\n\nconst acceptCharacterClass = backtrackOnFailure(state => {\n  if (!state.eat('[')) {\n    return { matched: false };\n  }\n  state.eat('^');\n\n  const acceptClassEscape = anyOf(\n    subState => {\n      return { matched: !!subState.eat('b'), value: 0x0008 };\n    },\n    subState => {\n      return { matched: subState.unicode && !!subState.eat('-'), value: '-'.charCodeAt(0) };\n    },\n    backtrackOnFailure(subState => {\n      if (subState.unicode || !subState.eat('c')) {\n        return { matched: false };\n      }\n      let character = subState.eatAny(...decimalDigits, '_');\n      if (character === null) {\n        return { matched: false };\n      }\n      return { matched: true, value: character.charCodeAt(0) % 32 };\n    }),\n    acceptCharacterClassEscape,\n    acceptCharacterEscape,\n    // We special-case `\\k` because `acceptCharacterEscape` rejects `\\k` unconditionally,\n    // deferring `\\k` to acceptGroupNameBackreference, which is not called here.\n    // See also https://github.com/tc39/ecma262/issues/2037. This code takes the route of\n    // making it unconditionally legal, rather than legal only in the absence of a group name.\n    subState => {\n      return { matched: !subState.unicode && !!subState.eat('k'), value: 107 };\n    }\n  );\n\n  const acceptClassAtomNoDash = localState => {\n    let nextCodePoint = localState.nextCodePoint();\n    if (nextCodePoint === ']' || nextCodePoint === '-' || nextCodePoint === null) {\n      return { matched: false };\n    }\n    if (nextCodePoint !== '\\\\') {\n      localState.skipCodePoint();\n      return { matched: true, value: nextCodePoint.codePointAt(0) };\n    }\n    localState.eat('\\\\');\n    let classEscape = acceptClassEscape(localState);\n    if (!classEscape.matched && localState.nextCodePoint() === 'c' && !localState.unicode) {\n      return { matched: true, value: '\\\\'.charCodeAt(0) };\n    }\n    return classEscape;\n  };\n\n  const acceptClassAtom = localState => {\n    if (localState.eat('-')) {\n      return { matched: true, value: '-'.charCodeAt(0) };\n    }\n    return acceptClassAtomNoDash(localState);\n  };\n\n  const finishClassRange = (localState, atom) => {\n    const isUnvaluedPassedAtom = subAtom => {\n      return subAtom.value === void 0 && subAtom.matched;\n    };\n    if (localState.eat('-')) {\n      if (localState.match(']')) {\n        return { matched: true };\n      }\n      let otherAtom = acceptClassAtom(localState);\n      if (!otherAtom.matched) {\n        return { matched: false };\n      }\n      if (localState.unicode && (isUnvaluedPassedAtom(atom) || isUnvaluedPassedAtom(otherAtom))) {\n        return { matched: false };\n      } else if (!(!localState.unicode && (isUnvaluedPassedAtom(atom) || isUnvaluedPassedAtom(otherAtom))) && atom.value > otherAtom.value) {\n        return { matched: false };\n      } else if (localState.match(']')) {\n        return { matched: true };\n      }\n      return acceptNonEmptyClassRanges(localState);\n\n    }\n    if (localState.match(']')) {\n      return { matched: true };\n    }\n    return acceptNonEmptyClassRangesNoDash(localState);\n  };\n\n  const acceptNonEmptyClassRanges = localState => {\n    let atom = acceptClassAtom(localState);\n    return atom.matched ? finishClassRange(localState, atom) : { matched: false };\n  };\n\n  const acceptNonEmptyClassRangesNoDash = localState => {\n    let atom = acceptClassAtomNoDash(localState);\n    return atom.matched ? finishClassRange(localState, atom) : { matched: false };\n  };\n\n  if (state.eat(']')) {\n    return { matched: true };\n  }\n\n  let value = acceptNonEmptyClassRanges(state);\n  if (value.matched) {\n    state.eat(']'); // cannot fail, as above will not return matched if it is not seen in advance\n  }\n\n  return value;\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}