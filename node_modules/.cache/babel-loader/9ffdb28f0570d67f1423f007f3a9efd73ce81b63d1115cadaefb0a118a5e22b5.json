{"ast":null,"code":"/**\n * Copyright 2014 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {\n  ErrorMessages\n} = require('./errors');\nconst acceptRegex = require('shift-regexp-acceptor');\nconst {\n  Tokenizer,\n  TokenClass,\n  TokenType\n} = require('./tokenizer');\nconst AST = require('shift-ast');\n\n// Empty parameter list for ArrowExpression\nconst ARROW_EXPRESSION_PARAMS = 'CoverParenthesizedExpressionAndArrowParameterList';\nconst EXPORT_UNKNOWN_SPECIFIER = 'ExportNameOfUnknownType';\nconst Precedence = {\n  Sequence: 0,\n  Yield: 1,\n  Assignment: 1,\n  Conditional: 2,\n  ArrowFunction: 2,\n  LogicalOR: 3,\n  LogicalAND: 4,\n  BitwiseOR: 5,\n  BitwiseXOR: 6,\n  BitwiseAND: 7,\n  Equality: 8,\n  Relational: 9,\n  BitwiseSHIFT: 10,\n  Additive: 11,\n  Multiplicative: 12,\n  Unary: 13,\n  Postfix: 14,\n  Call: 15,\n  New: 16,\n  TaggedTemplate: 17,\n  Member: 18,\n  Primary: 19\n};\nconst BinaryPrecedence = {\n  '||': Precedence.LogicalOR,\n  '&&': Precedence.LogicalAND,\n  '|': Precedence.BitwiseOR,\n  '^': Precedence.BitwiseXOR,\n  '&': Precedence.BitwiseAND,\n  '==': Precedence.Equality,\n  '!=': Precedence.Equality,\n  '===': Precedence.Equality,\n  '!==': Precedence.Equality,\n  '<': Precedence.Relational,\n  '>': Precedence.Relational,\n  '<=': Precedence.Relational,\n  '>=': Precedence.Relational,\n  'in': Precedence.Relational,\n  'instanceof': Precedence.Relational,\n  '<<': Precedence.BitwiseSHIFT,\n  '>>': Precedence.BitwiseSHIFT,\n  '>>>': Precedence.BitwiseSHIFT,\n  '+': Precedence.Additive,\n  '-': Precedence.Additive,\n  '*': Precedence.Multiplicative,\n  '%': Precedence.Multiplicative,\n  '/': Precedence.Multiplicative\n};\nfunction isValidSimpleAssignmentTarget(node) {\n  if (node == null) return false;\n  switch (node.type) {\n    case 'IdentifierExpression':\n    case 'ComputedMemberExpression':\n    case 'StaticMemberExpression':\n      return true;\n  }\n  return false;\n}\nfunction isPrefixOperator(token) {\n  switch (token.type) {\n    case TokenType.INC:\n    case TokenType.DEC:\n    case TokenType.ADD:\n    case TokenType.SUB:\n    case TokenType.BIT_NOT:\n    case TokenType.NOT:\n    case TokenType.DELETE:\n    case TokenType.VOID:\n    case TokenType.TYPEOF:\n      return true;\n  }\n  return false;\n}\nfunction isUpdateOperator(token) {\n  return token.type === TokenType.INC || token.type === TokenType.DEC;\n}\nclass GenericParser extends Tokenizer {\n  constructor(source) {\n    super(source);\n    this.allowIn = true;\n    this.inFunctionBody = false;\n    this.inParameter = false;\n    this.allowYieldExpression = false;\n    this.allowAwaitExpression = false;\n    this.firstAwaitLocation = null; // for forbidding `await` in async arrow params.\n    this.module = false;\n    this.moduleIsTheGoalSymbol = false;\n    this.strict = false;\n\n    // Cover grammar\n    this.isBindingElement = true;\n    this.isAssignmentTarget = true;\n    this.firstExprError = null;\n  }\n  match(subType) {\n    return this.lookahead.type === subType;\n  }\n  matchIdentifier() {\n    switch (this.lookahead.type) {\n      case TokenType.IDENTIFIER:\n      case TokenType.LET:\n      case TokenType.YIELD:\n      case TokenType.ASYNC:\n        return true;\n      case TokenType.AWAIT:\n        if (!this.moduleIsTheGoalSymbol) {\n          if (this.firstAwaitLocation === null) {\n            this.firstAwaitLocation = this.getLocation();\n          }\n          return true;\n        }\n        return false;\n      case TokenType.ESCAPED_KEYWORD:\n        if (this.lookahead.value === 'await' && !this.moduleIsTheGoalSymbol) {\n          if (this.firstAwaitLocation === null) {\n            this.firstAwaitLocation = this.getLocation();\n          }\n          return true;\n        }\n        return this.lookahead.value === 'let' || this.lookahead.value === 'yield' || this.lookahead.value === 'async';\n    }\n    return false;\n  }\n  eat(tokenType) {\n    if (this.lookahead.type === tokenType) {\n      return this.lex();\n    }\n    return null;\n  }\n  expect(tokenType) {\n    if (this.lookahead.type === tokenType) {\n      return this.lex();\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n  matchContextualKeyword(keyword) {\n    return this.lookahead.type === TokenType.IDENTIFIER && !this.lookahead.escaped && this.lookahead.value === keyword;\n  }\n  expectContextualKeyword(keyword) {\n    if (this.lookahead.type === TokenType.IDENTIFIER && !this.lookahead.escaped && this.lookahead.value === keyword) {\n      return this.lex();\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n  eatContextualKeyword(keyword) {\n    if (this.lookahead.type === TokenType.IDENTIFIER && !this.lookahead.escaped && this.lookahead.value === keyword) {\n      return this.lex();\n    }\n    return null;\n  }\n  consumeSemicolon() {\n    if (this.eat(TokenType.SEMICOLON)) return;\n    if (this.hasLineTerminatorBeforeNext) return;\n    if (!this.eof() && !this.match(TokenType.RBRACE)) {\n      throw this.createUnexpected(this.lookahead);\n    }\n  }\n\n  // this is a no-op, reserved for future use\n  startNode(node) {\n    return node;\n  }\n  copyNode(src, dest) {\n    return dest;\n  }\n  finishNode(node /* , startState */) {\n    return node;\n  }\n  parseModule() {\n    this.moduleIsTheGoalSymbol = this.module = this.strict = true;\n    this.lookahead = this.advance();\n    let startState = this.startNode();\n    let {\n      directives,\n      statements\n    } = this.parseBody();\n    if (!this.match(TokenType.EOS)) {\n      throw this.createUnexpected(this.lookahead);\n    }\n    return this.finishNode(new AST.Module({\n      directives,\n      items: statements\n    }), startState);\n  }\n  parseScript() {\n    this.lookahead = this.advance();\n    let startState = this.startNode();\n    let {\n      directives,\n      statements\n    } = this.parseBody();\n    if (!this.match(TokenType.EOS)) {\n      throw this.createUnexpected(this.lookahead);\n    }\n    return this.finishNode(new AST.Script({\n      directives,\n      statements\n    }), startState);\n  }\n  parseFunctionBody() {\n    let oldInFunctionBody = this.inFunctionBody;\n    let oldModule = this.module;\n    let oldStrict = this.strict;\n    this.inFunctionBody = true;\n    this.module = false;\n    let startState = this.startNode();\n    this.expect(TokenType.LBRACE);\n    let body = new AST.FunctionBody(this.parseBody());\n    this.expect(TokenType.RBRACE);\n    body = this.finishNode(body, startState);\n    this.inFunctionBody = oldInFunctionBody;\n    this.module = oldModule;\n    this.strict = oldStrict;\n    return body;\n  }\n  parseBody() {\n    let directives = [],\n      statements = [],\n      parsingDirectives = true,\n      directiveOctal = null;\n    while (true) {\n      if (this.eof() || this.match(TokenType.RBRACE)) break;\n      let token = this.lookahead;\n      let text = token.slice.text;\n      let isStringLiteral = token.type === TokenType.STRING;\n      let isModule = this.module;\n      let directiveLocation = this.getLocation();\n      let directiveStartState = this.startNode();\n      let stmt = isModule ? this.parseModuleItem() : this.parseStatementListItem();\n      if (parsingDirectives) {\n        if (isStringLiteral && stmt.type === 'ExpressionStatement' && stmt.expression.type === 'LiteralStringExpression') {\n          if (!directiveOctal && token.octal) {\n            directiveOctal = this.createErrorWithLocation(directiveLocation, 'Unexpected legacy octal escape sequence: \\\\' + token.octal);\n          }\n          let rawValue = text.slice(1, -1);\n          if (rawValue === 'use strict') {\n            this.strict = true;\n          }\n          directives.push(this.finishNode(new AST.Directive({\n            rawValue\n          }), directiveStartState));\n        } else {\n          parsingDirectives = false;\n          if (directiveOctal && this.strict) {\n            throw directiveOctal;\n          }\n          statements.push(stmt);\n        }\n      } else {\n        statements.push(stmt);\n      }\n    }\n    if (directiveOctal && this.strict) {\n      throw directiveOctal;\n    }\n    return {\n      directives,\n      statements\n    };\n  }\n  parseImportSpecifier() {\n    let startState = this.startNode(),\n      name;\n    if (this.matchIdentifier()) {\n      name = this.parseIdentifier();\n      if (!this.eatContextualKeyword('as')) {\n        return this.finishNode(new AST.ImportSpecifier({\n          name: null,\n          binding: this.finishNode(new AST.BindingIdentifier({\n            name\n          }), startState)\n        }), startState);\n      }\n    } else if (this.lookahead.type.klass.isIdentifierName) {\n      name = this.parseIdentifierName();\n      this.expectContextualKeyword('as');\n    }\n    return this.finishNode(new AST.ImportSpecifier({\n      name,\n      binding: this.parseBindingIdentifier()\n    }), startState);\n  }\n  parseNameSpaceBinding() {\n    this.expect(TokenType.MUL);\n    this.expectContextualKeyword('as');\n    return this.parseBindingIdentifier();\n  }\n  parseNamedImports() {\n    let result = [];\n    this.expect(TokenType.LBRACE);\n    while (!this.eat(TokenType.RBRACE)) {\n      result.push(this.parseImportSpecifier());\n      if (!this.eat(TokenType.COMMA)) {\n        this.expect(TokenType.RBRACE);\n        break;\n      }\n    }\n    return result;\n  }\n  parseFromClause() {\n    this.expectContextualKeyword('from');\n    let value = this.expect(TokenType.STRING).str;\n    return value;\n  }\n  parseImportDeclaration() {\n    let startState = this.startNode(),\n      defaultBinding = null,\n      moduleSpecifier;\n    this.expect(TokenType.IMPORT);\n    if (this.match(TokenType.STRING)) {\n      moduleSpecifier = this.lex().str;\n      this.consumeSemicolon();\n      return this.finishNode(new AST.Import({\n        defaultBinding: null,\n        namedImports: [],\n        moduleSpecifier\n      }), startState);\n    }\n    if (this.matchIdentifier()) {\n      defaultBinding = this.parseBindingIdentifier();\n      if (!this.eat(TokenType.COMMA)) {\n        let decl = new AST.Import({\n          defaultBinding,\n          namedImports: [],\n          moduleSpecifier: this.parseFromClause()\n        });\n        this.consumeSemicolon();\n        return this.finishNode(decl, startState);\n      }\n    }\n    if (this.match(TokenType.MUL)) {\n      let decl = new AST.ImportNamespace({\n        defaultBinding,\n        namespaceBinding: this.parseNameSpaceBinding(),\n        moduleSpecifier: this.parseFromClause()\n      });\n      this.consumeSemicolon();\n      return this.finishNode(decl, startState);\n    } else if (this.match(TokenType.LBRACE)) {\n      let decl = new AST.Import({\n        defaultBinding,\n        namedImports: this.parseNamedImports(),\n        moduleSpecifier: this.parseFromClause()\n      });\n      this.consumeSemicolon();\n      return this.finishNode(decl, startState);\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n  parseExportSpecifier() {\n    let startState = this.startNode();\n    let name = this.finishNode({\n      type: EXPORT_UNKNOWN_SPECIFIER,\n      isIdentifier: this.matchIdentifier(),\n      value: this.parseIdentifierName()\n    }, startState);\n    if (this.eatContextualKeyword('as')) {\n      let exportedName = this.parseIdentifierName();\n      return this.finishNode({\n        name,\n        exportedName\n      }, startState);\n    }\n    return this.finishNode({\n      name,\n      exportedName: null\n    }, startState);\n  }\n  parseExportClause() {\n    this.expect(TokenType.LBRACE);\n    let result = [];\n    while (!this.eat(TokenType.RBRACE)) {\n      result.push(this.parseExportSpecifier());\n      if (!this.eat(TokenType.COMMA)) {\n        this.expect(TokenType.RBRACE);\n        break;\n      }\n    }\n    return result;\n  }\n  parseExportDeclaration() {\n    let startState = this.startNode(),\n      decl;\n    this.expect(TokenType.EXPORT);\n    switch (this.lookahead.type) {\n      case TokenType.MUL:\n        this.lex();\n        // export * FromClause ;\n        decl = new AST.ExportAllFrom({\n          moduleSpecifier: this.parseFromClause()\n        });\n        this.consumeSemicolon();\n        break;\n      case TokenType.LBRACE:\n        {\n          // export ExportClause FromClause ;\n          // export ExportClause ;\n          let namedExports = this.parseExportClause();\n          let moduleSpecifier = null;\n          if (this.matchContextualKeyword('from')) {\n            moduleSpecifier = this.parseFromClause();\n            decl = new AST.ExportFrom({\n              namedExports: namedExports.map(e => this.copyNode(e, new AST.ExportFromSpecifier({\n                name: e.name.value,\n                exportedName: e.exportedName\n              }))),\n              moduleSpecifier\n            });\n          } else {\n            namedExports.forEach(({\n              name\n            }) => {\n              if (!name.isIdentifier) {\n                throw this.createError(ErrorMessages.ILLEGAL_EXPORTED_NAME);\n              }\n            });\n            decl = new AST.ExportLocals({\n              namedExports: namedExports.map(e => this.copyNode(e, new AST.ExportLocalSpecifier({\n                name: this.copyNode(e.name, new AST.IdentifierExpression({\n                  name: e.name.value\n                })),\n                exportedName: e.exportedName\n              })))\n            });\n          }\n          this.consumeSemicolon();\n          break;\n        }\n      case TokenType.CLASS:\n        // export ClassDeclaration\n        decl = new AST.Export({\n          declaration: this.parseClass({\n            isExpr: false,\n            inDefault: false\n          })\n        });\n        break;\n      case TokenType.FUNCTION:\n        // export HoistableDeclaration\n        decl = new AST.Export({\n          declaration: this.parseFunction({\n            isExpr: false,\n            inDefault: false,\n            allowGenerator: true,\n            isAsync: false\n          })\n        });\n        break;\n      case TokenType.ASYNC:\n        {\n          let preAsyncStartState = this.startNode();\n          this.lex();\n          decl = new AST.Export({\n            declaration: this.parseFunction({\n              isExpr: false,\n              inDefault: false,\n              allowGenerator: true,\n              isAsync: true,\n              startState: preAsyncStartState\n            })\n          });\n          break;\n        }\n      case TokenType.DEFAULT:\n        this.lex();\n        switch (this.lookahead.type) {\n          case TokenType.FUNCTION:\n            // export default HoistableDeclaration[Default]\n            decl = new AST.ExportDefault({\n              body: this.parseFunction({\n                isExpr: false,\n                inDefault: true,\n                allowGenerator: true,\n                isAsync: false\n              })\n            });\n            break;\n          case TokenType.CLASS:\n            // export default ClassDeclaration[Default]\n            decl = new AST.ExportDefault({\n              body: this.parseClass({\n                isExpr: false,\n                inDefault: true\n              })\n            });\n            break;\n          case TokenType.ASYNC:\n            {\n              let preAsyncStartState = this.startNode();\n              let lexerState = this.saveLexerState();\n              this.lex();\n              if (!this.hasLineTerminatorBeforeNext && this.match(TokenType.FUNCTION)) {\n                decl = new AST.ExportDefault({\n                  body: this.parseFunction({\n                    isExpr: false,\n                    inDefault: true,\n                    allowGenerator: false,\n                    isAsync: true,\n                    startState: preAsyncStartState\n                  })\n                });\n                break;\n              }\n              this.restoreLexerState(lexerState);\n            }\n          // else fall through\n          default:\n            // export default [lookahead ∉ {function, async [no LineTerminatorHere] function, class}] AssignmentExpression[In] ;\n            decl = new AST.ExportDefault({\n              body: this.parseAssignmentExpression()\n            });\n            this.consumeSemicolon();\n            break;\n        }\n        break;\n      case TokenType.VAR:\n      case TokenType.LET:\n      case TokenType.CONST:\n        // export LexicalDeclaration\n        decl = new AST.Export({\n          declaration: this.parseVariableDeclaration(true)\n        });\n        this.consumeSemicolon();\n        break;\n      default:\n        throw this.createUnexpected(this.lookahead);\n    }\n    return this.finishNode(decl, startState);\n  }\n  parseModuleItem() {\n    switch (this.lookahead.type) {\n      case TokenType.IMPORT:\n        return this.parseImportDeclaration();\n      case TokenType.EXPORT:\n        return this.parseExportDeclaration();\n      default:\n        return this.parseStatementListItem();\n    }\n  }\n  lookaheadLexicalDeclaration() {\n    if (this.match(TokenType.LET) || this.match(TokenType.CONST)) {\n      let lexerState = this.saveLexerState();\n      this.lex();\n      if (this.matchIdentifier() || this.match(TokenType.LBRACE) || this.match(TokenType.LBRACK)) {\n        this.restoreLexerState(lexerState);\n        return true;\n      }\n      this.restoreLexerState(lexerState);\n    }\n    return false;\n  }\n  parseStatementListItem() {\n    if (this.eof()) throw this.createUnexpected(this.lookahead);\n    switch (this.lookahead.type) {\n      case TokenType.FUNCTION:\n        return this.parseFunction({\n          isExpr: false,\n          inDefault: false,\n          allowGenerator: true,\n          isAsync: false\n        });\n      case TokenType.CLASS:\n        return this.parseClass({\n          isExpr: false,\n          inDefault: false\n        });\n      case TokenType.ASYNC:\n        {\n          let preAsyncStartState = this.getLocation();\n          let lexerState = this.saveLexerState();\n          this.lex();\n          if (!this.hasLineTerminatorBeforeNext && this.match(TokenType.FUNCTION)) {\n            return this.parseFunction({\n              isExpr: false,\n              inDefault: false,\n              allowGenerator: true,\n              isAsync: true,\n              startState: preAsyncStartState\n            });\n          }\n          this.restoreLexerState(lexerState);\n          return this.parseStatement();\n        }\n      default:\n        if (this.lookaheadLexicalDeclaration()) {\n          let startState = this.startNode();\n          return this.finishNode(this.parseVariableDeclarationStatement(), startState);\n        }\n        return this.parseStatement();\n    }\n  }\n  parseStatement() {\n    let startState = this.startNode();\n    let stmt = this.isolateCoverGrammar(this.parseStatementHelper);\n    return this.finishNode(stmt, startState);\n  }\n  parseStatementHelper() {\n    if (this.eof()) {\n      throw this.createUnexpected(this.lookahead);\n    }\n    switch (this.lookahead.type) {\n      case TokenType.SEMICOLON:\n        return this.parseEmptyStatement();\n      case TokenType.LBRACE:\n        return this.parseBlockStatement();\n      case TokenType.LPAREN:\n        return this.parseExpressionStatement();\n      case TokenType.BREAK:\n        return this.parseBreakStatement();\n      case TokenType.CONTINUE:\n        return this.parseContinueStatement();\n      case TokenType.DEBUGGER:\n        return this.parseDebuggerStatement();\n      case TokenType.DO:\n        return this.parseDoWhileStatement();\n      case TokenType.FOR:\n        return this.parseForStatement();\n      case TokenType.IF:\n        return this.parseIfStatement();\n      case TokenType.RETURN:\n        return this.parseReturnStatement();\n      case TokenType.SWITCH:\n        return this.parseSwitchStatement();\n      case TokenType.THROW:\n        return this.parseThrowStatement();\n      case TokenType.TRY:\n        return this.parseTryStatement();\n      case TokenType.VAR:\n        return this.parseVariableDeclarationStatement();\n      case TokenType.WHILE:\n        return this.parseWhileStatement();\n      case TokenType.WITH:\n        return this.parseWithStatement();\n      case TokenType.FUNCTION:\n      case TokenType.CLASS:\n        throw this.createUnexpected(this.lookahead);\n      default:\n        {\n          let lexerState = this.saveLexerState();\n          if (this.eat(TokenType.LET)) {\n            if (this.match(TokenType.LBRACK)) {\n              this.restoreLexerState(lexerState);\n              throw this.createUnexpected(this.lookahead);\n            }\n            this.restoreLexerState(lexerState);\n          } else if (this.eat(TokenType.ASYNC)) {\n            if (!this.hasLineTerminatorBeforeNext && this.match(TokenType.FUNCTION)) {\n              throw this.createUnexpected(this.lookahead);\n            }\n            this.restoreLexerState(lexerState);\n          }\n          let expr = this.parseExpression();\n          // 12.12 Labelled Statements;\n          if (expr.type === 'IdentifierExpression' && this.eat(TokenType.COLON)) {\n            let labeledBody = this.match(TokenType.FUNCTION) ? this.parseFunction({\n              isExpr: false,\n              inDefault: false,\n              allowGenerator: false,\n              isAsync: false\n            }) : this.parseStatement();\n            return new AST.LabeledStatement({\n              label: expr.name,\n              body: labeledBody\n            });\n          }\n          this.consumeSemicolon();\n          return new AST.ExpressionStatement({\n            expression: expr\n          });\n        }\n    }\n  }\n  parseEmptyStatement() {\n    this.lex();\n    return new AST.EmptyStatement();\n  }\n  parseBlockStatement() {\n    return new AST.BlockStatement({\n      block: this.parseBlock()\n    });\n  }\n  parseExpressionStatement() {\n    let expr = this.parseExpression();\n    this.consumeSemicolon();\n    return new AST.ExpressionStatement({\n      expression: expr\n    });\n  }\n  parseBreakStatement() {\n    this.lex();\n\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (this.eat(TokenType.SEMICOLON) || this.hasLineTerminatorBeforeNext) {\n      return new AST.BreakStatement({\n        label: null\n      });\n    }\n    let label = null;\n    if (this.matchIdentifier()) {\n      label = this.parseIdentifier();\n    }\n    this.consumeSemicolon();\n    return new AST.BreakStatement({\n      label\n    });\n  }\n  parseContinueStatement() {\n    this.lex();\n\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (this.eat(TokenType.SEMICOLON) || this.hasLineTerminatorBeforeNext) {\n      return new AST.ContinueStatement({\n        label: null\n      });\n    }\n    let label = null;\n    if (this.matchIdentifier()) {\n      label = this.parseIdentifier();\n    }\n    this.consumeSemicolon();\n    return new AST.ContinueStatement({\n      label\n    });\n  }\n  parseDebuggerStatement() {\n    this.lex();\n    this.consumeSemicolon();\n    return new AST.DebuggerStatement();\n  }\n  parseDoWhileStatement() {\n    this.lex();\n    let body = this.parseStatement();\n    this.expect(TokenType.WHILE);\n    this.expect(TokenType.LPAREN);\n    let test = this.parseExpression();\n    this.expect(TokenType.RPAREN);\n    this.eat(TokenType.SEMICOLON);\n    return new AST.DoWhileStatement({\n      body,\n      test\n    });\n  }\n  parseForStatement() {\n    this.lex();\n    let isAwait = this.allowAwaitExpression && this.eat(TokenType.AWAIT);\n    this.expect(TokenType.LPAREN);\n    let test = null;\n    let right = null;\n    if (isAwait && this.match(TokenType.SEMICOLON)) {\n      throw this.createUnexpected(this.lookahead);\n    }\n    if (this.eat(TokenType.SEMICOLON)) {\n      if (!this.match(TokenType.SEMICOLON)) {\n        test = this.parseExpression();\n      }\n      this.expect(TokenType.SEMICOLON);\n      if (!this.match(TokenType.RPAREN)) {\n        right = this.parseExpression();\n      }\n      return new AST.ForStatement({\n        init: null,\n        test,\n        update: right,\n        body: this.getIteratorStatementEpilogue()\n      });\n    }\n    let startsWithLet = this.match(TokenType.LET);\n    let isForDecl = this.lookaheadLexicalDeclaration();\n    let leftStartState = this.startNode();\n    if (this.match(TokenType.VAR) || isForDecl) {\n      let previousAllowIn = this.allowIn;\n      this.allowIn = false;\n      let init = this.parseVariableDeclaration(false);\n      this.allowIn = previousAllowIn;\n      if (init.declarators.length === 1 && (this.match(TokenType.IN) || this.matchContextualKeyword('of'))) {\n        let ctor;\n        let decl = init.declarators[0];\n        if (this.match(TokenType.IN)) {\n          if (isAwait) {\n            throw this.createUnexpected(this.lookahead);\n          }\n          if (decl.init !== null && (this.strict || init.kind !== 'var' || decl.binding.type !== 'BindingIdentifier')) {\n            throw this.createError(ErrorMessages.INVALID_VAR_INIT_FOR_IN);\n          }\n          ctor = AST.ForInStatement;\n          this.lex();\n          right = this.parseExpression();\n        } else {\n          if (decl.init !== null) {\n            throw this.createError(isAwait ? ErrorMessages.INVALID_VAR_INIT_FOR_AWAIT : ErrorMessages.INVALID_VAR_INIT_FOR_OF);\n          }\n          if (isAwait) {\n            ctor = AST.ForAwaitStatement;\n          } else {\n            ctor = AST.ForOfStatement;\n          }\n          this.lex();\n          right = this.parseAssignmentExpression();\n        }\n        let body = this.getIteratorStatementEpilogue();\n        return new ctor({\n          left: init,\n          right,\n          body\n        });\n      } else if (isAwait) {\n        throw this.createUnexpected(this.lookahead);\n      }\n      this.expect(TokenType.SEMICOLON);\n      if (init.declarators.some(decl => decl.binding.type !== 'BindingIdentifier' && decl.init === null)) {\n        throw this.createError(ErrorMessages.UNINITIALIZED_BINDINGPATTERN_IN_FOR_INIT);\n      }\n      if (!this.match(TokenType.SEMICOLON)) {\n        test = this.parseExpression();\n      }\n      this.expect(TokenType.SEMICOLON);\n      if (!this.match(TokenType.RPAREN)) {\n        right = this.parseExpression();\n      }\n      return new AST.ForStatement({\n        init,\n        test,\n        update: right,\n        body: this.getIteratorStatementEpilogue()\n      });\n    }\n    let previousAllowIn = this.allowIn;\n    this.allowIn = false;\n    let expr = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n    this.allowIn = previousAllowIn;\n    if (this.isAssignmentTarget && expr.type !== 'AssignmentExpression' && (this.match(TokenType.IN) || this.matchContextualKeyword('of'))) {\n      if (expr.type === 'ObjectAssignmentTarget' || expr.type === 'ArrayAssignmentTarget') {\n        this.firstExprError = null;\n      }\n      if (startsWithLet && this.matchContextualKeyword('of')) {\n        throw this.createError(isAwait ? ErrorMessages.INVALID_LHS_IN_FOR_AWAIT : ErrorMessages.INVALID_LHS_IN_FOR_OF);\n      }\n      let ctor;\n      if (this.match(TokenType.IN)) {\n        if (isAwait) {\n          throw this.createUnexpected(this.lookahead);\n        }\n        ctor = AST.ForInStatement;\n        this.lex();\n        right = this.parseExpression();\n      } else {\n        if (isAwait) {\n          ctor = AST.ForAwaitStatement;\n        } else {\n          ctor = AST.ForOfStatement;\n        }\n        this.lex();\n        right = this.parseAssignmentExpression();\n      }\n      return new ctor({\n        left: this.transformDestructuring(expr),\n        right,\n        body: this.getIteratorStatementEpilogue()\n      });\n    } else if (isAwait) {\n      throw this.createError(ErrorMessages.INVALID_LHS_IN_FOR_AWAIT);\n    }\n    if (this.firstExprError) {\n      throw this.firstExprError;\n    }\n    while (this.eat(TokenType.COMMA)) {\n      let rhs = this.parseAssignmentExpression();\n      expr = this.finishNode(new AST.BinaryExpression({\n        left: expr,\n        operator: ',',\n        right: rhs\n      }), leftStartState);\n    }\n    if (this.match(TokenType.IN)) {\n      throw this.createError(ErrorMessages.INVALID_LHS_IN_FOR_IN);\n    }\n    if (this.matchContextualKeyword('of')) {\n      throw this.createError(ErrorMessages.INVALID_LHS_IN_FOR_OF);\n    }\n    this.expect(TokenType.SEMICOLON);\n    if (!this.match(TokenType.SEMICOLON)) {\n      test = this.parseExpression();\n    }\n    this.expect(TokenType.SEMICOLON);\n    if (!this.match(TokenType.RPAREN)) {\n      right = this.parseExpression();\n    }\n    return new AST.ForStatement({\n      init: expr,\n      test,\n      update: right,\n      body: this.getIteratorStatementEpilogue()\n    });\n  }\n  getIteratorStatementEpilogue() {\n    this.expect(TokenType.RPAREN);\n    let body = this.parseStatement();\n    return body;\n  }\n  parseIfStatementChild() {\n    return this.match(TokenType.FUNCTION) ? this.parseFunction({\n      isExpr: false,\n      inDefault: false,\n      allowGenerator: false,\n      isAsync: false\n    }) : this.parseStatement();\n  }\n  parseIfStatement() {\n    this.lex();\n    this.expect(TokenType.LPAREN);\n    let test = this.parseExpression();\n    this.expect(TokenType.RPAREN);\n    let consequent = this.parseIfStatementChild();\n    let alternate = null;\n    if (this.eat(TokenType.ELSE)) {\n      alternate = this.parseIfStatementChild();\n    }\n    return new AST.IfStatement({\n      test,\n      consequent,\n      alternate\n    });\n  }\n  parseReturnStatement() {\n    if (!this.inFunctionBody) {\n      throw this.createError(ErrorMessages.ILLEGAL_RETURN);\n    }\n    this.lex();\n\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (this.eat(TokenType.SEMICOLON) || this.hasLineTerminatorBeforeNext) {\n      return new AST.ReturnStatement({\n        expression: null\n      });\n    }\n    let expression = null;\n    if (!this.match(TokenType.RBRACE) && !this.eof()) {\n      expression = this.parseExpression();\n    }\n    this.consumeSemicolon();\n    return new AST.ReturnStatement({\n      expression\n    });\n  }\n  parseSwitchStatement() {\n    this.lex();\n    this.expect(TokenType.LPAREN);\n    let discriminant = this.parseExpression();\n    this.expect(TokenType.RPAREN);\n    this.expect(TokenType.LBRACE);\n    if (this.eat(TokenType.RBRACE)) {\n      return new AST.SwitchStatement({\n        discriminant,\n        cases: []\n      });\n    }\n    let cases = this.parseSwitchCases();\n    if (this.match(TokenType.DEFAULT)) {\n      let defaultCase = this.parseSwitchDefault();\n      let postDefaultCases = this.parseSwitchCases();\n      if (this.match(TokenType.DEFAULT)) {\n        throw this.createError(ErrorMessages.MULTIPLE_DEFAULTS_IN_SWITCH);\n      }\n      this.expect(TokenType.RBRACE);\n      return new AST.SwitchStatementWithDefault({\n        discriminant,\n        preDefaultCases: cases,\n        defaultCase,\n        postDefaultCases\n      });\n    }\n    this.expect(TokenType.RBRACE);\n    return new AST.SwitchStatement({\n      discriminant,\n      cases\n    });\n  }\n  parseSwitchCases() {\n    let result = [];\n    while (!(this.eof() || this.match(TokenType.RBRACE) || this.match(TokenType.DEFAULT))) {\n      result.push(this.parseSwitchCase());\n    }\n    return result;\n  }\n  parseSwitchCase() {\n    let startState = this.startNode();\n    this.expect(TokenType.CASE);\n    return this.finishNode(new AST.SwitchCase({\n      test: this.parseExpression(),\n      consequent: this.parseSwitchCaseBody()\n    }), startState);\n  }\n  parseSwitchDefault() {\n    let startState = this.startNode();\n    this.expect(TokenType.DEFAULT);\n    return this.finishNode(new AST.SwitchDefault({\n      consequent: this.parseSwitchCaseBody()\n    }), startState);\n  }\n  parseSwitchCaseBody() {\n    this.expect(TokenType.COLON);\n    return this.parseStatementListInSwitchCaseBody();\n  }\n  parseStatementListInSwitchCaseBody() {\n    let result = [];\n    while (!(this.eof() || this.match(TokenType.RBRACE) || this.match(TokenType.DEFAULT) || this.match(TokenType.CASE))) {\n      result.push(this.parseStatementListItem());\n    }\n    return result;\n  }\n  parseThrowStatement() {\n    let token = this.lex();\n    if (this.hasLineTerminatorBeforeNext) {\n      throw this.createErrorWithLocation(token, ErrorMessages.NEWLINE_AFTER_THROW);\n    }\n    let expression = this.parseExpression();\n    this.consumeSemicolon();\n    return new AST.ThrowStatement({\n      expression\n    });\n  }\n  parseTryStatement() {\n    this.lex();\n    let body = this.parseBlock();\n    if (this.match(TokenType.CATCH)) {\n      let catchClause = this.parseCatchClause();\n      if (this.eat(TokenType.FINALLY)) {\n        let finalizer = this.parseBlock();\n        return new AST.TryFinallyStatement({\n          body,\n          catchClause,\n          finalizer\n        });\n      }\n      return new AST.TryCatchStatement({\n        body,\n        catchClause\n      });\n    }\n    if (this.eat(TokenType.FINALLY)) {\n      let finalizer = this.parseBlock();\n      return new AST.TryFinallyStatement({\n        body,\n        catchClause: null,\n        finalizer\n      });\n    }\n    throw this.createError(ErrorMessages.NO_CATCH_OR_FINALLY);\n  }\n  parseVariableDeclarationStatement() {\n    let declaration = this.parseVariableDeclaration(true);\n    this.consumeSemicolon();\n    return new AST.VariableDeclarationStatement({\n      declaration\n    });\n  }\n  parseWhileStatement() {\n    this.lex();\n    this.expect(TokenType.LPAREN);\n    let test = this.parseExpression();\n    let body = this.getIteratorStatementEpilogue();\n    return new AST.WhileStatement({\n      test,\n      body\n    });\n  }\n  parseWithStatement() {\n    this.lex();\n    this.expect(TokenType.LPAREN);\n    let object = this.parseExpression();\n    this.expect(TokenType.RPAREN);\n    let body = this.parseStatement();\n    return new AST.WithStatement({\n      object,\n      body\n    });\n  }\n  parseCatchClause() {\n    let startState = this.startNode();\n    this.lex();\n    let binding = null;\n\n    // Catch binding is optional\n    if (this.match(TokenType.LPAREN)) {\n      this.lex();\n      if (this.match(TokenType.RPAREN) || this.match(TokenType.LPAREN)) {\n        throw this.createUnexpected(this.lookahead);\n      }\n      binding = this.parseBindingTarget();\n      this.expect(TokenType.RPAREN);\n    }\n    let body = this.parseBlock();\n    return this.finishNode(new AST.CatchClause({\n      binding,\n      body\n    }), startState);\n  }\n  parseBlock() {\n    let startState = this.startNode();\n    this.expect(TokenType.LBRACE);\n    let body = [];\n    while (!this.match(TokenType.RBRACE)) {\n      body.push(this.parseStatementListItem());\n    }\n    this.expect(TokenType.RBRACE);\n    return this.finishNode(new AST.Block({\n      statements: body\n    }), startState);\n  }\n  parseVariableDeclaration(bindingPatternsMustHaveInit) {\n    let startState = this.startNode();\n    let token = this.lex();\n\n    // preceded by this.match(TokenSubType.VAR) || this.match(TokenSubType.LET);\n    let kind = token.type === TokenType.VAR ? 'var' : token.type === TokenType.CONST ? 'const' : 'let';\n    let declarators = this.parseVariableDeclaratorList(bindingPatternsMustHaveInit);\n    return this.finishNode(new AST.VariableDeclaration({\n      kind,\n      declarators\n    }), startState);\n  }\n  parseVariableDeclaratorList(bindingPatternsMustHaveInit) {\n    let result = [];\n    do {\n      result.push(this.parseVariableDeclarator(bindingPatternsMustHaveInit));\n    } while (this.eat(TokenType.COMMA));\n    return result;\n  }\n  parseVariableDeclarator(bindingPatternsMustHaveInit) {\n    let startState = this.startNode();\n    if (this.match(TokenType.LPAREN)) {\n      throw this.createUnexpected(this.lookahead);\n    }\n    let previousAllowIn = this.allowIn;\n    this.allowIn = true;\n    let binding = this.parseBindingTarget();\n    this.allowIn = previousAllowIn;\n    if (bindingPatternsMustHaveInit && binding.type !== 'BindingIdentifier' && !this.match(TokenType.ASSIGN)) {\n      this.expect(TokenType.ASSIGN);\n    }\n    let init = null;\n    if (this.eat(TokenType.ASSIGN)) {\n      init = this.parseAssignmentExpression();\n    }\n    return this.finishNode(new AST.VariableDeclarator({\n      binding,\n      init\n    }), startState);\n  }\n  isolateCoverGrammar(parser) {\n    let oldIsBindingElement = this.isBindingElement,\n      oldIsAssignmentTarget = this.isAssignmentTarget,\n      oldFirstExprError = this.firstExprError,\n      result;\n    this.isBindingElement = this.isAssignmentTarget = true;\n    this.firstExprError = null;\n    result = parser.call(this);\n    if (this.firstExprError !== null) {\n      throw this.firstExprError;\n    }\n    this.isBindingElement = oldIsBindingElement;\n    this.isAssignmentTarget = oldIsAssignmentTarget;\n    this.firstExprError = oldFirstExprError;\n    return result;\n  }\n  inheritCoverGrammar(parser) {\n    let oldIsBindingElement = this.isBindingElement,\n      oldIsAssignmentTarget = this.isAssignmentTarget,\n      oldFirstExprError = this.firstExprError,\n      result;\n    this.isBindingElement = this.isAssignmentTarget = true;\n    this.firstExprError = null;\n    result = parser.call(this);\n    this.isBindingElement = this.isBindingElement && oldIsBindingElement;\n    this.isAssignmentTarget = this.isAssignmentTarget && oldIsAssignmentTarget;\n    this.firstExprError = oldFirstExprError || this.firstExprError;\n    return result;\n  }\n  parseExpression() {\n    let startState = this.startNode();\n    let left = this.parseAssignmentExpression();\n    if (this.match(TokenType.COMMA)) {\n      while (!this.eof()) {\n        if (!this.match(TokenType.COMMA)) break;\n        this.lex();\n        let right = this.parseAssignmentExpression();\n        left = this.finishNode(new AST.BinaryExpression({\n          left,\n          operator: ',',\n          right\n        }), startState);\n      }\n    }\n    return left;\n  }\n  finishArrowParams(head) {\n    let {\n      params = null,\n      rest = null\n    } = head;\n    if (head.type !== ARROW_EXPRESSION_PARAMS) {\n      if (head.type === 'IdentifierExpression') {\n        params = [this.targetToBinding(this.transformDestructuring(head))];\n      } else {\n        throw this.createUnexpected(this.lookahead);\n      }\n    }\n    return this.copyNode(head, new AST.FormalParameters({\n      items: params,\n      rest\n    }));\n  }\n  parseArrowExpressionTail(params, isAsync, startState) {\n    this.expect(TokenType.ARROW);\n    let previousYield = this.allowYieldExpression;\n    let previousAwait = this.allowAwaitExpression;\n    let previousAwaitLocation = this.firstAwaitLocation;\n    this.allowYieldExpression = false;\n    this.allowAwaitExpression = isAsync;\n    this.firstAwaitLocation = null;\n    let body;\n    if (this.match(TokenType.LBRACE)) {\n      let previousAllowIn = this.allowIn;\n      this.allowIn = true;\n      body = this.parseFunctionBody();\n      this.allowIn = previousAllowIn;\n    } else {\n      body = this.parseAssignmentExpression();\n    }\n    this.allowYieldExpression = previousYield;\n    this.allowAwaitExpression = previousAwait;\n    this.firstAwaitLocation = previousAwaitLocation;\n    return this.finishNode(new AST.ArrowExpression({\n      isAsync,\n      params,\n      body\n    }), startState);\n  }\n  parseAssignmentExpression() {\n    return this.isolateCoverGrammar(this.parseAssignmentExpressionOrTarget);\n  }\n  parseAssignmentExpressionOrTarget() {\n    let startState = this.startNode();\n    if (this.allowYieldExpression && this.match(TokenType.YIELD)) {\n      this.isBindingElement = this.isAssignmentTarget = false;\n      return this.parseYieldExpression();\n    }\n    let expr = this.parseConditionalExpression();\n    if (!this.hasLineTerminatorBeforeNext && this.match(TokenType.ARROW)) {\n      this.isBindingElement = this.isAssignmentTarget = false;\n      this.firstExprError = null;\n      let isAsync = expr.type === ARROW_EXPRESSION_PARAMS && expr.isAsync;\n      return this.parseArrowExpressionTail(this.finishArrowParams(expr), isAsync, startState);\n    }\n    let isAssignmentOperator = false;\n    let operator = this.lookahead;\n    switch (operator.type) {\n      case TokenType.ASSIGN_BIT_OR:\n      case TokenType.ASSIGN_BIT_XOR:\n      case TokenType.ASSIGN_BIT_AND:\n      case TokenType.ASSIGN_SHL:\n      case TokenType.ASSIGN_SHR:\n      case TokenType.ASSIGN_SHR_UNSIGNED:\n      case TokenType.ASSIGN_ADD:\n      case TokenType.ASSIGN_SUB:\n      case TokenType.ASSIGN_MUL:\n      case TokenType.ASSIGN_DIV:\n      case TokenType.ASSIGN_MOD:\n      case TokenType.ASSIGN_EXP:\n        isAssignmentOperator = true;\n        break;\n    }\n    if (isAssignmentOperator) {\n      if (!this.isAssignmentTarget || !isValidSimpleAssignmentTarget(expr)) {\n        throw this.createError(ErrorMessages.INVALID_LHS_IN_ASSIGNMENT);\n      }\n      expr = this.transformDestructuring(expr);\n    } else if (operator.type === TokenType.ASSIGN) {\n      if (!this.isAssignmentTarget) {\n        throw this.createError(ErrorMessages.INVALID_LHS_IN_ASSIGNMENT);\n      }\n      expr = this.transformDestructuring(expr);\n    } else {\n      return expr;\n    }\n    this.lex();\n    let rhs = this.parseAssignmentExpression();\n    this.firstExprError = null;\n    let node;\n    if (operator.type === TokenType.ASSIGN) {\n      node = new AST.AssignmentExpression({\n        binding: expr,\n        expression: rhs\n      });\n    } else {\n      node = new AST.CompoundAssignmentExpression({\n        binding: expr,\n        operator: operator.type.name,\n        expression: rhs\n      });\n      this.isBindingElement = this.isAssignmentTarget = false;\n    }\n    return this.finishNode(node, startState);\n  }\n  targetToBinding(node) {\n    if (node === null) {\n      return null;\n    }\n    switch (node.type) {\n      case 'AssignmentTargetIdentifier':\n        return this.copyNode(node, new AST.BindingIdentifier({\n          name: node.name\n        }));\n      case 'ArrayAssignmentTarget':\n        return this.copyNode(node, new AST.ArrayBinding({\n          elements: node.elements.map(e => this.targetToBinding(e)),\n          rest: this.targetToBinding(node.rest)\n        }));\n      case 'ObjectAssignmentTarget':\n        return this.copyNode(node, new AST.ObjectBinding({\n          properties: node.properties.map(p => this.targetToBinding(p)),\n          rest: this.targetToBinding(node.rest)\n        }));\n      case 'AssignmentTargetPropertyIdentifier':\n        return this.copyNode(node, new AST.BindingPropertyIdentifier({\n          binding: this.targetToBinding(node.binding),\n          init: node.init\n        }));\n      case 'AssignmentTargetPropertyProperty':\n        return this.copyNode(node, new AST.BindingPropertyProperty({\n          name: node.name,\n          binding: this.targetToBinding(node.binding)\n        }));\n      case 'AssignmentTargetWithDefault':\n        return this.copyNode(node, new AST.BindingWithDefault({\n          binding: this.targetToBinding(node.binding),\n          init: node.init\n        }));\n    }\n\n    // istanbul ignore next\n    throw new Error('Not reached');\n  }\n  transformDestructuring(node) {\n    switch (node.type) {\n      case 'DataProperty':\n        return this.copyNode(node, new AST.AssignmentTargetPropertyProperty({\n          name: node.name,\n          binding: this.transformDestructuringWithDefault(node.expression)\n        }));\n      case 'ShorthandProperty':\n        return this.copyNode(node, new AST.AssignmentTargetPropertyIdentifier({\n          binding: this.copyNode(node, new AST.AssignmentTargetIdentifier({\n            name: node.name.name\n          })),\n          init: null\n        }));\n      case 'ObjectExpression':\n        {\n          let last = node.properties.length > 0 ? node.properties[node.properties.length - 1] : void 0;\n          if (last != null && last.type === 'SpreadProperty') {\n            return this.copyNode(node, new AST.ObjectAssignmentTarget({\n              properties: node.properties.slice(0, -1).map(e => e && this.transformDestructuringWithDefault(e)),\n              rest: this.transformDestructuring(last.expression)\n            }));\n          }\n          return this.copyNode(node, new AST.ObjectAssignmentTarget({\n            properties: node.properties.map(e => e && this.transformDestructuringWithDefault(e)),\n            rest: null\n          }));\n        }\n      case 'ArrayExpression':\n        {\n          let last = node.elements[node.elements.length - 1];\n          if (last != null && last.type === 'SpreadElement') {\n            return this.copyNode(node, new AST.ArrayAssignmentTarget({\n              elements: node.elements.slice(0, -1).map(e => e && this.transformDestructuringWithDefault(e)),\n              rest: this.copyNode(last.expression, this.transformDestructuring(last.expression))\n            }));\n          }\n          return this.copyNode(node, new AST.ArrayAssignmentTarget({\n            elements: node.elements.map(e => e && this.transformDestructuringWithDefault(e)),\n            rest: null\n          }));\n        }\n      case 'IdentifierExpression':\n        return this.copyNode(node, new AST.AssignmentTargetIdentifier({\n          name: node.name\n        }));\n      case 'StaticPropertyName':\n        return this.copyNode(node, new AST.AssignmentTargetIdentifier({\n          name: node.value\n        }));\n      case 'ComputedMemberExpression':\n        return this.copyNode(node, new AST.ComputedMemberAssignmentTarget({\n          object: node.object,\n          expression: node.expression\n        }));\n      case 'StaticMemberExpression':\n        return this.copyNode(node, new AST.StaticMemberAssignmentTarget({\n          object: node.object,\n          property: node.property\n        }));\n      case 'ArrayAssignmentTarget':\n      case 'ObjectAssignmentTarget':\n      case 'ComputedMemberAssignmentTarget':\n      case 'StaticMemberAssignmentTarget':\n      case 'AssignmentTargetIdentifier':\n      case 'AssignmentTargetPropertyIdentifier':\n      case 'AssignmentTargetPropertyProperty':\n      case 'AssignmentTargetWithDefault':\n        return node;\n    }\n    // istanbul ignore next\n    throw new Error('Not reached');\n  }\n  transformDestructuringWithDefault(node) {\n    switch (node.type) {\n      case 'AssignmentExpression':\n        return this.copyNode(node, new AST.AssignmentTargetWithDefault({\n          binding: this.transformDestructuring(node.binding),\n          init: node.expression\n        }));\n    }\n    return this.transformDestructuring(node);\n  }\n  lookaheadAssignmentExpression() {\n    if (this.matchIdentifier()) {\n      return true;\n    }\n    switch (this.lookahead.type) {\n      case TokenType.ADD:\n      case TokenType.ASSIGN_DIV:\n      case TokenType.BIT_NOT:\n      case TokenType.CLASS:\n      case TokenType.DEC:\n      case TokenType.DELETE:\n      case TokenType.DIV:\n      case TokenType.FALSE:\n      case TokenType.FUNCTION:\n      case TokenType.INC:\n      case TokenType.LBRACE:\n      case TokenType.LBRACK:\n      case TokenType.LPAREN:\n      case TokenType.NEW:\n      case TokenType.NOT:\n      case TokenType.NULL:\n      case TokenType.NUMBER:\n      case TokenType.STRING:\n      case TokenType.SUB:\n      case TokenType.SUPER:\n      case TokenType.THIS:\n      case TokenType.TRUE:\n      case TokenType.TYPEOF:\n      case TokenType.VOID:\n      case TokenType.TEMPLATE:\n        return true;\n    }\n    return false;\n  }\n  parseYieldExpression() {\n    let startState = this.startNode();\n    this.lex();\n    if (this.hasLineTerminatorBeforeNext) {\n      return this.finishNode(new AST.YieldExpression({\n        expression: null\n      }), startState);\n    }\n    let isGenerator = !!this.eat(TokenType.MUL);\n    let expr = null;\n    if (isGenerator || this.lookaheadAssignmentExpression()) {\n      expr = this.parseAssignmentExpression();\n    }\n    let ctor = isGenerator ? AST.YieldGeneratorExpression : AST.YieldExpression;\n    return this.finishNode(new ctor({\n      expression: expr\n    }), startState);\n  }\n  parseConditionalExpression() {\n    let startState = this.startNode();\n    let test = this.parseBinaryExpression();\n    if (this.firstExprError) return test;\n    if (this.eat(TokenType.CONDITIONAL)) {\n      this.isBindingElement = this.isAssignmentTarget = false;\n      let previousAllowIn = this.allowIn;\n      this.allowIn = true;\n      let consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);\n      this.allowIn = previousAllowIn;\n      this.expect(TokenType.COLON);\n      let alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);\n      return this.finishNode(new AST.ConditionalExpression({\n        test,\n        consequent,\n        alternate\n      }), startState);\n    }\n    return test;\n  }\n  isBinaryOperator(type) {\n    switch (type) {\n      case TokenType.OR:\n      case TokenType.AND:\n      case TokenType.BIT_OR:\n      case TokenType.BIT_XOR:\n      case TokenType.BIT_AND:\n      case TokenType.EQ:\n      case TokenType.NE:\n      case TokenType.EQ_STRICT:\n      case TokenType.NE_STRICT:\n      case TokenType.LT:\n      case TokenType.GT:\n      case TokenType.LTE:\n      case TokenType.GTE:\n      case TokenType.INSTANCEOF:\n      case TokenType.SHL:\n      case TokenType.SHR:\n      case TokenType.SHR_UNSIGNED:\n      case TokenType.ADD:\n      case TokenType.SUB:\n      case TokenType.MUL:\n      case TokenType.DIV:\n      case TokenType.MOD:\n        return true;\n      case TokenType.IN:\n        return this.allowIn;\n      default:\n        return false;\n    }\n  }\n  parseBinaryExpression() {\n    let startState = this.startNode();\n    let left = this.parseExponentiationExpression();\n    if (this.firstExprError) {\n      return left;\n    }\n    let operator = this.lookahead.type;\n    if (!this.isBinaryOperator(operator)) return left;\n    this.isBindingElement = this.isAssignmentTarget = false;\n    this.lex();\n    let stack = [];\n    stack.push({\n      startState,\n      left,\n      operator,\n      precedence: BinaryPrecedence[operator.name]\n    });\n    startState = this.startNode();\n    let right = this.isolateCoverGrammar(this.parseExponentiationExpression);\n    operator = this.lookahead.type;\n    while (this.isBinaryOperator(operator)) {\n      let precedence = BinaryPrecedence[operator.name];\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length && precedence <= stack[stack.length - 1].precedence) {\n        let stackItem = stack[stack.length - 1];\n        let stackOperator = stackItem.operator;\n        left = stackItem.left;\n        stack.pop();\n        startState = stackItem.startState;\n        right = this.finishNode(new AST.BinaryExpression({\n          left,\n          operator: stackOperator.name,\n          right\n        }), startState);\n      }\n      this.lex();\n      stack.push({\n        startState,\n        left: right,\n        operator,\n        precedence\n      });\n      startState = this.startNode();\n      right = this.isolateCoverGrammar(this.parseExponentiationExpression);\n      operator = this.lookahead.type;\n    }\n\n    // Final reduce to clean-up the stack.\n    return stack.reduceRight((expr, stackItem) => this.finishNode(new AST.BinaryExpression({\n      left: stackItem.left,\n      operator: stackItem.operator.name,\n      right: expr\n    }), stackItem.startState), right);\n  }\n  parseExponentiationExpression() {\n    let startState = this.startNode();\n    let leftIsParenthesized = this.lookahead.type === TokenType.LPAREN;\n    let left = this.parseUnaryExpression();\n    if (this.lookahead.type !== TokenType.EXP) {\n      return left;\n    }\n    if (left.type === 'UnaryExpression' && !leftIsParenthesized) {\n      throw this.createError(ErrorMessages.INVALID_EXPONENTIATION_LHS);\n    }\n    this.lex();\n    this.isBindingElement = this.isAssignmentTarget = false;\n    let right = this.isolateCoverGrammar(this.parseExponentiationExpression);\n    return this.finishNode(new AST.BinaryExpression({\n      left,\n      operator: '**',\n      right\n    }), startState);\n  }\n  parseUnaryExpression() {\n    if (this.lookahead.type.klass !== TokenClass.Punctuator && this.lookahead.type.klass !== TokenClass.Keyword) {\n      return this.parseUpdateExpression();\n    }\n    let startState = this.startNode();\n    if (this.allowAwaitExpression && this.eat(TokenType.AWAIT)) {\n      this.isBindingElement = this.isAssignmentTarget = false;\n      let expression = this.isolateCoverGrammar(this.parseUnaryExpression);\n      return this.finishNode(new AST.AwaitExpression({\n        expression\n      }), startState);\n    }\n    let operator = this.lookahead;\n    if (!isPrefixOperator(operator)) {\n      return this.parseUpdateExpression();\n    }\n    this.lex();\n    this.isBindingElement = this.isAssignmentTarget = false;\n    let node;\n    if (isUpdateOperator(operator)) {\n      let operandStartLocation = this.getLocation();\n      let operand = this.isolateCoverGrammar(this.parseUnaryExpression);\n      if (!isValidSimpleAssignmentTarget(operand)) {\n        throw this.createErrorWithLocation(operandStartLocation, ErrorMessages.INVALID_UPDATE_OPERAND);\n      }\n      operand = this.transformDestructuring(operand);\n      node = new AST.UpdateExpression({\n        isPrefix: true,\n        operator: operator.value,\n        operand\n      });\n    } else {\n      let operand = this.isolateCoverGrammar(this.parseUnaryExpression);\n      node = new AST.UnaryExpression({\n        operator: operator.value,\n        operand\n      });\n    }\n    return this.finishNode(node, startState);\n  }\n  parseUpdateExpression() {\n    let startLocation = this.getLocation();\n    let startState = this.startNode();\n    let operand = this.parseLeftHandSideExpression({\n      allowCall: true\n    });\n    if (this.firstExprError || this.hasLineTerminatorBeforeNext) return operand;\n    let operator = this.lookahead;\n    if (!isUpdateOperator(operator)) return operand;\n    this.lex();\n    this.isBindingElement = this.isAssignmentTarget = false;\n    if (!isValidSimpleAssignmentTarget(operand)) {\n      throw this.createErrorWithLocation(startLocation, ErrorMessages.INVALID_UPDATE_OPERAND);\n    }\n    operand = this.transformDestructuring(operand);\n    return this.finishNode(new AST.UpdateExpression({\n      isPrefix: false,\n      operator: operator.value,\n      operand\n    }), startState);\n  }\n  parseLeftHandSideExpression({\n    allowCall\n  }) {\n    let startState = this.startNode();\n    let previousAllowIn = this.allowIn;\n    this.allowIn = true;\n    let expr,\n      token = this.lookahead;\n    if (this.eat(TokenType.SUPER)) {\n      this.isBindingElement = false;\n      this.isAssignmentTarget = false;\n      expr = this.finishNode(new AST.Super(), startState);\n      if (this.match(TokenType.LPAREN)) {\n        if (allowCall) {\n          expr = this.finishNode(new AST.CallExpression({\n            callee: expr,\n            arguments: this.parseArgumentList().args\n          }), startState);\n        } else {\n          throw this.createUnexpected(token);\n        }\n      } else if (this.match(TokenType.LBRACK)) {\n        expr = this.finishNode(new AST.ComputedMemberExpression({\n          object: expr,\n          expression: this.parseComputedMember()\n        }), startState);\n        this.isAssignmentTarget = true;\n      } else if (this.match(TokenType.PERIOD)) {\n        expr = this.finishNode(new AST.StaticMemberExpression({\n          object: expr,\n          property: this.parseStaticMember()\n        }), startState);\n        this.isAssignmentTarget = true;\n      } else {\n        throw this.createUnexpected(token);\n      }\n    } else if (this.match(TokenType.NEW)) {\n      this.isBindingElement = this.isAssignmentTarget = false;\n      expr = this.parseNewExpression();\n    } else if (this.match(TokenType.ASYNC)) {\n      expr = this.parsePrimaryExpression();\n      // there's only three things this could be: an identifier, an async arrow, or an async function expression.\n      if (expr.type === 'IdentifierExpression' && allowCall && !this.hasLineTerminatorBeforeNext) {\n        if (this.matchIdentifier()) {\n          // `async [no lineterminator here] identifier` must be an async arrow\n          let afterAsyncStartState = this.startNode();\n          let previousAwait = this.allowAwaitExpression;\n          this.allowAwaitExpression = true;\n          let param = this.parseBindingIdentifier();\n          this.allowAwaitExpression = previousAwait;\n          this.ensureArrow();\n          return this.finishNode({\n            type: ARROW_EXPRESSION_PARAMS,\n            params: [param],\n            rest: null,\n            isAsync: true\n          }, afterAsyncStartState);\n        }\n        if (this.match(TokenType.LPAREN)) {\n          // the maximally obnoxious case: `async (`\n          let afterAsyncStartState = this.startNode();\n          let previousAwaitLocation = this.firstAwaitLocation;\n          this.firstAwaitLocation = null;\n          let {\n            args,\n            locationFollowingFirstSpread\n          } = this.parseArgumentList();\n          if (this.isBindingElement && !this.hasLineTerminatorBeforeNext && this.match(TokenType.ARROW)) {\n            if (locationFollowingFirstSpread !== null) {\n              throw this.createErrorWithLocation(locationFollowingFirstSpread, ErrorMessages.UNEXPECTED_TOKEN(','));\n            }\n            if (this.firstAwaitLocation !== null) {\n              throw this.createErrorWithLocation(this.firstAwaitLocation, ErrorMessages.NO_AWAIT_IN_ASYNC_PARAMS);\n            }\n            let rest = null;\n            if (args.length > 0 && args[args.length - 1].type === 'SpreadElement') {\n              rest = this.targetToBinding(this.transformDestructuringWithDefault(args[args.length - 1].expression));\n              if (rest.init != null) {\n                throw this.createError(ErrorMessages.UNEXPECTED_REST_PARAMETERS_INITIALIZATION);\n              }\n              args = args.slice(0, -1);\n            }\n            let params = args.map(arg => this.targetToBinding(this.transformDestructuringWithDefault(arg)));\n            return this.finishNode({\n              type: ARROW_EXPRESSION_PARAMS,\n              params,\n              rest,\n              isAsync: true\n            }, afterAsyncStartState);\n          }\n          this.firstAwaitLocation = previousAwaitLocation || this.firstAwaitLocation;\n          // otherwise we've just taken the first iteration of the loop below\n          this.isBindingElement = this.isAssignmentTarget = false;\n          expr = this.finishNode(new AST.CallExpression({\n            callee: expr,\n            arguments: args\n          }), startState);\n        }\n      }\n    } else {\n      expr = this.parsePrimaryExpression();\n      if (this.firstExprError) {\n        return expr;\n      }\n    }\n    while (true) {\n      if (allowCall && this.match(TokenType.LPAREN)) {\n        this.isBindingElement = this.isAssignmentTarget = false;\n        expr = this.finishNode(new AST.CallExpression({\n          callee: expr,\n          arguments: this.parseArgumentList().args\n        }), startState);\n      } else if (this.match(TokenType.LBRACK)) {\n        this.isBindingElement = false;\n        this.isAssignmentTarget = true;\n        expr = this.finishNode(new AST.ComputedMemberExpression({\n          object: expr,\n          expression: this.parseComputedMember()\n        }), startState);\n      } else if (this.match(TokenType.PERIOD)) {\n        this.isBindingElement = false;\n        this.isAssignmentTarget = true;\n        expr = this.finishNode(new AST.StaticMemberExpression({\n          object: expr,\n          property: this.parseStaticMember()\n        }), startState);\n      } else if (this.match(TokenType.TEMPLATE)) {\n        this.isBindingElement = this.isAssignmentTarget = false;\n        expr = this.finishNode(new AST.TemplateExpression({\n          tag: expr,\n          elements: this.parseTemplateElements()\n        }), startState);\n      } else {\n        break;\n      }\n    }\n    this.allowIn = previousAllowIn;\n    return expr;\n  }\n  parseTemplateElements() {\n    let startState = this.startNode();\n    let token = this.lookahead;\n    if (token.tail) {\n      this.lex();\n      return [this.finishNode(new AST.TemplateElement({\n        rawValue: token.slice.text.slice(1, -1)\n      }), startState)];\n    }\n    let result = [this.finishNode(new AST.TemplateElement({\n      rawValue: this.lex().slice.text.slice(1, -2)\n    }), startState)];\n    while (true) {\n      result.push(this.parseExpression());\n      if (!this.match(TokenType.RBRACE)) {\n        throw this.createILLEGAL();\n      }\n      this.index = this.startIndex;\n      this.line = this.startLine;\n      this.lineStart = this.startLineStart;\n      this.lookahead = this.scanTemplateElement();\n      startState = this.startNode();\n      token = this.lex();\n      if (token.tail) {\n        result.push(this.finishNode(new AST.TemplateElement({\n          rawValue: token.slice.text.slice(1, -1)\n        }), startState));\n        return result;\n      }\n      result.push(this.finishNode(new AST.TemplateElement({\n        rawValue: token.slice.text.slice(1, -2)\n      }), startState));\n    }\n  }\n  parseStaticMember() {\n    this.lex();\n    if (this.lookahead.type.klass.isIdentifierName) {\n      return this.lex().value;\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n  parseComputedMember() {\n    this.lex();\n    let expr = this.parseExpression();\n    this.expect(TokenType.RBRACK);\n    return expr;\n  }\n  parseNewExpression() {\n    let startState = this.startNode();\n    this.lex();\n    if (this.eat(TokenType.PERIOD)) {\n      this.expectContextualKeyword('target');\n      return this.finishNode(new AST.NewTargetExpression(), startState);\n    }\n    let callee = this.isolateCoverGrammar(() => this.parseLeftHandSideExpression({\n      allowCall: false\n    }));\n    return this.finishNode(new AST.NewExpression({\n      callee,\n      arguments: this.match(TokenType.LPAREN) ? this.parseArgumentList().args : []\n    }), startState);\n  }\n  parseRegexFlags(flags) {\n    let isGlobal = false,\n      ignoreCase = false,\n      multiLine = false,\n      unicode = false,\n      sticky = false,\n      dotAll = false;\n    for (let i = 0; i < flags.length; ++i) {\n      let f = flags[i];\n      switch (f) {\n        case 'g':\n          if (isGlobal) {\n            throw this.createError('Duplicate regular expression flag \\'g\\'');\n          }\n          isGlobal = true;\n          break;\n        case 'i':\n          if (ignoreCase) {\n            throw this.createError('Duplicate regular expression flag \\'i\\'');\n          }\n          ignoreCase = true;\n          break;\n        case 'm':\n          if (multiLine) {\n            throw this.createError('Duplicate regular expression flag \\'m\\'');\n          }\n          multiLine = true;\n          break;\n        case 'u':\n          if (unicode) {\n            throw this.createError('Duplicate regular expression flag \\'u\\'');\n          }\n          unicode = true;\n          break;\n        case 'y':\n          if (sticky) {\n            throw this.createError('Duplicate regular expression flag \\'y\\'');\n          }\n          sticky = true;\n          break;\n        case 's':\n          if (dotAll) {\n            throw this.createError('Duplicate regular expression flag \\'s\\'');\n          }\n          dotAll = true;\n          break;\n        default:\n          throw this.createError(`Invalid regular expression flag '${f}'`);\n      }\n    }\n    return {\n      global: isGlobal,\n      ignoreCase,\n      multiLine,\n      unicode,\n      sticky,\n      dotAll\n    };\n  }\n  parsePrimaryExpression() {\n    if (this.match(TokenType.LPAREN)) {\n      return this.parseGroupExpression();\n    }\n    let startState = this.startNode();\n    if (this.eat(TokenType.ASYNC)) {\n      if (!this.hasLineTerminatorBeforeNext && this.match(TokenType.FUNCTION)) {\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(this.parseFunction({\n          isExpr: true,\n          inDefault: false,\n          allowGenerator: true,\n          isAsync: true\n        }), startState);\n      }\n      return this.finishNode(new AST.IdentifierExpression({\n        name: 'async'\n      }), startState);\n    }\n    if (this.matchIdentifier()) {\n      return this.finishNode(new AST.IdentifierExpression({\n        name: this.parseIdentifier()\n      }), startState);\n    }\n    switch (this.lookahead.type) {\n      case TokenType.STRING:\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.parseStringLiteral();\n      case TokenType.NUMBER:\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.parseNumericLiteral();\n      case TokenType.THIS:\n        this.lex();\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(new AST.ThisExpression(), startState);\n      case TokenType.FUNCTION:\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(this.parseFunction({\n          isExpr: true,\n          inDefault: false,\n          allowGenerator: true,\n          isAsync: false\n        }), startState);\n      case TokenType.TRUE:\n        this.lex();\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(new AST.LiteralBooleanExpression({\n          value: true\n        }), startState);\n      case TokenType.FALSE:\n        this.lex();\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(new AST.LiteralBooleanExpression({\n          value: false\n        }), startState);\n      case TokenType.NULL:\n        this.lex();\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(new AST.LiteralNullExpression(), startState);\n      case TokenType.LBRACK:\n        return this.parseArrayExpression();\n      case TokenType.LBRACE:\n        return this.parseObjectExpression();\n      case TokenType.TEMPLATE:\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(new AST.TemplateExpression({\n          tag: null,\n          elements: this.parseTemplateElements()\n        }), startState);\n      case TokenType.DIV:\n      case TokenType.ASSIGN_DIV:\n        {\n          this.isBindingElement = this.isAssignmentTarget = false;\n          this.lookahead = this.scanRegExp(this.match(TokenType.DIV) ? '/' : '/=');\n          let token = this.lex();\n          let lastSlash = token.value.lastIndexOf('/');\n          let pattern = token.value.slice(1, lastSlash);\n          let flags = token.value.slice(lastSlash + 1);\n          let ctorArgs = this.parseRegexFlags(flags);\n          if (!acceptRegex(pattern, ctorArgs)) {\n            throw this.createError(ErrorMessages.INVALID_REGEX);\n          }\n          ctorArgs.pattern = pattern;\n          return this.finishNode(new AST.LiteralRegExpExpression(ctorArgs), startState);\n        }\n      case TokenType.CLASS:\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.parseClass({\n          isExpr: true,\n          inDefault: false\n        });\n      default:\n        throw this.createUnexpected(this.lookahead);\n    }\n  }\n  parseNumericLiteral() {\n    let startLocation = this.getLocation();\n    let startState = this.startNode();\n    let token = this.lex();\n    if (token.octal && this.strict) {\n      if (token.noctal) {\n        throw this.createErrorWithLocation(startLocation, 'Unexpected noctal integer literal');\n      } else {\n        throw this.createErrorWithLocation(startLocation, 'Unexpected legacy octal integer literal');\n      }\n    }\n    let node = token.value === 1 / 0 ? new AST.LiteralInfinityExpression() : new AST.LiteralNumericExpression({\n      value: token.value\n    });\n    return this.finishNode(node, startState);\n  }\n  parseStringLiteral() {\n    let startLocation = this.getLocation();\n    let startState = this.startNode();\n    let token = this.lex();\n    if (token.octal != null && this.strict) {\n      throw this.createErrorWithLocation(startLocation, 'Unexpected legacy octal escape sequence: \\\\' + token.octal);\n    }\n    return this.finishNode(new AST.LiteralStringExpression({\n      value: token.str\n    }), startState);\n  }\n  parseIdentifierName() {\n    if (this.lookahead.type.klass.isIdentifierName) {\n      return this.lex().value;\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n  parseBindingIdentifier() {\n    let startState = this.startNode();\n    return this.finishNode(new AST.BindingIdentifier({\n      name: this.parseIdentifier()\n    }), startState);\n  }\n  parseIdentifier() {\n    if (this.lookahead.value === 'yield' && this.allowYieldExpression) {\n      throw this.createError(ErrorMessages.ILLEGAL_YIELD_IDENTIFIER);\n    }\n    if (this.lookahead.value === 'await' && this.allowAwaitExpression) {\n      throw this.createError(ErrorMessages.ILLEGAL_AWAIT_IDENTIFIER);\n    }\n    if (this.matchIdentifier()) {\n      return this.lex().value;\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n  parseArgumentList() {\n    this.lex();\n    let args = this.parseArguments();\n    this.expect(TokenType.RPAREN);\n    return args;\n  }\n  parseArguments() {\n    let args = [];\n    let locationFollowingFirstSpread = null;\n    while (!this.match(TokenType.RPAREN)) {\n      let arg;\n      let startState = this.startNode();\n      if (this.eat(TokenType.ELLIPSIS)) {\n        arg = this.finishNode(new AST.SpreadElement({\n          expression: this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget)\n        }), startState);\n        if (locationFollowingFirstSpread === null) {\n          args.push(arg);\n          if (this.match(TokenType.RPAREN)) {\n            break;\n          }\n          locationFollowingFirstSpread = this.getLocation();\n          this.expect(TokenType.COMMA);\n          continue;\n        }\n      } else {\n        arg = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n      }\n      args.push(arg);\n      if (this.match(TokenType.RPAREN)) {\n        break;\n      }\n      this.expect(TokenType.COMMA);\n    }\n    return {\n      args,\n      locationFollowingFirstSpread\n    };\n  }\n\n  // 11.2 Left-Hand-Side Expressions;\n\n  ensureArrow() {\n    if (this.hasLineTerminatorBeforeNext) {\n      throw this.createError(ErrorMessages.UNEXPECTED_LINE_TERMINATOR);\n    }\n    if (!this.match(TokenType.ARROW)) {\n      this.expect(TokenType.ARROW);\n    }\n  }\n  parseGroupExpression() {\n    // At this point, we need to parse 3 things:\n    //  1. Group expression\n    //  2. Assignment target of assignment expression\n    //  3. Parameter list of arrow function\n    let rest = null;\n    let preParenStartState = this.startNode();\n    let start = this.expect(TokenType.LPAREN);\n    let postParenStartState = this.startNode();\n    if (this.match(TokenType.RPAREN)) {\n      this.lex();\n      let paramsNode = this.finishNode({\n        type: ARROW_EXPRESSION_PARAMS,\n        params: [],\n        rest: null,\n        isAsync: false\n      }, preParenStartState);\n      this.ensureArrow();\n      this.isBindingElement = this.isAssignmentTarget = false;\n      return paramsNode;\n    } else if (this.eat(TokenType.ELLIPSIS)) {\n      rest = this.parseBindingTarget();\n      if (this.match(TokenType.ASSIGN)) {\n        throw this.createError(ErrorMessages.INVALID_REST_PARAMETERS_INITIALIZATION);\n      }\n      if (this.match(TokenType.COMMA)) {\n        throw this.createError(ErrorMessages.INVALID_LAST_REST_PARAMETER);\n      }\n      this.expect(TokenType.RPAREN);\n      let paramsNode = this.finishNode({\n        type: ARROW_EXPRESSION_PARAMS,\n        params: [],\n        rest,\n        isAsync: false\n      }, preParenStartState);\n      this.ensureArrow();\n      this.isBindingElement = this.isAssignmentTarget = false;\n      return paramsNode;\n    }\n    let group = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n    let params = this.isBindingElement ? [this.targetToBinding(this.transformDestructuringWithDefault(group))] : null;\n    while (this.eat(TokenType.COMMA)) {\n      if (this.match(TokenType.RPAREN)) {\n        if (!this.isBindingElement) {\n          throw this.createUnexpected(this.lookahead);\n        }\n        this.firstExprError = this.firstExprError || this.createUnexpected(this.lookahead);\n        group = null;\n        break;\n      }\n      this.isAssignmentTarget = false;\n      if (this.match(TokenType.ELLIPSIS)) {\n        if (!this.isBindingElement) {\n          throw this.createUnexpected(this.lookahead);\n        }\n        this.lex();\n        rest = this.parseBindingTarget();\n        if (this.match(TokenType.ASSIGN)) {\n          throw this.createError(ErrorMessages.INVALID_REST_PARAMETERS_INITIALIZATION);\n        }\n        if (this.match(TokenType.COMMA)) {\n          throw this.createError(ErrorMessages.INVALID_LAST_REST_PARAMETER);\n        }\n        break;\n      }\n      if (group) {\n        // Can be either binding element or assignment target.\n        let expr = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n        if (this.isBindingElement) {\n          params.push(this.targetToBinding(this.transformDestructuringWithDefault(expr)));\n        } else {\n          params = null;\n        }\n        if (this.firstExprError) {\n          group = null;\n        } else {\n          group = this.finishNode(new AST.BinaryExpression({\n            left: group,\n            operator: ',',\n            right: expr\n          }), postParenStartState);\n        }\n      } else {\n        // Can be only binding elements.\n        let binding = this.parseBindingElement();\n        params.push(binding);\n      }\n    }\n    this.expect(TokenType.RPAREN);\n    if (!this.hasLineTerminatorBeforeNext && this.match(TokenType.ARROW)) {\n      if (!this.isBindingElement) {\n        throw this.createErrorWithLocation(start, ErrorMessages.ILLEGAL_ARROW_FUNCTION_PARAMS);\n      }\n      this.isBindingElement = false;\n      return this.finishNode({\n        type: ARROW_EXPRESSION_PARAMS,\n        params,\n        rest,\n        isAsync: false\n      }, preParenStartState);\n    }\n    // Ensure assignment pattern:\n    if (rest) {\n      this.ensureArrow();\n    }\n    this.isBindingElement = false;\n    if (!isValidSimpleAssignmentTarget(group)) {\n      this.isAssignmentTarget = false;\n    }\n    return group;\n  }\n  parseArrayExpression() {\n    let startLocation = this.getLocation();\n    let startState = this.startNode();\n    this.lex();\n    let exprs = [];\n    let rest = null;\n    while (true) {\n      if (this.match(TokenType.RBRACK)) {\n        break;\n      }\n      if (this.eat(TokenType.COMMA)) {\n        exprs.push(null);\n      } else {\n        let elementStartState = this.startNode();\n        let expr;\n        if (this.eat(TokenType.ELLIPSIS)) {\n          // Spread/Rest element\n          expr = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n          if (!this.isAssignmentTarget && this.firstExprError) {\n            throw this.firstExprError;\n          }\n          if (expr.type === 'ArrayAssignmentTarget' || expr.type === 'ObjectAssignmentTarget') {\n            rest = expr;\n            break;\n          }\n          if (expr.type !== 'ArrayExpression' && expr.type !== 'ObjectExpression' && !isValidSimpleAssignmentTarget(expr)) {\n            this.isBindingElement = this.isAssignmentTarget = false;\n          }\n          expr = this.finishNode(new AST.SpreadElement({\n            expression: expr\n          }), elementStartState);\n          if (!this.match(TokenType.RBRACK)) {\n            this.isBindingElement = this.isAssignmentTarget = false;\n          }\n        } else {\n          expr = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n          if (!this.isAssignmentTarget && this.firstExprError) {\n            throw this.firstExprError;\n          }\n        }\n        exprs.push(expr);\n        if (!this.match(TokenType.RBRACK)) {\n          this.expect(TokenType.COMMA);\n        }\n      }\n    }\n    if (rest && this.match(TokenType.COMMA)) {\n      throw this.createErrorWithLocation(startLocation, ErrorMessages.UNEXPECTED_COMMA_AFTER_REST);\n    }\n    this.expect(TokenType.RBRACK);\n    if (rest) {\n      // No need to check isAssignmentTarget: the only way to have something we know is a rest element is if we have ...Object/ArrayAssignmentTarget, which implies we have a firstExprError; as such, if isAssignmentTarget were false, we'd've thrown above before setting rest.\n      return this.finishNode(new AST.ArrayAssignmentTarget({\n        elements: exprs.map(e => e && this.transformDestructuringWithDefault(e)),\n        rest\n      }), startState);\n    } else if (this.firstExprError) {\n      let last = exprs[exprs.length - 1];\n      if (last != null && last.type === 'SpreadElement') {\n        return this.finishNode(new AST.ArrayAssignmentTarget({\n          elements: exprs.slice(0, -1).map(e => e && this.transformDestructuringWithDefault(e)),\n          rest: this.transformDestructuring(last.expression)\n        }), startState);\n      }\n      return this.finishNode(new AST.ArrayAssignmentTarget({\n        elements: exprs.map(e => e && this.transformDestructuringWithDefault(e)),\n        rest: null\n      }), startState);\n    }\n    return this.finishNode(new AST.ArrayExpression({\n      elements: exprs\n    }), startState);\n  }\n  parseObjectExpression() {\n    let startState = this.startNode();\n    this.lex();\n    let properties = [];\n    while (!this.match(TokenType.RBRACE)) {\n      let isSpreadProperty = false;\n      if (this.match(TokenType.ELLIPSIS)) {\n        isSpreadProperty = true;\n        let spreadPropertyOrAssignmentTarget = this.parseSpreadPropertyDefinition();\n        properties.push(spreadPropertyOrAssignmentTarget);\n      } else {\n        let property = this.inheritCoverGrammar(this.parsePropertyDefinition);\n        properties.push(property);\n      }\n      if (!this.match(TokenType.RBRACE)) {\n        this.expect(TokenType.COMMA);\n        if (isSpreadProperty) {\n          this.isBindingElement = this.isAssignmentTarget = false;\n        }\n      }\n    }\n    this.expect(TokenType.RBRACE);\n    if (this.firstExprError) {\n      if (!this.isAssignmentTarget) {\n        throw this.createError(ErrorMessages.INVALID_LHS_IN_BINDING);\n      }\n      let last = properties[properties.length - 1];\n      if (last != null && last.type === 'SpreadProperty') {\n        return this.finishNode(new AST.ObjectAssignmentTarget({\n          properties: properties.slice(0, -1).map(p => this.transformDestructuringWithDefault(p)),\n          rest: this.transformDestructuring(last.expression)\n        }), startState);\n      }\n      return this.finishNode(new AST.ObjectAssignmentTarget({\n        properties: properties.map(p => this.transformDestructuringWithDefault(p)),\n        rest: null\n      }), startState);\n    }\n    return this.finishNode(new AST.ObjectExpression({\n      properties\n    }), startState);\n  }\n  parseSpreadPropertyDefinition() {\n    let startState = this.startNode();\n    this.expect(TokenType.ELLIPSIS);\n    let expression = this.parseAssignmentExpression();\n    if (!isValidSimpleAssignmentTarget(expression)) {\n      this.isBindingElement = this.isAssignmentTarget = false;\n    } else if (expression.type !== 'IdentifierExpression') {\n      this.isBindingElement = false;\n    }\n    return this.finishNode(new AST.SpreadProperty({\n      expression\n    }), startState);\n  }\n  parsePropertyDefinition() {\n    let startLocation = this.getLocation();\n    let startState = this.startNode();\n    let token = this.lookahead;\n    let {\n      methodOrKey,\n      kind\n    } = this.parseMethodDefinition();\n    switch (kind) {\n      case 'method':\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return methodOrKey;\n      case 'identifier':\n        if (token.value === 'await' && this.firstAwaitLocation == null) {\n          this.firstAwaitLocation = this.getLocation();\n        }\n        if (this.eat(TokenType.ASSIGN)) {\n          if (this.allowYieldExpression && token.value === 'yield') {\n            throw this.createError(ErrorMessages.ILLEGAL_YIELD_IDENTIFIER);\n          }\n          if (this.allowAwaitExpression && token.value === 'await') {\n            throw this.createError(ErrorMessages.ILLEGAL_AWAIT_IDENTIFIER);\n          }\n          // CoverInitializedName\n          let init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n          this.firstExprError = this.createErrorWithLocation(startLocation, ErrorMessages.ILLEGAL_PROPERTY);\n          return this.finishNode(new AST.AssignmentTargetPropertyIdentifier({\n            binding: this.transformDestructuring(methodOrKey),\n            init\n          }), startState);\n        } else if (!this.match(TokenType.COLON)) {\n          if (this.allowYieldExpression && token.value === 'yield') {\n            throw this.createError(ErrorMessages.ILLEGAL_YIELD_IDENTIFIER);\n          }\n          if (this.allowAwaitExpression && token.value === 'await') {\n            throw this.createError(ErrorMessages.ILLEGAL_AWAIT_IDENTIFIER);\n          }\n          if (token.type === TokenType.IDENTIFIER || token.value === 'let' || token.value === 'yield' || token.value === 'async' || token.value === 'await') {\n            return this.finishNode(new AST.ShorthandProperty({\n              name: this.finishNode(new AST.IdentifierExpression({\n                name: methodOrKey.value\n              }), startState)\n            }), startState);\n          }\n          throw this.createUnexpected(token);\n        }\n    }\n\n    // property\n    this.expect(TokenType.COLON);\n    let expr = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n    if (this.firstExprError) {\n      return this.finishNode(new AST.AssignmentTargetPropertyProperty({\n        name: methodOrKey,\n        binding: expr\n      }), startState);\n    }\n    return this.finishNode(new AST.DataProperty({\n      name: methodOrKey,\n      expression: expr\n    }), startState);\n  }\n  parsePropertyName() {\n    // PropertyName[Yield,GeneratorParameter]:\n    let token = this.lookahead;\n    let startState = this.startNode();\n    if (this.eof()) {\n      throw this.createUnexpected(token);\n    }\n    switch (token.type) {\n      case TokenType.STRING:\n        return {\n          name: this.finishNode(new AST.StaticPropertyName({\n            value: this.parseStringLiteral().value\n          }), startState),\n          binding: null\n        };\n      case TokenType.NUMBER:\n        {\n          let numLiteral = this.parseNumericLiteral();\n          return {\n            name: this.finishNode(new AST.StaticPropertyName({\n              value: `${numLiteral.type === 'LiteralInfinityExpression' ? 1 / 0 : numLiteral.value}`\n            }), startState),\n            binding: null\n          };\n        }\n      case TokenType.LBRACK:\n        {\n          this.lex();\n          let expr = this.parseAssignmentExpression();\n          this.expect(TokenType.RBRACK);\n          return {\n            name: this.finishNode(new AST.ComputedPropertyName({\n              expression: expr\n            }), startState),\n            binding: null\n          };\n        }\n    }\n    let name = this.parseIdentifierName();\n    return {\n      name: this.finishNode(new AST.StaticPropertyName({\n        value: name\n      }), startState),\n      binding: this.finishNode(new AST.BindingIdentifier({\n        name\n      }), startState)\n    };\n  }\n\n  /**\n   * Test if lookahead can be the beginning of a `PropertyName`.\n   * @returns {boolean}\n   */\n  lookaheadPropertyName() {\n    switch (this.lookahead.type) {\n      case TokenType.NUMBER:\n      case TokenType.STRING:\n      case TokenType.LBRACK:\n        return true;\n      default:\n        return this.lookahead.type.klass.isIdentifierName;\n    }\n  }\n\n  // eslint-disable-next-line valid-jsdoc\n  /**\n   * Try to parse a method definition.\n   *\n   * If it turns out to be one of:\n   *  * `IdentifierReference`\n   *  * `CoverInitializedName` (`IdentifierReference \"=\" AssignmentExpression`)\n   *  * `PropertyName : AssignmentExpression`\n   * The parser will stop at the end of the leading `Identifier` or `PropertyName` and return it.\n   *\n   * @returns {{methodOrKey: (Method|PropertyName), kind: string}}\n   */\n  parseMethodDefinition() {\n    let token = this.lookahead;\n    let startState = this.startNode();\n    let preAsyncTokenState = this.saveLexerState();\n    let isAsync = !!this.eat(TokenType.ASYNC);\n    if (isAsync && this.hasLineTerminatorBeforeNext) {\n      isAsync = false;\n      this.restoreLexerState(preAsyncTokenState);\n    }\n    let isGenerator = !!this.eat(TokenType.MUL);\n    if (isAsync && !this.lookaheadPropertyName()) {\n      isAsync = false;\n      isGenerator = false;\n      this.restoreLexerState(preAsyncTokenState);\n    }\n    let {\n      name\n    } = this.parsePropertyName();\n    if (!isGenerator && !isAsync) {\n      if (token.type === TokenType.IDENTIFIER && token.value.length === 3) {\n        // Property Assignment: Getter and Setter.\n        if (token.value === 'get' && this.lookaheadPropertyName() && !token.escaped) {\n          ({\n            name\n          } = this.parsePropertyName());\n          this.expect(TokenType.LPAREN);\n          this.expect(TokenType.RPAREN);\n          let previousYield = this.allowYieldExpression;\n          let previousAwait = this.allowAwaitExpression;\n          let previousAwaitLocation = this.firstAwaitLocation;\n          this.allowYieldExpression = false;\n          this.allowAwaitExpression = false;\n          this.firstAwaitLocation = null;\n          let body = this.parseFunctionBody();\n          this.allowYieldExpression = previousYield;\n          this.allowAwaitExpression = previousAwait;\n          this.firstAwaitLocation = previousAwaitLocation;\n          return {\n            methodOrKey: this.finishNode(new AST.Getter({\n              name,\n              body\n            }), startState),\n            kind: 'method'\n          };\n        } else if (token.value === 'set' && this.lookaheadPropertyName() && !token.escaped) {\n          ({\n            name\n          } = this.parsePropertyName());\n          this.expect(TokenType.LPAREN);\n          let previousYield = this.allowYieldExpression;\n          let previousAwait = this.allowAwaitExpression;\n          let previousAwaitLocation = this.firstAwaitLocation;\n          this.allowYieldExpression = false;\n          this.allowAwaitExpression = false;\n          this.firstAwaitLocation = null;\n          let param = this.parseBindingElement();\n          this.expect(TokenType.RPAREN);\n          let body = this.parseFunctionBody();\n          this.allowYieldExpression = previousYield;\n          this.allowAwaitExpression = previousAwait;\n          this.firstAwaitLocation = previousAwaitLocation;\n          return {\n            methodOrKey: this.finishNode(new AST.Setter({\n              name,\n              param,\n              body\n            }), startState),\n            kind: 'method'\n          };\n        }\n      }\n    }\n    if (isAsync) {\n      let previousYield = this.allowYieldExpression;\n      let previousAwait = this.allowAwaitExpression;\n      this.allowYieldExpression = isGenerator;\n      this.allowAwaitExpression = true;\n      let params = this.parseParams();\n      this.allowYieldExpression = isGenerator;\n      this.allowAwaitExpression = true;\n      let body = this.parseFunctionBody();\n      this.allowYieldExpression = previousYield;\n      this.allowAwaitExpression = previousAwait;\n      return {\n        methodOrKey: this.finishNode(new AST.Method({\n          isAsync,\n          isGenerator,\n          name,\n          params,\n          body\n        }), startState),\n        kind: 'method'\n      };\n    }\n    if (this.match(TokenType.LPAREN)) {\n      let previousYield = this.allowYieldExpression;\n      let previousAwait = this.allowAwaitExpression;\n      let previousAwaitLocation = this.firstAwaitLocation;\n      this.allowYieldExpression = isGenerator;\n      this.allowAwaitExpression = false;\n      this.firstAwaitLocation = null;\n      let params = this.parseParams();\n      let body = this.parseFunctionBody();\n      this.allowYieldExpression = previousYield;\n      this.allowAwaitExpression = previousAwait;\n      this.firstAwaitLocation = previousAwaitLocation;\n      return {\n        methodOrKey: this.finishNode(new AST.Method({\n          isAsync,\n          isGenerator,\n          name,\n          params,\n          body\n        }), startState),\n        kind: 'method'\n      };\n    }\n    if (isGenerator && this.match(TokenType.COLON)) {\n      throw this.createUnexpected(this.lookahead);\n    }\n    return {\n      methodOrKey: name,\n      kind: token.type.klass.isIdentifierName ? 'identifier' : 'property',\n      escaped: token.escaped\n    };\n  }\n  parseClass({\n    isExpr,\n    inDefault\n  }) {\n    let startState = this.startNode();\n    this.lex();\n    let name = null;\n    let heritage = null;\n    if (this.matchIdentifier()) {\n      name = this.parseBindingIdentifier();\n    } else if (!isExpr) {\n      if (inDefault) {\n        name = new AST.BindingIdentifier({\n          name: '*default*'\n        });\n      } else {\n        throw this.createUnexpected(this.lookahead);\n      }\n    }\n    if (this.eat(TokenType.EXTENDS)) {\n      heritage = this.isolateCoverGrammar(() => this.parseLeftHandSideExpression({\n        allowCall: true\n      }));\n    }\n    this.expect(TokenType.LBRACE);\n    let elements = [];\n    while (!this.eat(TokenType.RBRACE)) {\n      if (this.eat(TokenType.SEMICOLON)) {\n        continue;\n      }\n      let isStatic = false;\n      let classElementStart = this.startNode();\n      let {\n        methodOrKey,\n        kind,\n        escaped\n      } = this.parseMethodDefinition();\n      if (kind === 'identifier' && methodOrKey.value === 'static' && !escaped) {\n        isStatic = true;\n        ({\n          methodOrKey,\n          kind\n        } = this.parseMethodDefinition());\n      }\n      if (kind === 'method') {\n        elements.push(this.finishNode(new AST.ClassElement({\n          isStatic,\n          method: methodOrKey\n        }), classElementStart));\n      } else {\n        throw this.createError('Only methods are allowed in classes');\n      }\n    }\n    return this.finishNode(new (isExpr ? AST.ClassExpression : AST.ClassDeclaration)({\n      name,\n      super: heritage,\n      elements\n    }), startState);\n  }\n  parseFunction({\n    isExpr,\n    inDefault,\n    allowGenerator,\n    isAsync,\n    startState = this.startNode()\n  }) {\n    this.lex();\n    let name = null;\n    let isGenerator = allowGenerator && !!this.eat(TokenType.MUL);\n    let previousYield = this.allowYieldExpression;\n    let previousAwait = this.allowAwaitExpression;\n    let previousAwaitLocation = this.firstAwaitLocation;\n    if (isExpr) {\n      this.allowYieldExpression = isGenerator;\n      this.allowAwaitExpression = isAsync;\n    }\n    if (!this.match(TokenType.LPAREN)) {\n      name = this.parseBindingIdentifier();\n    } else if (!isExpr) {\n      if (inDefault) {\n        name = new AST.BindingIdentifier({\n          name: '*default*'\n        });\n      } else {\n        throw this.createUnexpected(this.lookahead);\n      }\n    }\n    this.allowYieldExpression = isGenerator;\n    this.allowAwaitExpression = isAsync;\n    this.firstAwaitLocation = null;\n    let params = this.parseParams();\n    let body = this.parseFunctionBody();\n    this.allowYieldExpression = previousYield;\n    this.allowAwaitExpression = previousAwait;\n    this.firstAwaitLocation = previousAwaitLocation;\n    return this.finishNode(new (isExpr ? AST.FunctionExpression : AST.FunctionDeclaration)({\n      isAsync,\n      isGenerator,\n      name,\n      params,\n      body\n    }), startState);\n  }\n  parseArrayBinding() {\n    let startState = this.startNode();\n    this.expect(TokenType.LBRACK);\n    let elements = [],\n      rest = null;\n    while (true) {\n      if (this.match(TokenType.RBRACK)) {\n        break;\n      }\n      let el;\n      if (this.eat(TokenType.COMMA)) {\n        el = null;\n      } else {\n        if (this.eat(TokenType.ELLIPSIS)) {\n          rest = this.parseBindingTarget();\n          break;\n        } else {\n          el = this.parseBindingElement();\n        }\n        if (!this.match(TokenType.RBRACK)) {\n          this.expect(TokenType.COMMA);\n        }\n      }\n      elements.push(el);\n    }\n    this.expect(TokenType.RBRACK);\n    return this.finishNode(new AST.ArrayBinding({\n      elements,\n      rest\n    }), startState);\n  }\n  parseBindingProperty() {\n    let startState = this.startNode();\n    let isIdentifier = this.matchIdentifier();\n    let token = this.lookahead;\n    let {\n      name,\n      binding\n    } = this.parsePropertyName();\n    if (isIdentifier && name.type === 'StaticPropertyName') {\n      if (!this.match(TokenType.COLON)) {\n        if (this.allowYieldExpression && token.value === 'yield') {\n          throw this.createError(ErrorMessages.ILLEGAL_YIELD_IDENTIFIER);\n        }\n        if (this.allowAwaitExpression && token.value === 'await') {\n          throw this.createError(ErrorMessages.ILLEGAL_AWAIT_IDENTIFIER);\n        }\n        let defaultValue = null;\n        if (this.eat(TokenType.ASSIGN)) {\n          defaultValue = this.parseAssignmentExpression();\n        }\n        return this.finishNode(new AST.BindingPropertyIdentifier({\n          binding,\n          init: defaultValue\n        }), startState);\n      }\n    }\n    this.expect(TokenType.COLON);\n    binding = this.parseBindingElement();\n    return this.finishNode(new AST.BindingPropertyProperty({\n      name,\n      binding\n    }), startState);\n  }\n  parseObjectBinding() {\n    let startState = this.startNode();\n    this.expect(TokenType.LBRACE);\n    let properties = [];\n    let rest = null;\n    while (!this.match(TokenType.RBRACE)) {\n      if (this.eat(TokenType.ELLIPSIS)) {\n        rest = this.parseBindingIdentifier();\n        break;\n      }\n      properties.push(this.parseBindingProperty());\n      if (!this.match(TokenType.RBRACE)) {\n        this.expect(TokenType.COMMA);\n      }\n    }\n    this.expect(TokenType.RBRACE);\n    return this.finishNode(new AST.ObjectBinding({\n      properties,\n      rest\n    }), startState);\n  }\n  parseBindingTarget() {\n    if (this.matchIdentifier()) {\n      return this.parseBindingIdentifier();\n    }\n    switch (this.lookahead.type) {\n      case TokenType.LBRACK:\n        return this.parseArrayBinding();\n      case TokenType.LBRACE:\n        return this.parseObjectBinding();\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n  parseBindingElement() {\n    let startState = this.startNode();\n    let binding = this.parseBindingTarget();\n    if (this.eat(TokenType.ASSIGN)) {\n      let init = this.parseAssignmentExpression();\n      binding = this.finishNode(new AST.BindingWithDefault({\n        binding,\n        init\n      }), startState);\n    }\n    return binding;\n  }\n  parseParam() {\n    let previousInParameter = this.inParameter;\n    this.inParameter = true;\n    let param = this.parseBindingElement();\n    this.inParameter = previousInParameter;\n    return param;\n  }\n  parseParams() {\n    let startState = this.startNode();\n    this.expect(TokenType.LPAREN);\n    let items = [],\n      rest = null;\n    while (!this.match(TokenType.RPAREN)) {\n      if (this.eat(TokenType.ELLIPSIS)) {\n        rest = this.parseBindingTarget();\n        if (this.lookahead.type === TokenType.ASSIGN) {\n          throw this.createError(ErrorMessages.UNEXPECTED_REST_PARAMETERS_INITIALIZATION);\n        }\n        if (this.match(TokenType.COMMA)) {\n          throw this.createError(ErrorMessages.UNEXPECTED_COMMA_AFTER_REST);\n        }\n        break;\n      }\n      items.push(this.parseParam());\n      if (this.match(TokenType.RPAREN)) break;\n      this.expect(TokenType.COMMA);\n    }\n    this.expect(TokenType.RPAREN);\n    return this.finishNode(new AST.FormalParameters({\n      items,\n      rest\n    }), startState);\n  }\n}\nmodule.exports = {\n  GenericParser\n};","map":{"version":3,"names":["ErrorMessages","require","acceptRegex","Tokenizer","TokenClass","TokenType","AST","ARROW_EXPRESSION_PARAMS","EXPORT_UNKNOWN_SPECIFIER","Precedence","Sequence","Yield","Assignment","Conditional","ArrowFunction","LogicalOR","LogicalAND","BitwiseOR","BitwiseXOR","BitwiseAND","Equality","Relational","BitwiseSHIFT","Additive","Multiplicative","Unary","Postfix","Call","New","TaggedTemplate","Member","Primary","BinaryPrecedence","isValidSimpleAssignmentTarget","node","type","isPrefixOperator","token","INC","DEC","ADD","SUB","BIT_NOT","NOT","DELETE","VOID","TYPEOF","isUpdateOperator","GenericParser","constructor","source","allowIn","inFunctionBody","inParameter","allowYieldExpression","allowAwaitExpression","firstAwaitLocation","module","moduleIsTheGoalSymbol","strict","isBindingElement","isAssignmentTarget","firstExprError","match","subType","lookahead","matchIdentifier","IDENTIFIER","LET","YIELD","ASYNC","AWAIT","getLocation","ESCAPED_KEYWORD","value","eat","tokenType","lex","expect","createUnexpected","matchContextualKeyword","keyword","escaped","expectContextualKeyword","eatContextualKeyword","consumeSemicolon","SEMICOLON","hasLineTerminatorBeforeNext","eof","RBRACE","startNode","copyNode","src","dest","finishNode","parseModule","advance","startState","directives","statements","parseBody","EOS","Module","items","parseScript","Script","parseFunctionBody","oldInFunctionBody","oldModule","oldStrict","LBRACE","body","FunctionBody","parsingDirectives","directiveOctal","text","slice","isStringLiteral","STRING","isModule","directiveLocation","directiveStartState","stmt","parseModuleItem","parseStatementListItem","expression","octal","createErrorWithLocation","rawValue","push","Directive","parseImportSpecifier","name","parseIdentifier","ImportSpecifier","binding","BindingIdentifier","klass","isIdentifierName","parseIdentifierName","parseBindingIdentifier","parseNameSpaceBinding","MUL","parseNamedImports","result","COMMA","parseFromClause","str","parseImportDeclaration","defaultBinding","moduleSpecifier","IMPORT","Import","namedImports","decl","ImportNamespace","namespaceBinding","parseExportSpecifier","isIdentifier","exportedName","parseExportClause","parseExportDeclaration","EXPORT","ExportAllFrom","namedExports","ExportFrom","map","e","ExportFromSpecifier","forEach","createError","ILLEGAL_EXPORTED_NAME","ExportLocals","ExportLocalSpecifier","IdentifierExpression","CLASS","Export","declaration","parseClass","isExpr","inDefault","FUNCTION","parseFunction","allowGenerator","isAsync","preAsyncStartState","DEFAULT","ExportDefault","lexerState","saveLexerState","restoreLexerState","parseAssignmentExpression","VAR","CONST","parseVariableDeclaration","lookaheadLexicalDeclaration","LBRACK","parseStatement","parseVariableDeclarationStatement","isolateCoverGrammar","parseStatementHelper","parseEmptyStatement","parseBlockStatement","LPAREN","parseExpressionStatement","BREAK","parseBreakStatement","CONTINUE","parseContinueStatement","DEBUGGER","parseDebuggerStatement","DO","parseDoWhileStatement","FOR","parseForStatement","IF","parseIfStatement","RETURN","parseReturnStatement","SWITCH","parseSwitchStatement","THROW","parseThrowStatement","TRY","parseTryStatement","WHILE","parseWhileStatement","WITH","parseWithStatement","expr","parseExpression","COLON","labeledBody","LabeledStatement","label","ExpressionStatement","EmptyStatement","BlockStatement","block","parseBlock","BreakStatement","ContinueStatement","DebuggerStatement","test","RPAREN","DoWhileStatement","isAwait","right","ForStatement","init","update","getIteratorStatementEpilogue","startsWithLet","isForDecl","leftStartState","previousAllowIn","declarators","length","IN","ctor","kind","INVALID_VAR_INIT_FOR_IN","ForInStatement","INVALID_VAR_INIT_FOR_AWAIT","INVALID_VAR_INIT_FOR_OF","ForAwaitStatement","ForOfStatement","left","some","UNINITIALIZED_BINDINGPATTERN_IN_FOR_INIT","inheritCoverGrammar","parseAssignmentExpressionOrTarget","INVALID_LHS_IN_FOR_AWAIT","INVALID_LHS_IN_FOR_OF","transformDestructuring","rhs","BinaryExpression","operator","INVALID_LHS_IN_FOR_IN","parseIfStatementChild","consequent","alternate","ELSE","IfStatement","ILLEGAL_RETURN","ReturnStatement","discriminant","SwitchStatement","cases","parseSwitchCases","defaultCase","parseSwitchDefault","postDefaultCases","MULTIPLE_DEFAULTS_IN_SWITCH","SwitchStatementWithDefault","preDefaultCases","parseSwitchCase","CASE","SwitchCase","parseSwitchCaseBody","SwitchDefault","parseStatementListInSwitchCaseBody","NEWLINE_AFTER_THROW","ThrowStatement","CATCH","catchClause","parseCatchClause","FINALLY","finalizer","TryFinallyStatement","TryCatchStatement","NO_CATCH_OR_FINALLY","VariableDeclarationStatement","WhileStatement","object","WithStatement","parseBindingTarget","CatchClause","Block","bindingPatternsMustHaveInit","parseVariableDeclaratorList","VariableDeclaration","parseVariableDeclarator","ASSIGN","VariableDeclarator","parser","oldIsBindingElement","oldIsAssignmentTarget","oldFirstExprError","call","finishArrowParams","head","params","rest","targetToBinding","FormalParameters","parseArrowExpressionTail","ARROW","previousYield","previousAwait","previousAwaitLocation","ArrowExpression","parseYieldExpression","parseConditionalExpression","isAssignmentOperator","ASSIGN_BIT_OR","ASSIGN_BIT_XOR","ASSIGN_BIT_AND","ASSIGN_SHL","ASSIGN_SHR","ASSIGN_SHR_UNSIGNED","ASSIGN_ADD","ASSIGN_SUB","ASSIGN_MUL","ASSIGN_DIV","ASSIGN_MOD","ASSIGN_EXP","INVALID_LHS_IN_ASSIGNMENT","AssignmentExpression","CompoundAssignmentExpression","ArrayBinding","elements","ObjectBinding","properties","p","BindingPropertyIdentifier","BindingPropertyProperty","BindingWithDefault","Error","AssignmentTargetPropertyProperty","transformDestructuringWithDefault","AssignmentTargetPropertyIdentifier","AssignmentTargetIdentifier","last","ObjectAssignmentTarget","ArrayAssignmentTarget","ComputedMemberAssignmentTarget","StaticMemberAssignmentTarget","property","AssignmentTargetWithDefault","lookaheadAssignmentExpression","DIV","FALSE","NEW","NULL","NUMBER","SUPER","THIS","TRUE","TEMPLATE","YieldExpression","isGenerator","YieldGeneratorExpression","parseBinaryExpression","CONDITIONAL","ConditionalExpression","isBinaryOperator","OR","AND","BIT_OR","BIT_XOR","BIT_AND","EQ","NE","EQ_STRICT","NE_STRICT","LT","GT","LTE","GTE","INSTANCEOF","SHL","SHR","SHR_UNSIGNED","MOD","parseExponentiationExpression","stack","precedence","stackItem","stackOperator","pop","reduceRight","leftIsParenthesized","parseUnaryExpression","EXP","INVALID_EXPONENTIATION_LHS","Punctuator","Keyword","parseUpdateExpression","AwaitExpression","operandStartLocation","operand","INVALID_UPDATE_OPERAND","UpdateExpression","isPrefix","UnaryExpression","startLocation","parseLeftHandSideExpression","allowCall","Super","CallExpression","callee","arguments","parseArgumentList","args","ComputedMemberExpression","parseComputedMember","PERIOD","StaticMemberExpression","parseStaticMember","parseNewExpression","parsePrimaryExpression","afterAsyncStartState","param","ensureArrow","locationFollowingFirstSpread","UNEXPECTED_TOKEN","NO_AWAIT_IN_ASYNC_PARAMS","UNEXPECTED_REST_PARAMETERS_INITIALIZATION","arg","TemplateExpression","tag","parseTemplateElements","tail","TemplateElement","createILLEGAL","index","startIndex","line","startLine","lineStart","startLineStart","scanTemplateElement","RBRACK","NewTargetExpression","NewExpression","parseRegexFlags","flags","isGlobal","ignoreCase","multiLine","unicode","sticky","dotAll","i","f","global","parseGroupExpression","parseStringLiteral","parseNumericLiteral","ThisExpression","LiteralBooleanExpression","LiteralNullExpression","parseArrayExpression","parseObjectExpression","scanRegExp","lastSlash","lastIndexOf","pattern","ctorArgs","INVALID_REGEX","LiteralRegExpExpression","noctal","LiteralInfinityExpression","LiteralNumericExpression","LiteralStringExpression","ILLEGAL_YIELD_IDENTIFIER","ILLEGAL_AWAIT_IDENTIFIER","parseArguments","ELLIPSIS","SpreadElement","UNEXPECTED_LINE_TERMINATOR","preParenStartState","start","postParenStartState","paramsNode","INVALID_REST_PARAMETERS_INITIALIZATION","INVALID_LAST_REST_PARAMETER","group","parseBindingElement","ILLEGAL_ARROW_FUNCTION_PARAMS","exprs","elementStartState","UNEXPECTED_COMMA_AFTER_REST","ArrayExpression","isSpreadProperty","spreadPropertyOrAssignmentTarget","parseSpreadPropertyDefinition","parsePropertyDefinition","INVALID_LHS_IN_BINDING","ObjectExpression","SpreadProperty","methodOrKey","parseMethodDefinition","ILLEGAL_PROPERTY","ShorthandProperty","DataProperty","parsePropertyName","StaticPropertyName","numLiteral","ComputedPropertyName","lookaheadPropertyName","preAsyncTokenState","Getter","Setter","parseParams","Method","heritage","EXTENDS","isStatic","classElementStart","ClassElement","method","ClassExpression","ClassDeclaration","super","FunctionExpression","FunctionDeclaration","parseArrayBinding","el","parseBindingProperty","defaultValue","parseObjectBinding","parseParam","previousInParameter","exports"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/shift-parser/src/parser.js"],"sourcesContent":["/**\n * Copyright 2014 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { ErrorMessages } = require('./errors');\n\nconst acceptRegex = require('shift-regexp-acceptor');\n\nconst { Tokenizer, TokenClass, TokenType } = require('./tokenizer');\n\nconst AST = require('shift-ast');\n\n// Empty parameter list for ArrowExpression\nconst ARROW_EXPRESSION_PARAMS = 'CoverParenthesizedExpressionAndArrowParameterList';\nconst EXPORT_UNKNOWN_SPECIFIER = 'ExportNameOfUnknownType';\n\nconst Precedence = {\n  Sequence: 0,\n  Yield: 1,\n  Assignment: 1,\n  Conditional: 2,\n  ArrowFunction: 2,\n  LogicalOR: 3,\n  LogicalAND: 4,\n  BitwiseOR: 5,\n  BitwiseXOR: 6,\n  BitwiseAND: 7,\n  Equality: 8,\n  Relational: 9,\n  BitwiseSHIFT: 10,\n  Additive: 11,\n  Multiplicative: 12,\n  Unary: 13,\n  Postfix: 14,\n  Call: 15,\n  New: 16,\n  TaggedTemplate: 17,\n  Member: 18,\n  Primary: 19,\n};\n\nconst BinaryPrecedence = {\n  '||': Precedence.LogicalOR,\n  '&&': Precedence.LogicalAND,\n  '|': Precedence.BitwiseOR,\n  '^': Precedence.BitwiseXOR,\n  '&': Precedence.BitwiseAND,\n  '==': Precedence.Equality,\n  '!=': Precedence.Equality,\n  '===': Precedence.Equality,\n  '!==': Precedence.Equality,\n  '<': Precedence.Relational,\n  '>': Precedence.Relational,\n  '<=': Precedence.Relational,\n  '>=': Precedence.Relational,\n  'in': Precedence.Relational,\n  'instanceof': Precedence.Relational,\n  '<<': Precedence.BitwiseSHIFT,\n  '>>': Precedence.BitwiseSHIFT,\n  '>>>': Precedence.BitwiseSHIFT,\n  '+': Precedence.Additive,\n  '-': Precedence.Additive,\n  '*': Precedence.Multiplicative,\n  '%': Precedence.Multiplicative,\n  '/': Precedence.Multiplicative,\n};\n\nfunction isValidSimpleAssignmentTarget(node) {\n  if (node == null) return false;\n  switch (node.type) {\n    case 'IdentifierExpression':\n    case 'ComputedMemberExpression':\n    case 'StaticMemberExpression':\n      return true;\n  }\n  return false;\n}\n\nfunction isPrefixOperator(token) {\n  switch (token.type) {\n    case TokenType.INC:\n    case TokenType.DEC:\n    case TokenType.ADD:\n    case TokenType.SUB:\n    case TokenType.BIT_NOT:\n    case TokenType.NOT:\n    case TokenType.DELETE:\n    case TokenType.VOID:\n    case TokenType.TYPEOF:\n      return true;\n  }\n  return false;\n}\n\nfunction isUpdateOperator(token) {\n  return token.type === TokenType.INC || token.type === TokenType.DEC;\n}\n\nclass GenericParser extends Tokenizer {\n  constructor(source) {\n    super(source);\n    this.allowIn = true;\n    this.inFunctionBody = false;\n    this.inParameter = false;\n    this.allowYieldExpression = false;\n    this.allowAwaitExpression = false;\n    this.firstAwaitLocation = null; // for forbidding `await` in async arrow params.\n    this.module = false;\n    this.moduleIsTheGoalSymbol = false;\n    this.strict = false;\n\n    // Cover grammar\n    this.isBindingElement = true;\n    this.isAssignmentTarget = true;\n    this.firstExprError = null;\n  }\n\n  match(subType) {\n    return this.lookahead.type === subType;\n  }\n\n  matchIdentifier() {\n    switch (this.lookahead.type) {\n      case TokenType.IDENTIFIER:\n      case TokenType.LET:\n      case TokenType.YIELD:\n      case TokenType.ASYNC:\n        return true;\n      case TokenType.AWAIT:\n        if (!this.moduleIsTheGoalSymbol) {\n          if (this.firstAwaitLocation === null) {\n            this.firstAwaitLocation = this.getLocation();\n          }\n          return true;\n        }\n        return false;\n      case TokenType.ESCAPED_KEYWORD:\n        if (this.lookahead.value === 'await' && !this.moduleIsTheGoalSymbol) {\n          if (this.firstAwaitLocation === null) {\n            this.firstAwaitLocation = this.getLocation();\n          }\n          return true;\n        }\n        return this.lookahead.value === 'let'\n          || this.lookahead.value === 'yield'\n          || this.lookahead.value === 'async';\n    }\n    return false;\n  }\n\n  eat(tokenType) {\n    if (this.lookahead.type === tokenType) {\n      return this.lex();\n    }\n    return null;\n  }\n\n  expect(tokenType) {\n    if (this.lookahead.type === tokenType) {\n      return this.lex();\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n\n  matchContextualKeyword(keyword) {\n    return this.lookahead.type === TokenType.IDENTIFIER && !this.lookahead.escaped && this.lookahead.value === keyword;\n  }\n\n  expectContextualKeyword(keyword) {\n    if (this.lookahead.type === TokenType.IDENTIFIER && !this.lookahead.escaped && this.lookahead.value === keyword) {\n      return this.lex();\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n\n  eatContextualKeyword(keyword) {\n    if (this.lookahead.type === TokenType.IDENTIFIER && !this.lookahead.escaped && this.lookahead.value === keyword) {\n      return this.lex();\n    }\n    return null;\n  }\n\n  consumeSemicolon() {\n    if (this.eat(TokenType.SEMICOLON)) return;\n    if (this.hasLineTerminatorBeforeNext) return;\n    if (!this.eof() && !this.match(TokenType.RBRACE)) {\n      throw this.createUnexpected(this.lookahead);\n    }\n  }\n\n  // this is a no-op, reserved for future use\n  startNode(node) {\n    return node;\n  }\n\n  copyNode(src, dest) {\n    return dest;\n  }\n\n  finishNode(node /* , startState */) {\n    return node;\n  }\n\n  parseModule() {\n    this.moduleIsTheGoalSymbol = this.module = this.strict = true;\n    this.lookahead = this.advance();\n\n    let startState = this.startNode();\n    let { directives, statements } = this.parseBody();\n    if (!this.match(TokenType.EOS)) {\n      throw this.createUnexpected(this.lookahead);\n    }\n    return this.finishNode(new AST.Module({ directives, items: statements }), startState);\n  }\n\n  parseScript() {\n    this.lookahead = this.advance();\n\n    let startState = this.startNode();\n    let { directives, statements } = this.parseBody();\n    if (!this.match(TokenType.EOS)) {\n      throw this.createUnexpected(this.lookahead);\n    }\n    return this.finishNode(new AST.Script({ directives, statements }), startState);\n  }\n\n  parseFunctionBody() {\n    let oldInFunctionBody = this.inFunctionBody;\n    let oldModule = this.module;\n    let oldStrict = this.strict;\n    this.inFunctionBody = true;\n    this.module = false;\n\n    let startState = this.startNode();\n    this.expect(TokenType.LBRACE);\n    let body = new AST.FunctionBody(this.parseBody());\n    this.expect(TokenType.RBRACE);\n    body = this.finishNode(body, startState);\n\n    this.inFunctionBody = oldInFunctionBody;\n    this.module = oldModule;\n    this.strict = oldStrict;\n\n    return body;\n  }\n\n  parseBody() {\n    let directives = [], statements = [], parsingDirectives = true, directiveOctal = null;\n\n    while (true) {\n      if (this.eof() || this.match(TokenType.RBRACE)) break;\n      let token = this.lookahead;\n      let text = token.slice.text;\n      let isStringLiteral = token.type === TokenType.STRING;\n      let isModule = this.module;\n      let directiveLocation = this.getLocation();\n      let directiveStartState = this.startNode();\n      let stmt = isModule ? this.parseModuleItem() : this.parseStatementListItem();\n      if (parsingDirectives) {\n        if (isStringLiteral && stmt.type === 'ExpressionStatement' && stmt.expression.type === 'LiteralStringExpression') {\n          if (!directiveOctal && token.octal) {\n            directiveOctal = this.createErrorWithLocation(directiveLocation, 'Unexpected legacy octal escape sequence: \\\\' + token.octal);\n          }\n          let rawValue = text.slice(1, -1);\n          if (rawValue === 'use strict') {\n            this.strict = true;\n          }\n          directives.push(this.finishNode(new AST.Directive({ rawValue }), directiveStartState));\n        } else {\n          parsingDirectives = false;\n          if (directiveOctal && this.strict) {\n            throw directiveOctal;\n          }\n          statements.push(stmt);\n        }\n      } else {\n        statements.push(stmt);\n      }\n    }\n    if (directiveOctal && this.strict) {\n      throw directiveOctal;\n    }\n\n    return { directives, statements };\n  }\n\n  parseImportSpecifier() {\n    let startState = this.startNode(), name;\n    if (this.matchIdentifier()) {\n      name = this.parseIdentifier();\n      if (!this.eatContextualKeyword('as')) {\n        return this.finishNode(new AST.ImportSpecifier({\n          name: null,\n          binding: this.finishNode(new AST.BindingIdentifier({ name }), startState),\n        }), startState);\n      }\n    } else if (this.lookahead.type.klass.isIdentifierName) {\n      name = this.parseIdentifierName();\n      this.expectContextualKeyword('as');\n    }\n\n    return this.finishNode(new AST.ImportSpecifier({ name, binding: this.parseBindingIdentifier() }), startState);\n  }\n\n  parseNameSpaceBinding() {\n    this.expect(TokenType.MUL);\n    this.expectContextualKeyword('as');\n    return this.parseBindingIdentifier();\n  }\n\n  parseNamedImports() {\n    let result = [];\n    this.expect(TokenType.LBRACE);\n    while (!this.eat(TokenType.RBRACE)) {\n      result.push(this.parseImportSpecifier());\n      if (!this.eat(TokenType.COMMA)) {\n        this.expect(TokenType.RBRACE);\n        break;\n      }\n    }\n    return result;\n  }\n\n  parseFromClause() {\n    this.expectContextualKeyword('from');\n    let value = this.expect(TokenType.STRING).str;\n    return value;\n  }\n\n  parseImportDeclaration() {\n    let startState = this.startNode(), defaultBinding = null, moduleSpecifier;\n    this.expect(TokenType.IMPORT);\n    if (this.match(TokenType.STRING)) {\n      moduleSpecifier = this.lex().str;\n      this.consumeSemicolon();\n      return this.finishNode(new AST.Import({ defaultBinding: null, namedImports: [], moduleSpecifier }), startState);\n    }\n    if (this.matchIdentifier()) {\n      defaultBinding = this.parseBindingIdentifier();\n      if (!this.eat(TokenType.COMMA)) {\n        let decl = new AST.Import({ defaultBinding, namedImports: [], moduleSpecifier: this.parseFromClause() });\n        this.consumeSemicolon();\n        return this.finishNode(decl, startState);\n      }\n    }\n    if (this.match(TokenType.MUL)) {\n      let decl = new AST.ImportNamespace({\n        defaultBinding,\n        namespaceBinding: this.parseNameSpaceBinding(),\n        moduleSpecifier: this.parseFromClause(),\n      });\n      this.consumeSemicolon();\n      return this.finishNode(decl, startState);\n    } else if (this.match(TokenType.LBRACE)) {\n      let decl = new AST.Import({\n        defaultBinding,\n        namedImports: this.parseNamedImports(),\n        moduleSpecifier: this.parseFromClause(),\n      });\n      this.consumeSemicolon();\n      return this.finishNode(decl, startState);\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n\n  parseExportSpecifier() {\n    let startState = this.startNode();\n    let name = this.finishNode({ type: EXPORT_UNKNOWN_SPECIFIER, isIdentifier: this.matchIdentifier(), value: this.parseIdentifierName() }, startState);\n    if (this.eatContextualKeyword('as')) {\n      let exportedName = this.parseIdentifierName();\n      return this.finishNode({ name, exportedName }, startState);\n    }\n    return this.finishNode({ name, exportedName: null }, startState);\n  }\n\n  parseExportClause() {\n    this.expect(TokenType.LBRACE);\n    let result = [];\n    while (!this.eat(TokenType.RBRACE)) {\n      result.push(this.parseExportSpecifier());\n      if (!this.eat(TokenType.COMMA)) {\n        this.expect(TokenType.RBRACE);\n        break;\n      }\n    }\n    return result;\n  }\n\n  parseExportDeclaration() {\n    let startState = this.startNode(), decl;\n    this.expect(TokenType.EXPORT);\n    switch (this.lookahead.type) {\n      case TokenType.MUL:\n        this.lex();\n        // export * FromClause ;\n        decl = new AST.ExportAllFrom({ moduleSpecifier: this.parseFromClause() });\n        this.consumeSemicolon();\n        break;\n      case TokenType.LBRACE: {\n        // export ExportClause FromClause ;\n        // export ExportClause ;\n        let namedExports = this.parseExportClause();\n        let moduleSpecifier = null;\n        if (this.matchContextualKeyword('from')) {\n          moduleSpecifier = this.parseFromClause();\n          decl = new AST.ExportFrom({ namedExports: namedExports.map(e => this.copyNode(e, new AST.ExportFromSpecifier({ name: e.name.value, exportedName: e.exportedName }))), moduleSpecifier });\n        } else {\n          namedExports.forEach(({ name }) => {\n            if (!name.isIdentifier) {\n              throw this.createError(ErrorMessages.ILLEGAL_EXPORTED_NAME);\n            }\n          });\n          decl = new AST.ExportLocals({ namedExports: namedExports.map(e => this.copyNode(e, new AST.ExportLocalSpecifier({ name: this.copyNode(e.name, new AST.IdentifierExpression({ name: e.name.value })), exportedName: e.exportedName }))) });\n        }\n        this.consumeSemicolon();\n        break;\n      }\n      case TokenType.CLASS:\n        // export ClassDeclaration\n        decl = new AST.Export({ declaration: this.parseClass({ isExpr: false, inDefault: false }) });\n        break;\n      case TokenType.FUNCTION:\n        // export HoistableDeclaration\n        decl = new AST.Export({ declaration: this.parseFunction({ isExpr: false, inDefault: false, allowGenerator: true, isAsync: false }) });\n        break;\n      case TokenType.ASYNC: {\n        let preAsyncStartState = this.startNode();\n        this.lex();\n        decl = new AST.Export({ declaration: this.parseFunction({ isExpr: false, inDefault: false, allowGenerator: true, isAsync: true, startState: preAsyncStartState }) });\n        break;\n      }\n      case TokenType.DEFAULT:\n        this.lex();\n        switch (this.lookahead.type) {\n          case TokenType.FUNCTION:\n            // export default HoistableDeclaration[Default]\n            decl = new AST.ExportDefault({\n              body: this.parseFunction({ isExpr: false, inDefault: true, allowGenerator: true, isAsync: false }),\n            });\n            break;\n          case TokenType.CLASS:\n            // export default ClassDeclaration[Default]\n            decl = new AST.ExportDefault({ body: this.parseClass({ isExpr: false, inDefault: true }) });\n            break;\n          case TokenType.ASYNC: {\n            let preAsyncStartState = this.startNode();\n            let lexerState = this.saveLexerState();\n            this.lex();\n            if (!this.hasLineTerminatorBeforeNext && this.match(TokenType.FUNCTION)) {\n              decl = new AST.ExportDefault({\n                body: this.parseFunction({ isExpr: false, inDefault: true, allowGenerator: false, isAsync: true, startState: preAsyncStartState }),\n              });\n              break;\n            }\n            this.restoreLexerState(lexerState);\n          }\n          // else fall through\n          default:\n            // export default [lookahead ∉ {function, async [no LineTerminatorHere] function, class}] AssignmentExpression[In] ;\n            decl = new AST.ExportDefault({ body: this.parseAssignmentExpression() });\n            this.consumeSemicolon();\n            break;\n        }\n        break;\n      case TokenType.VAR:\n      case TokenType.LET:\n      case TokenType.CONST:\n        // export LexicalDeclaration\n        decl = new AST.Export({ declaration: this.parseVariableDeclaration(true) });\n        this.consumeSemicolon();\n        break;\n      default:\n        throw this.createUnexpected(this.lookahead);\n    }\n    return this.finishNode(decl, startState);\n  }\n\n  parseModuleItem() {\n    switch (this.lookahead.type) {\n      case TokenType.IMPORT:\n        return this.parseImportDeclaration();\n      case TokenType.EXPORT:\n        return this.parseExportDeclaration();\n      default:\n        return this.parseStatementListItem();\n    }\n  }\n\n  lookaheadLexicalDeclaration() {\n    if (this.match(TokenType.LET) || this.match(TokenType.CONST)) {\n      let lexerState = this.saveLexerState();\n      this.lex();\n      if (\n        this.matchIdentifier() ||\n        this.match(TokenType.LBRACE) ||\n        this.match(TokenType.LBRACK)\n      ) {\n        this.restoreLexerState(lexerState);\n        return true;\n      }\n      this.restoreLexerState(lexerState);\n    }\n    return false;\n  }\n\n  parseStatementListItem() {\n    if (this.eof()) throw this.createUnexpected(this.lookahead);\n\n    switch (this.lookahead.type) {\n      case TokenType.FUNCTION:\n        return this.parseFunction({ isExpr: false, inDefault: false, allowGenerator: true, isAsync: false });\n      case TokenType.CLASS:\n        return this.parseClass({ isExpr: false, inDefault: false });\n      case TokenType.ASYNC: {\n        let preAsyncStartState = this.getLocation();\n        let lexerState = this.saveLexerState();\n        this.lex();\n        if (!this.hasLineTerminatorBeforeNext && this.match(TokenType.FUNCTION)) {\n          return this.parseFunction({ isExpr: false, inDefault: false, allowGenerator: true, isAsync: true, startState: preAsyncStartState });\n        }\n        this.restoreLexerState(lexerState);\n        return this.parseStatement();\n      }\n      default:\n        if (this.lookaheadLexicalDeclaration()) {\n          let startState = this.startNode();\n          return this.finishNode(this.parseVariableDeclarationStatement(), startState);\n        }\n        return this.parseStatement();\n    }\n  }\n\n  parseStatement() {\n    let startState = this.startNode();\n    let stmt = this.isolateCoverGrammar(this.parseStatementHelper);\n    return this.finishNode(stmt, startState);\n  }\n\n  parseStatementHelper() {\n    if (this.eof()) {\n      throw this.createUnexpected(this.lookahead);\n    }\n\n    switch (this.lookahead.type) {\n      case TokenType.SEMICOLON:\n        return this.parseEmptyStatement();\n      case TokenType.LBRACE:\n        return this.parseBlockStatement();\n      case TokenType.LPAREN:\n        return this.parseExpressionStatement();\n      case TokenType.BREAK:\n        return this.parseBreakStatement();\n      case TokenType.CONTINUE:\n        return this.parseContinueStatement();\n      case TokenType.DEBUGGER:\n        return this.parseDebuggerStatement();\n      case TokenType.DO:\n        return this.parseDoWhileStatement();\n      case TokenType.FOR:\n        return this.parseForStatement();\n      case TokenType.IF:\n        return this.parseIfStatement();\n      case TokenType.RETURN:\n        return this.parseReturnStatement();\n      case TokenType.SWITCH:\n        return this.parseSwitchStatement();\n      case TokenType.THROW:\n        return this.parseThrowStatement();\n      case TokenType.TRY:\n        return this.parseTryStatement();\n      case TokenType.VAR:\n        return this.parseVariableDeclarationStatement();\n      case TokenType.WHILE:\n        return this.parseWhileStatement();\n      case TokenType.WITH:\n        return this.parseWithStatement();\n      case TokenType.FUNCTION:\n      case TokenType.CLASS:\n        throw this.createUnexpected(this.lookahead);\n\n      default: {\n        let lexerState = this.saveLexerState();\n        if (this.eat(TokenType.LET)) {\n          if (this.match(TokenType.LBRACK)) {\n            this.restoreLexerState(lexerState);\n            throw this.createUnexpected(this.lookahead);\n          }\n          this.restoreLexerState(lexerState);\n        } else if (this.eat(TokenType.ASYNC)) {\n          if (!this.hasLineTerminatorBeforeNext && this.match(TokenType.FUNCTION)) {\n            throw this.createUnexpected(this.lookahead);\n          }\n          this.restoreLexerState(lexerState);\n        }\n        let expr = this.parseExpression();\n        // 12.12 Labelled Statements;\n        if (expr.type === 'IdentifierExpression' && this.eat(TokenType.COLON)) {\n          let labeledBody = this.match(TokenType.FUNCTION)\n            ? this.parseFunction({ isExpr: false, inDefault: false, allowGenerator: false, isAsync: false })\n            : this.parseStatement();\n          return new AST.LabeledStatement({ label: expr.name, body: labeledBody });\n        }\n        this.consumeSemicolon();\n        return new AST.ExpressionStatement({ expression: expr });\n      }\n    }\n  }\n\n  parseEmptyStatement() {\n    this.lex();\n    return new AST.EmptyStatement;\n  }\n\n  parseBlockStatement() {\n    return new AST.BlockStatement({ block: this.parseBlock() });\n  }\n\n  parseExpressionStatement() {\n    let expr = this.parseExpression();\n    this.consumeSemicolon();\n    return new AST.ExpressionStatement({ expression: expr });\n  }\n\n  parseBreakStatement() {\n    this.lex();\n\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (this.eat(TokenType.SEMICOLON) || this.hasLineTerminatorBeforeNext) {\n      return new AST.BreakStatement({ label: null });\n    }\n\n    let label = null;\n    if (this.matchIdentifier()) {\n      label = this.parseIdentifier();\n    }\n\n    this.consumeSemicolon();\n\n    return new AST.BreakStatement({ label });\n  }\n\n  parseContinueStatement() {\n    this.lex();\n\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (this.eat(TokenType.SEMICOLON) || this.hasLineTerminatorBeforeNext) {\n      return new AST.ContinueStatement({ label: null });\n    }\n\n    let label = null;\n    if (this.matchIdentifier()) {\n      label = this.parseIdentifier();\n    }\n\n    this.consumeSemicolon();\n\n    return new AST.ContinueStatement({ label });\n  }\n\n\n  parseDebuggerStatement() {\n    this.lex();\n    this.consumeSemicolon();\n    return new AST.DebuggerStatement;\n  }\n\n  parseDoWhileStatement() {\n    this.lex();\n    let body = this.parseStatement();\n    this.expect(TokenType.WHILE);\n    this.expect(TokenType.LPAREN);\n    let test = this.parseExpression();\n    this.expect(TokenType.RPAREN);\n    this.eat(TokenType.SEMICOLON);\n    return new AST.DoWhileStatement({ body, test });\n  }\n\n  parseForStatement() {\n    this.lex();\n    let isAwait = this.allowAwaitExpression && this.eat(TokenType.AWAIT);\n    this.expect(TokenType.LPAREN);\n    let test = null;\n    let right = null;\n    if (isAwait && this.match(TokenType.SEMICOLON)) {\n      throw this.createUnexpected(this.lookahead);\n    }\n    if (this.eat(TokenType.SEMICOLON)) {\n      if (!this.match(TokenType.SEMICOLON)) {\n        test = this.parseExpression();\n      }\n      this.expect(TokenType.SEMICOLON);\n      if (!this.match(TokenType.RPAREN)) {\n        right = this.parseExpression();\n      }\n      return new AST.ForStatement({ init: null, test, update: right, body: this.getIteratorStatementEpilogue() });\n    }\n    let startsWithLet = this.match(TokenType.LET);\n    let isForDecl = this.lookaheadLexicalDeclaration();\n    let leftStartState = this.startNode();\n    if (this.match(TokenType.VAR) || isForDecl) {\n      let previousAllowIn = this.allowIn;\n      this.allowIn = false;\n      let init = this.parseVariableDeclaration(false);\n      this.allowIn = previousAllowIn;\n\n      if (init.declarators.length === 1 && (this.match(TokenType.IN) || this.matchContextualKeyword('of'))) {\n        let ctor;\n        let decl = init.declarators[0];\n\n        if (this.match(TokenType.IN)) {\n          if (isAwait) {\n            throw this.createUnexpected(this.lookahead);\n          }\n          if (decl.init !== null && (this.strict || init.kind !== 'var' || decl.binding.type !== 'BindingIdentifier')) {\n            throw this.createError(ErrorMessages.INVALID_VAR_INIT_FOR_IN);\n          }\n          ctor = AST.ForInStatement;\n          this.lex();\n          right = this.parseExpression();\n        } else {\n          if (decl.init !== null) {\n            throw this.createError(isAwait ? ErrorMessages.INVALID_VAR_INIT_FOR_AWAIT : ErrorMessages.INVALID_VAR_INIT_FOR_OF);\n          }\n          if (isAwait) {\n            ctor = AST.ForAwaitStatement;\n          } else {\n            ctor = AST.ForOfStatement;\n          }\n          this.lex();\n          right = this.parseAssignmentExpression();\n        }\n\n        let body = this.getIteratorStatementEpilogue();\n\n        return new ctor({ left: init, right, body });\n      } else if (isAwait) {\n        throw this.createUnexpected(this.lookahead);\n      }\n      this.expect(TokenType.SEMICOLON);\n      if (init.declarators.some(decl => decl.binding.type !== 'BindingIdentifier' && decl.init === null)) {\n        throw this.createError(ErrorMessages.UNINITIALIZED_BINDINGPATTERN_IN_FOR_INIT);\n      }\n      if (!this.match(TokenType.SEMICOLON)) {\n        test = this.parseExpression();\n      }\n      this.expect(TokenType.SEMICOLON);\n      if (!this.match(TokenType.RPAREN)) {\n        right = this.parseExpression();\n      }\n      return new AST.ForStatement({ init, test, update: right, body: this.getIteratorStatementEpilogue() });\n\n    }\n    let previousAllowIn = this.allowIn;\n    this.allowIn = false;\n    let expr = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n    this.allowIn = previousAllowIn;\n\n    if (this.isAssignmentTarget && expr.type !== 'AssignmentExpression' && (this.match(TokenType.IN) || this.matchContextualKeyword('of'))) {\n      if (expr.type === 'ObjectAssignmentTarget' || expr.type === 'ArrayAssignmentTarget') {\n        this.firstExprError = null;\n      }\n      if (startsWithLet && this.matchContextualKeyword('of')) {\n        throw this.createError(isAwait ? ErrorMessages.INVALID_LHS_IN_FOR_AWAIT : ErrorMessages.INVALID_LHS_IN_FOR_OF);\n      }\n      let ctor;\n      if (this.match(TokenType.IN)) {\n        if (isAwait) {\n          throw this.createUnexpected(this.lookahead);\n        }\n        ctor = AST.ForInStatement;\n        this.lex();\n        right = this.parseExpression();\n      } else {\n        if (isAwait) {\n          ctor = AST.ForAwaitStatement;\n        } else {\n          ctor = AST.ForOfStatement;\n        }\n        this.lex();\n        right = this.parseAssignmentExpression();\n      }\n\n      return new ctor({ left: this.transformDestructuring(expr), right, body: this.getIteratorStatementEpilogue() });\n    } else if (isAwait) {\n      throw this.createError(ErrorMessages.INVALID_LHS_IN_FOR_AWAIT);\n    }\n    if (this.firstExprError) {\n      throw this.firstExprError;\n    }\n    while (this.eat(TokenType.COMMA)) {\n      let rhs = this.parseAssignmentExpression();\n      expr = this.finishNode(new AST.BinaryExpression({ left: expr, operator: ',', right: rhs }), leftStartState);\n    }\n    if (this.match(TokenType.IN)) {\n      throw this.createError(ErrorMessages.INVALID_LHS_IN_FOR_IN);\n    }\n    if (this.matchContextualKeyword('of')) {\n      throw this.createError(ErrorMessages.INVALID_LHS_IN_FOR_OF);\n    }\n    this.expect(TokenType.SEMICOLON);\n    if (!this.match(TokenType.SEMICOLON)) {\n      test = this.parseExpression();\n    }\n    this.expect(TokenType.SEMICOLON);\n    if (!this.match(TokenType.RPAREN)) {\n      right = this.parseExpression();\n    }\n    return new AST.ForStatement({ init: expr, test, update: right, body: this.getIteratorStatementEpilogue() });\n  }\n\n  getIteratorStatementEpilogue() {\n    this.expect(TokenType.RPAREN);\n    let body = this.parseStatement();\n    return body;\n  }\n\n  parseIfStatementChild() {\n    return this.match(TokenType.FUNCTION)\n      ? this.parseFunction({ isExpr: false, inDefault: false, allowGenerator: false, isAsync: false })\n      : this.parseStatement();\n  }\n\n  parseIfStatement() {\n    this.lex();\n    this.expect(TokenType.LPAREN);\n    let test = this.parseExpression();\n    this.expect(TokenType.RPAREN);\n    let consequent = this.parseIfStatementChild();\n    let alternate = null;\n    if (this.eat(TokenType.ELSE)) {\n      alternate = this.parseIfStatementChild();\n    }\n    return new AST.IfStatement({ test, consequent, alternate });\n  }\n\n  parseReturnStatement() {\n    if (!this.inFunctionBody) {\n      throw this.createError(ErrorMessages.ILLEGAL_RETURN);\n    }\n\n    this.lex();\n\n    // Catch the very common case first: immediately a semicolon (U+003B).\n    if (this.eat(TokenType.SEMICOLON) || this.hasLineTerminatorBeforeNext) {\n      return new AST.ReturnStatement({ expression: null });\n    }\n\n    let expression = null;\n    if (!this.match(TokenType.RBRACE) && !this.eof()) {\n      expression = this.parseExpression();\n    }\n\n    this.consumeSemicolon();\n    return new AST.ReturnStatement({ expression });\n  }\n\n  parseSwitchStatement() {\n    this.lex();\n    this.expect(TokenType.LPAREN);\n    let discriminant = this.parseExpression();\n    this.expect(TokenType.RPAREN);\n    this.expect(TokenType.LBRACE);\n\n    if (this.eat(TokenType.RBRACE)) {\n      return new AST.SwitchStatement({ discriminant, cases: [] });\n    }\n\n    let cases = this.parseSwitchCases();\n    if (this.match(TokenType.DEFAULT)) {\n      let defaultCase = this.parseSwitchDefault();\n      let postDefaultCases = this.parseSwitchCases();\n      if (this.match(TokenType.DEFAULT)) {\n        throw this.createError(ErrorMessages.MULTIPLE_DEFAULTS_IN_SWITCH);\n      }\n      this.expect(TokenType.RBRACE);\n      return new AST.SwitchStatementWithDefault({\n        discriminant,\n        preDefaultCases: cases,\n        defaultCase,\n        postDefaultCases,\n      });\n    }\n    this.expect(TokenType.RBRACE);\n    return new AST.SwitchStatement({ discriminant, cases });\n  }\n\n  parseSwitchCases() {\n    let result = [];\n    while (!(this.eof() || this.match(TokenType.RBRACE) || this.match(TokenType.DEFAULT))) {\n      result.push(this.parseSwitchCase());\n    }\n    return result;\n  }\n\n  parseSwitchCase() {\n    let startState = this.startNode();\n    this.expect(TokenType.CASE);\n    return this.finishNode(new AST.SwitchCase({\n      test: this.parseExpression(),\n      consequent: this.parseSwitchCaseBody(),\n    }), startState);\n  }\n\n  parseSwitchDefault() {\n    let startState = this.startNode();\n    this.expect(TokenType.DEFAULT);\n    return this.finishNode(new AST.SwitchDefault({ consequent: this.parseSwitchCaseBody() }), startState);\n  }\n\n  parseSwitchCaseBody() {\n    this.expect(TokenType.COLON);\n    return this.parseStatementListInSwitchCaseBody();\n  }\n\n  parseStatementListInSwitchCaseBody() {\n    let result = [];\n    while (!(this.eof() || this.match(TokenType.RBRACE) || this.match(TokenType.DEFAULT) || this.match(TokenType.CASE))) {\n      result.push(this.parseStatementListItem());\n    }\n    return result;\n  }\n\n  parseThrowStatement() {\n    let token = this.lex();\n    if (this.hasLineTerminatorBeforeNext) {\n      throw this.createErrorWithLocation(token, ErrorMessages.NEWLINE_AFTER_THROW);\n    }\n    let expression = this.parseExpression();\n    this.consumeSemicolon();\n    return new AST.ThrowStatement({ expression });\n  }\n\n  parseTryStatement() {\n    this.lex();\n    let body = this.parseBlock();\n\n    if (this.match(TokenType.CATCH)) {\n      let catchClause = this.parseCatchClause();\n      if (this.eat(TokenType.FINALLY)) {\n        let finalizer = this.parseBlock();\n        return new AST.TryFinallyStatement({ body, catchClause, finalizer });\n      }\n      return new AST.TryCatchStatement({ body, catchClause });\n    }\n\n    if (this.eat(TokenType.FINALLY)) {\n      let finalizer = this.parseBlock();\n      return new AST.TryFinallyStatement({ body, catchClause: null, finalizer });\n    }\n    throw this.createError(ErrorMessages.NO_CATCH_OR_FINALLY);\n  }\n\n  parseVariableDeclarationStatement() {\n    let declaration = this.parseVariableDeclaration(true);\n    this.consumeSemicolon();\n    return new AST.VariableDeclarationStatement({ declaration });\n  }\n\n  parseWhileStatement() {\n    this.lex();\n    this.expect(TokenType.LPAREN);\n    let test = this.parseExpression();\n    let body = this.getIteratorStatementEpilogue();\n    return new AST.WhileStatement({ test, body });\n  }\n\n  parseWithStatement() {\n    this.lex();\n    this.expect(TokenType.LPAREN);\n    let object = this.parseExpression();\n    this.expect(TokenType.RPAREN);\n    let body = this.parseStatement();\n    return new AST.WithStatement({ object, body });\n  }\n\n  parseCatchClause() {\n    let startState = this.startNode();\n\n    this.lex();\n\n    let binding = null;\n\n    // Catch binding is optional\n    if (this.match(TokenType.LPAREN)) {\n      this.lex();\n      if (this.match(TokenType.RPAREN) || this.match(TokenType.LPAREN)) {\n        throw this.createUnexpected(this.lookahead);\n      }\n      binding = this.parseBindingTarget();\n      this.expect(TokenType.RPAREN);\n    }\n\n    let body = this.parseBlock();\n\n    return this.finishNode(new AST.CatchClause({ binding, body }), startState);\n  }\n\n  parseBlock() {\n    let startState = this.startNode();\n    this.expect(TokenType.LBRACE);\n    let body = [];\n    while (!this.match(TokenType.RBRACE)) {\n      body.push(this.parseStatementListItem());\n    }\n    this.expect(TokenType.RBRACE);\n    return this.finishNode(new AST.Block({ statements: body }), startState);\n  }\n\n  parseVariableDeclaration(bindingPatternsMustHaveInit) {\n    let startState = this.startNode();\n    let token = this.lex();\n\n    // preceded by this.match(TokenSubType.VAR) || this.match(TokenSubType.LET);\n    let kind = token.type === TokenType.VAR ? 'var' : token.type === TokenType.CONST ? 'const' : 'let';\n    let declarators = this.parseVariableDeclaratorList(bindingPatternsMustHaveInit);\n    return this.finishNode(new AST.VariableDeclaration({ kind, declarators }), startState);\n  }\n\n  parseVariableDeclaratorList(bindingPatternsMustHaveInit) {\n    let result = [];\n    do {\n      result.push(this.parseVariableDeclarator(bindingPatternsMustHaveInit));\n    } while (this.eat(TokenType.COMMA));\n    return result;\n  }\n\n  parseVariableDeclarator(bindingPatternsMustHaveInit) {\n    let startState = this.startNode();\n\n    if (this.match(TokenType.LPAREN)) {\n      throw this.createUnexpected(this.lookahead);\n    }\n\n    let previousAllowIn = this.allowIn;\n    this.allowIn = true;\n    let binding = this.parseBindingTarget();\n    this.allowIn = previousAllowIn;\n\n    if (bindingPatternsMustHaveInit && binding.type !== 'BindingIdentifier' && !this.match(TokenType.ASSIGN)) {\n      this.expect(TokenType.ASSIGN);\n    }\n\n    let init = null;\n    if (this.eat(TokenType.ASSIGN)) {\n      init = this.parseAssignmentExpression();\n    }\n\n    return this.finishNode(new AST.VariableDeclarator({ binding, init }), startState);\n  }\n\n  isolateCoverGrammar(parser) {\n    let oldIsBindingElement = this.isBindingElement,\n        oldIsAssignmentTarget = this.isAssignmentTarget,\n        oldFirstExprError = this.firstExprError,\n        result;\n    this.isBindingElement = this.isAssignmentTarget = true;\n    this.firstExprError = null;\n    result = parser.call(this);\n    if (this.firstExprError !== null) {\n      throw this.firstExprError;\n    }\n    this.isBindingElement = oldIsBindingElement;\n    this.isAssignmentTarget = oldIsAssignmentTarget;\n    this.firstExprError = oldFirstExprError;\n    return result;\n  }\n\n  inheritCoverGrammar(parser) {\n    let oldIsBindingElement = this.isBindingElement,\n        oldIsAssignmentTarget = this.isAssignmentTarget,\n        oldFirstExprError = this.firstExprError,\n        result;\n    this.isBindingElement = this.isAssignmentTarget = true;\n    this.firstExprError = null;\n    result = parser.call(this);\n    this.isBindingElement = this.isBindingElement && oldIsBindingElement;\n    this.isAssignmentTarget = this.isAssignmentTarget && oldIsAssignmentTarget;\n    this.firstExprError = oldFirstExprError || this.firstExprError;\n    return result;\n  }\n\n  parseExpression() {\n    let startState = this.startNode();\n\n    let left = this.parseAssignmentExpression();\n    if (this.match(TokenType.COMMA)) {\n      while (!this.eof()) {\n        if (!this.match(TokenType.COMMA)) break;\n        this.lex();\n        let right = this.parseAssignmentExpression();\n        left = this.finishNode(new AST.BinaryExpression({ left, operator: ',', right }), startState);\n      }\n    }\n    return left;\n  }\n\n  finishArrowParams(head) {\n    let { params = null, rest = null } = head;\n    if (head.type !== ARROW_EXPRESSION_PARAMS) {\n      if (head.type === 'IdentifierExpression') {\n        params = [this.targetToBinding(this.transformDestructuring(head))];\n      } else {\n        throw this.createUnexpected(this.lookahead);\n      }\n    }\n    return this.copyNode(head, new AST.FormalParameters({ items: params, rest }));\n  }\n\n  parseArrowExpressionTail(params, isAsync, startState) {\n    this.expect(TokenType.ARROW);\n    let previousYield = this.allowYieldExpression;\n    let previousAwait = this.allowAwaitExpression;\n    let previousAwaitLocation = this.firstAwaitLocation;\n    this.allowYieldExpression = false;\n    this.allowAwaitExpression = isAsync;\n    this.firstAwaitLocation = null;\n    let body;\n    if (this.match(TokenType.LBRACE)) {\n      let previousAllowIn = this.allowIn;\n      this.allowIn = true;\n      body = this.parseFunctionBody();\n      this.allowIn = previousAllowIn;\n    } else {\n      body = this.parseAssignmentExpression();\n    }\n    this.allowYieldExpression = previousYield;\n    this.allowAwaitExpression = previousAwait;\n    this.firstAwaitLocation = previousAwaitLocation;\n    return this.finishNode(new AST.ArrowExpression({ isAsync, params, body }), startState);\n  }\n\n  parseAssignmentExpression() {\n    return this.isolateCoverGrammar(this.parseAssignmentExpressionOrTarget);\n  }\n\n  parseAssignmentExpressionOrTarget() {\n    let startState = this.startNode();\n    if (this.allowYieldExpression && this.match(TokenType.YIELD)) {\n      this.isBindingElement = this.isAssignmentTarget = false;\n      return this.parseYieldExpression();\n    }\n    let expr = this.parseConditionalExpression();\n    if (!this.hasLineTerminatorBeforeNext && this.match(TokenType.ARROW)) {\n      this.isBindingElement = this.isAssignmentTarget = false;\n      this.firstExprError = null;\n      let isAsync = expr.type === ARROW_EXPRESSION_PARAMS && expr.isAsync;\n      return this.parseArrowExpressionTail(this.finishArrowParams(expr), isAsync, startState);\n    }\n    let isAssignmentOperator = false;\n    let operator = this.lookahead;\n    switch (operator.type) {\n      case TokenType.ASSIGN_BIT_OR:\n      case TokenType.ASSIGN_BIT_XOR:\n      case TokenType.ASSIGN_BIT_AND:\n      case TokenType.ASSIGN_SHL:\n      case TokenType.ASSIGN_SHR:\n      case TokenType.ASSIGN_SHR_UNSIGNED:\n      case TokenType.ASSIGN_ADD:\n      case TokenType.ASSIGN_SUB:\n      case TokenType.ASSIGN_MUL:\n      case TokenType.ASSIGN_DIV:\n      case TokenType.ASSIGN_MOD:\n      case TokenType.ASSIGN_EXP:\n        isAssignmentOperator = true;\n        break;\n    }\n    if (isAssignmentOperator) {\n      if (!this.isAssignmentTarget || !isValidSimpleAssignmentTarget(expr)) {\n        throw this.createError(ErrorMessages.INVALID_LHS_IN_ASSIGNMENT);\n      }\n      expr = this.transformDestructuring(expr);\n    } else if (operator.type === TokenType.ASSIGN) {\n      if (!this.isAssignmentTarget) {\n        throw this.createError(ErrorMessages.INVALID_LHS_IN_ASSIGNMENT);\n      }\n      expr = this.transformDestructuring(expr);\n    } else {\n      return expr;\n    }\n    this.lex();\n    let rhs = this.parseAssignmentExpression();\n\n    this.firstExprError = null;\n    let node;\n    if (operator.type === TokenType.ASSIGN) {\n      node = new AST.AssignmentExpression({ binding: expr, expression: rhs });\n    } else {\n      node = new AST.CompoundAssignmentExpression({ binding: expr, operator: operator.type.name, expression: rhs });\n      this.isBindingElement = this.isAssignmentTarget = false;\n    }\n    return this.finishNode(node, startState);\n  }\n\n  targetToBinding(node) {\n    if (node === null) {\n      return null;\n    }\n\n    switch (node.type) {\n      case 'AssignmentTargetIdentifier':\n        return this.copyNode(node, new AST.BindingIdentifier({ name: node.name }));\n      case 'ArrayAssignmentTarget':\n        return this.copyNode(node, new AST.ArrayBinding({ elements: node.elements.map(e => this.targetToBinding(e)), rest: this.targetToBinding(node.rest) }));\n      case 'ObjectAssignmentTarget':\n        return this.copyNode(node, new AST.ObjectBinding({ properties: node.properties.map(p => this.targetToBinding(p)), rest: this.targetToBinding(node.rest) }));\n      case 'AssignmentTargetPropertyIdentifier':\n        return this.copyNode(node, new AST.BindingPropertyIdentifier({ binding: this.targetToBinding(node.binding), init: node.init }));\n      case 'AssignmentTargetPropertyProperty':\n        return this.copyNode(node, new AST.BindingPropertyProperty({ name: node.name, binding: this.targetToBinding(node.binding) }));\n      case 'AssignmentTargetWithDefault':\n        return this.copyNode(node, new AST.BindingWithDefault({ binding: this.targetToBinding(node.binding), init: node.init }));\n    }\n\n    // istanbul ignore next\n    throw new Error('Not reached');\n  }\n\n  transformDestructuring(node) {\n    switch (node.type) {\n\n      case 'DataProperty':\n        return this.copyNode(node, new AST.AssignmentTargetPropertyProperty({\n          name: node.name,\n          binding: this.transformDestructuringWithDefault(node.expression),\n        }));\n      case 'ShorthandProperty':\n        return this.copyNode(node, new AST.AssignmentTargetPropertyIdentifier({\n          binding: this.copyNode(node, new AST.AssignmentTargetIdentifier({ name: node.name.name })),\n          init: null,\n        }));\n\n      case 'ObjectExpression': {\n        let last = node.properties.length > 0 ? node.properties[node.properties.length - 1] : void 0;\n        if (last != null && last.type === 'SpreadProperty') {\n          return this.copyNode(node, new AST.ObjectAssignmentTarget({\n            properties: node.properties.slice(0, -1).map(e => e && this.transformDestructuringWithDefault(e)),\n            rest: this.transformDestructuring(last.expression),\n          }));\n        }\n\n        return this.copyNode(node, new AST.ObjectAssignmentTarget({\n          properties: node.properties.map(e => e && this.transformDestructuringWithDefault(e)),\n          rest: null,\n        }));\n      }\n      case 'ArrayExpression': {\n        let last = node.elements[node.elements.length - 1];\n        if (last != null && last.type === 'SpreadElement') {\n          return this.copyNode(node, new AST.ArrayAssignmentTarget({\n            elements: node.elements.slice(0, -1).map(e => e && this.transformDestructuringWithDefault(e)),\n            rest: this.copyNode(last.expression, this.transformDestructuring(last.expression)),\n          }));\n        }\n        return this.copyNode(node, new AST.ArrayAssignmentTarget({\n          elements: node.elements.map(e => e && this.transformDestructuringWithDefault(e)),\n          rest: null,\n        }));\n      }\n      case 'IdentifierExpression':\n        return this.copyNode(node, new AST.AssignmentTargetIdentifier({ name: node.name }));\n\n      case 'StaticPropertyName':\n        return this.copyNode(node, new AST.AssignmentTargetIdentifier({ name: node.value }));\n\n      case 'ComputedMemberExpression':\n        return this.copyNode(node, new AST.ComputedMemberAssignmentTarget({ object: node.object, expression: node.expression }));\n      case 'StaticMemberExpression':\n        return this.copyNode(node, new AST.StaticMemberAssignmentTarget({ object: node.object, property: node.property }));\n\n      case 'ArrayAssignmentTarget':\n      case 'ObjectAssignmentTarget':\n      case 'ComputedMemberAssignmentTarget':\n      case 'StaticMemberAssignmentTarget':\n      case 'AssignmentTargetIdentifier':\n      case 'AssignmentTargetPropertyIdentifier':\n      case 'AssignmentTargetPropertyProperty':\n      case 'AssignmentTargetWithDefault':\n        return node;\n    }\n    // istanbul ignore next\n    throw new Error('Not reached');\n  }\n\n  transformDestructuringWithDefault(node) {\n    switch (node.type) {\n      case 'AssignmentExpression':\n        return this.copyNode(node, new AST.AssignmentTargetWithDefault({\n          binding: this.transformDestructuring(node.binding),\n          init: node.expression,\n        }));\n    }\n    return this.transformDestructuring(node);\n  }\n\n  lookaheadAssignmentExpression() {\n    if (this.matchIdentifier()) {\n      return true;\n    }\n    switch (this.lookahead.type) {\n      case TokenType.ADD:\n      case TokenType.ASSIGN_DIV:\n      case TokenType.BIT_NOT:\n      case TokenType.CLASS:\n      case TokenType.DEC:\n      case TokenType.DELETE:\n      case TokenType.DIV:\n      case TokenType.FALSE:\n      case TokenType.FUNCTION:\n      case TokenType.INC:\n      case TokenType.LBRACE:\n      case TokenType.LBRACK:\n      case TokenType.LPAREN:\n      case TokenType.NEW:\n      case TokenType.NOT:\n      case TokenType.NULL:\n      case TokenType.NUMBER:\n      case TokenType.STRING:\n      case TokenType.SUB:\n      case TokenType.SUPER:\n      case TokenType.THIS:\n      case TokenType.TRUE:\n      case TokenType.TYPEOF:\n      case TokenType.VOID:\n      case TokenType.TEMPLATE:\n        return true;\n    }\n    return false;\n  }\n\n  parseYieldExpression() {\n    let startState = this.startNode();\n\n    this.lex();\n    if (this.hasLineTerminatorBeforeNext) {\n      return this.finishNode(new AST.YieldExpression({ expression: null }), startState);\n    }\n    let isGenerator = !!this.eat(TokenType.MUL);\n    let expr = null;\n    if (isGenerator || this.lookaheadAssignmentExpression()) {\n      expr = this.parseAssignmentExpression();\n    }\n    let ctor = isGenerator ? AST.YieldGeneratorExpression : AST.YieldExpression;\n    return this.finishNode(new ctor({ expression: expr }), startState);\n  }\n\n  parseConditionalExpression() {\n    let startState = this.startNode();\n    let test = this.parseBinaryExpression();\n    if (this.firstExprError) return test;\n    if (this.eat(TokenType.CONDITIONAL)) {\n      this.isBindingElement = this.isAssignmentTarget = false;\n      let previousAllowIn = this.allowIn;\n      this.allowIn = true;\n      let consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);\n      this.allowIn = previousAllowIn;\n      this.expect(TokenType.COLON);\n      let alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);\n      return this.finishNode(new AST.ConditionalExpression({ test, consequent, alternate }), startState);\n    }\n    return test;\n  }\n\n  isBinaryOperator(type) {\n    switch (type) {\n      case TokenType.OR:\n      case TokenType.AND:\n      case TokenType.BIT_OR:\n      case TokenType.BIT_XOR:\n      case TokenType.BIT_AND:\n      case TokenType.EQ:\n      case TokenType.NE:\n      case TokenType.EQ_STRICT:\n      case TokenType.NE_STRICT:\n      case TokenType.LT:\n      case TokenType.GT:\n      case TokenType.LTE:\n      case TokenType.GTE:\n      case TokenType.INSTANCEOF:\n      case TokenType.SHL:\n      case TokenType.SHR:\n      case TokenType.SHR_UNSIGNED:\n      case TokenType.ADD:\n      case TokenType.SUB:\n      case TokenType.MUL:\n      case TokenType.DIV:\n      case TokenType.MOD:\n        return true;\n      case TokenType.IN:\n        return this.allowIn;\n      default:\n        return false;\n    }\n  }\n\n  parseBinaryExpression() {\n    let startState = this.startNode();\n    let left = this.parseExponentiationExpression();\n    if (this.firstExprError) {\n      return left;\n    }\n\n    let operator = this.lookahead.type;\n    if (!this.isBinaryOperator(operator)) return left;\n\n    this.isBindingElement = this.isAssignmentTarget = false;\n\n    this.lex();\n    let stack = [];\n    stack.push({ startState, left, operator, precedence: BinaryPrecedence[operator.name] });\n    startState = this.startNode();\n    let right = this.isolateCoverGrammar(this.parseExponentiationExpression);\n    operator = this.lookahead.type;\n    while (this.isBinaryOperator(operator)) {\n      let precedence = BinaryPrecedence[operator.name];\n      // Reduce: make a binary expression from the three topmost entries.\n      while (stack.length && precedence <= stack[stack.length - 1].precedence) {\n        let stackItem = stack[stack.length - 1];\n        let stackOperator = stackItem.operator;\n        left = stackItem.left;\n        stack.pop();\n        startState = stackItem.startState;\n        right = this.finishNode(new AST.BinaryExpression({ left, operator: stackOperator.name, right }), startState);\n      }\n\n      this.lex();\n      stack.push({ startState, left: right, operator, precedence });\n\n      startState = this.startNode();\n      right = this.isolateCoverGrammar(this.parseExponentiationExpression);\n      operator = this.lookahead.type;\n    }\n\n    // Final reduce to clean-up the stack.\n    return stack.reduceRight((expr, stackItem) =>\n      this.finishNode(new AST.BinaryExpression({\n        left: stackItem.left,\n        operator: stackItem.operator.name,\n        right: expr,\n      }), stackItem.startState),\n    right);\n  }\n\n  parseExponentiationExpression() {\n    let startState = this.startNode();\n\n    let leftIsParenthesized = this.lookahead.type === TokenType.LPAREN;\n    let left = this.parseUnaryExpression();\n    if (this.lookahead.type !== TokenType.EXP) {\n      return left;\n    }\n    if (left.type === 'UnaryExpression' && !leftIsParenthesized) {\n      throw this.createError(ErrorMessages.INVALID_EXPONENTIATION_LHS);\n    }\n    this.lex();\n\n    this.isBindingElement = this.isAssignmentTarget = false;\n\n    let right = this.isolateCoverGrammar(this.parseExponentiationExpression);\n    return this.finishNode(new AST.BinaryExpression({ left, operator: '**', right }), startState);\n  }\n\n  parseUnaryExpression() {\n    if (this.lookahead.type.klass !== TokenClass.Punctuator && this.lookahead.type.klass !== TokenClass.Keyword) {\n      return this.parseUpdateExpression();\n    }\n\n    let startState = this.startNode();\n    if (this.allowAwaitExpression && this.eat(TokenType.AWAIT)) {\n      this.isBindingElement = this.isAssignmentTarget = false;\n      let expression = this.isolateCoverGrammar(this.parseUnaryExpression);\n      return this.finishNode(new AST.AwaitExpression({ expression }), startState);\n    }\n\n    let operator = this.lookahead;\n    if (!isPrefixOperator(operator)) {\n      return this.parseUpdateExpression();\n    }\n\n    this.lex();\n    this.isBindingElement = this.isAssignmentTarget = false;\n\n    let node;\n    if (isUpdateOperator(operator)) {\n      let operandStartLocation = this.getLocation();\n      let operand = this.isolateCoverGrammar(this.parseUnaryExpression);\n      if (!isValidSimpleAssignmentTarget(operand)) {\n        throw this.createErrorWithLocation(operandStartLocation, ErrorMessages.INVALID_UPDATE_OPERAND);\n      }\n      operand = this.transformDestructuring(operand);\n      node = new AST.UpdateExpression({ isPrefix: true, operator: operator.value, operand });\n    } else {\n      let operand = this.isolateCoverGrammar(this.parseUnaryExpression);\n      node = new AST.UnaryExpression({ operator: operator.value, operand });\n    }\n\n    return this.finishNode(node, startState);\n  }\n\n  parseUpdateExpression() {\n    let startLocation = this.getLocation();\n    let startState = this.startNode();\n\n    let operand = this.parseLeftHandSideExpression({ allowCall: true });\n    if (this.firstExprError || this.hasLineTerminatorBeforeNext) return operand;\n\n    let operator = this.lookahead;\n    if (!isUpdateOperator(operator)) return operand;\n    this.lex();\n    this.isBindingElement = this.isAssignmentTarget = false;\n    if (!isValidSimpleAssignmentTarget(operand)) {\n      throw this.createErrorWithLocation(startLocation, ErrorMessages.INVALID_UPDATE_OPERAND);\n    }\n    operand = this.transformDestructuring(operand);\n\n    return this.finishNode(new AST.UpdateExpression({ isPrefix: false, operator: operator.value, operand }), startState);\n  }\n\n  parseLeftHandSideExpression({ allowCall }) {\n    let startState = this.startNode();\n    let previousAllowIn = this.allowIn;\n    this.allowIn = true;\n\n    let expr, token = this.lookahead;\n\n    if (this.eat(TokenType.SUPER)) {\n      this.isBindingElement = false;\n      this.isAssignmentTarget = false;\n      expr = this.finishNode(new AST.Super, startState);\n      if (this.match(TokenType.LPAREN)) {\n        if (allowCall) {\n          expr = this.finishNode(new AST.CallExpression({\n            callee: expr,\n            arguments: this.parseArgumentList().args,\n          }), startState);\n        } else {\n          throw this.createUnexpected(token);\n        }\n      } else if (this.match(TokenType.LBRACK)) {\n        expr = this.finishNode(new AST.ComputedMemberExpression({\n          object: expr,\n          expression: this.parseComputedMember(),\n        }), startState);\n        this.isAssignmentTarget = true;\n      } else if (this.match(TokenType.PERIOD)) {\n        expr = this.finishNode(new AST.StaticMemberExpression({\n          object: expr,\n          property: this.parseStaticMember(),\n        }), startState);\n        this.isAssignmentTarget = true;\n      } else {\n        throw this.createUnexpected(token);\n      }\n    } else if (this.match(TokenType.NEW)) {\n      this.isBindingElement = this.isAssignmentTarget = false;\n      expr = this.parseNewExpression();\n    } else if (this.match(TokenType.ASYNC)) {\n      expr = this.parsePrimaryExpression();\n      // there's only three things this could be: an identifier, an async arrow, or an async function expression.\n      if (expr.type === 'IdentifierExpression' && allowCall && !this.hasLineTerminatorBeforeNext) {\n        if (this.matchIdentifier()) {\n          // `async [no lineterminator here] identifier` must be an async arrow\n          let afterAsyncStartState = this.startNode();\n          let previousAwait = this.allowAwaitExpression;\n          this.allowAwaitExpression = true;\n          let param = this.parseBindingIdentifier();\n          this.allowAwaitExpression = previousAwait;\n          this.ensureArrow();\n          return this.finishNode({\n            type: ARROW_EXPRESSION_PARAMS,\n            params: [param],\n            rest: null,\n            isAsync: true,\n          }, afterAsyncStartState);\n        }\n        if (this.match(TokenType.LPAREN)) {\n          // the maximally obnoxious case: `async (`\n          let afterAsyncStartState = this.startNode();\n          let previousAwaitLocation = this.firstAwaitLocation;\n          this.firstAwaitLocation = null;\n          let { args, locationFollowingFirstSpread } = this.parseArgumentList();\n          if (this.isBindingElement && !this.hasLineTerminatorBeforeNext && this.match(TokenType.ARROW)) {\n            if (locationFollowingFirstSpread !== null) {\n              throw this.createErrorWithLocation(locationFollowingFirstSpread, ErrorMessages.UNEXPECTED_TOKEN(','));\n            }\n            if (this.firstAwaitLocation !== null) {\n              throw this.createErrorWithLocation(this.firstAwaitLocation, ErrorMessages.NO_AWAIT_IN_ASYNC_PARAMS);\n            }\n            let rest = null;\n            if (args.length > 0 && args[args.length - 1].type === 'SpreadElement') {\n              rest = this.targetToBinding(this.transformDestructuringWithDefault(args[args.length - 1].expression));\n              if (rest.init != null) {\n                throw this.createError(ErrorMessages.UNEXPECTED_REST_PARAMETERS_INITIALIZATION);\n              }\n              args = args.slice(0, -1);\n            }\n            let params = args.map(arg => this.targetToBinding(this.transformDestructuringWithDefault(arg)));\n            return this.finishNode({\n              type: ARROW_EXPRESSION_PARAMS,\n              params,\n              rest,\n              isAsync: true,\n            }, afterAsyncStartState);\n          }\n          this.firstAwaitLocation = previousAwaitLocation || this.firstAwaitLocation;\n          // otherwise we've just taken the first iteration of the loop below\n          this.isBindingElement = this.isAssignmentTarget = false;\n          expr = this.finishNode(new AST.CallExpression({\n            callee: expr,\n            arguments: args,\n          }), startState);\n        }\n      }\n    } else {\n      expr = this.parsePrimaryExpression();\n      if (this.firstExprError) {\n        return expr;\n      }\n    }\n\n    while (true) {\n      if (allowCall && this.match(TokenType.LPAREN)) {\n        this.isBindingElement = this.isAssignmentTarget = false;\n        expr = this.finishNode(new AST.CallExpression({\n          callee: expr,\n          arguments: this.parseArgumentList().args,\n        }), startState);\n      } else if (this.match(TokenType.LBRACK)) {\n        this.isBindingElement = false;\n        this.isAssignmentTarget = true;\n        expr = this.finishNode(new AST.ComputedMemberExpression({\n          object: expr,\n          expression: this.parseComputedMember(),\n        }), startState);\n      } else if (this.match(TokenType.PERIOD)) {\n        this.isBindingElement = false;\n        this.isAssignmentTarget = true;\n        expr = this.finishNode(new AST.StaticMemberExpression({\n          object: expr,\n          property: this.parseStaticMember(),\n        }), startState);\n      } else if (this.match(TokenType.TEMPLATE)) {\n        this.isBindingElement = this.isAssignmentTarget = false;\n        expr = this.finishNode(new AST.TemplateExpression({\n          tag: expr,\n          elements: this.parseTemplateElements(),\n        }), startState);\n      } else {\n        break;\n      }\n    }\n\n    this.allowIn = previousAllowIn;\n\n    return expr;\n  }\n\n  parseTemplateElements() {\n    let startState = this.startNode();\n    let token = this.lookahead;\n    if (token.tail) {\n      this.lex();\n      return [this.finishNode(new AST.TemplateElement({ rawValue: token.slice.text.slice(1, -1) }), startState)];\n    }\n    let result = [\n      this.finishNode(new AST.TemplateElement({ rawValue: this.lex().slice.text.slice(1, -2) }), startState),\n    ];\n    while (true) {\n      result.push(this.parseExpression());\n      if (!this.match(TokenType.RBRACE)) {\n        throw this.createILLEGAL();\n      }\n      this.index = this.startIndex;\n      this.line = this.startLine;\n      this.lineStart = this.startLineStart;\n      this.lookahead = this.scanTemplateElement();\n      startState = this.startNode();\n      token = this.lex();\n      if (token.tail) {\n        result.push(this.finishNode(new AST.TemplateElement({ rawValue: token.slice.text.slice(1, -1) }), startState));\n        return result;\n      }\n      result.push(this.finishNode(new AST.TemplateElement({ rawValue: token.slice.text.slice(1, -2) }), startState));\n    }\n  }\n\n  parseStaticMember() {\n    this.lex();\n    if (this.lookahead.type.klass.isIdentifierName) {\n      return this.lex().value;\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n\n  parseComputedMember() {\n    this.lex();\n    let expr = this.parseExpression();\n    this.expect(TokenType.RBRACK);\n    return expr;\n  }\n\n  parseNewExpression() {\n    let startState = this.startNode();\n    this.lex();\n    if (this.eat(TokenType.PERIOD)) {\n      this.expectContextualKeyword('target');\n      return this.finishNode(new AST.NewTargetExpression, startState);\n    }\n    let callee = this.isolateCoverGrammar(() => this.parseLeftHandSideExpression({ allowCall: false }));\n    return this.finishNode(new AST.NewExpression({\n      callee,\n      arguments: this.match(TokenType.LPAREN) ? this.parseArgumentList().args : [],\n    }), startState);\n  }\n\n  parseRegexFlags(flags) {\n    let isGlobal = false,\n        ignoreCase = false,\n        multiLine = false,\n        unicode = false,\n        sticky = false,\n        dotAll = false;\n    for (let i = 0; i < flags.length; ++i) {\n      let f = flags[i];\n      switch (f) {\n        case 'g':\n          if (isGlobal) {\n            throw this.createError('Duplicate regular expression flag \\'g\\'');\n          }\n          isGlobal = true;\n          break;\n        case 'i':\n          if (ignoreCase) {\n            throw this.createError('Duplicate regular expression flag \\'i\\'');\n          }\n          ignoreCase = true;\n          break;\n        case 'm':\n          if (multiLine) {\n            throw this.createError('Duplicate regular expression flag \\'m\\'');\n          }\n          multiLine = true;\n          break;\n        case 'u':\n          if (unicode) {\n            throw this.createError('Duplicate regular expression flag \\'u\\'');\n          }\n          unicode = true;\n          break;\n        case 'y':\n          if (sticky) {\n            throw this.createError('Duplicate regular expression flag \\'y\\'');\n          }\n          sticky = true;\n          break;\n        case 's':\n          if (dotAll) {\n            throw this.createError('Duplicate regular expression flag \\'s\\'');\n          }\n          dotAll = true;\n          break;\n        default:\n          throw this.createError(`Invalid regular expression flag '${f}'`);\n      }\n    }\n    return { global: isGlobal, ignoreCase, multiLine, unicode, sticky, dotAll };\n  }\n\n  parsePrimaryExpression() {\n    if (this.match(TokenType.LPAREN)) {\n      return this.parseGroupExpression();\n    }\n\n    let startState = this.startNode();\n\n    if (this.eat(TokenType.ASYNC)) {\n      if (!this.hasLineTerminatorBeforeNext && this.match(TokenType.FUNCTION)) {\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(this.parseFunction({ isExpr: true, inDefault: false, allowGenerator: true, isAsync: true }), startState);\n      }\n      return this.finishNode(new AST.IdentifierExpression({ name: 'async' }), startState);\n    }\n\n    if (this.matchIdentifier()) {\n      return this.finishNode(new AST.IdentifierExpression({ name: this.parseIdentifier() }), startState);\n    }\n    switch (this.lookahead.type) {\n      case TokenType.STRING:\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.parseStringLiteral();\n      case TokenType.NUMBER:\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.parseNumericLiteral();\n      case TokenType.THIS:\n        this.lex();\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(new AST.ThisExpression, startState);\n      case TokenType.FUNCTION:\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(this.parseFunction({ isExpr: true, inDefault: false, allowGenerator: true, isAsync: false }), startState);\n      case TokenType.TRUE:\n        this.lex();\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(new AST.LiteralBooleanExpression({ value: true }), startState);\n      case TokenType.FALSE:\n        this.lex();\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(new AST.LiteralBooleanExpression({ value: false }), startState);\n      case TokenType.NULL:\n        this.lex();\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(new AST.LiteralNullExpression, startState);\n      case TokenType.LBRACK:\n        return this.parseArrayExpression();\n      case TokenType.LBRACE:\n        return this.parseObjectExpression();\n      case TokenType.TEMPLATE:\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.finishNode(new AST.TemplateExpression({ tag: null, elements: this.parseTemplateElements() }), startState);\n      case TokenType.DIV:\n      case TokenType.ASSIGN_DIV: {\n        this.isBindingElement = this.isAssignmentTarget = false;\n        this.lookahead = this.scanRegExp(this.match(TokenType.DIV) ? '/' : '/=');\n        let token = this.lex();\n        let lastSlash = token.value.lastIndexOf('/');\n        let pattern = token.value.slice(1, lastSlash);\n        let flags = token.value.slice(lastSlash + 1);\n        let ctorArgs = this.parseRegexFlags(flags);\n        if (!acceptRegex(pattern, ctorArgs)) {\n          throw this.createError(ErrorMessages.INVALID_REGEX);\n        }\n        ctorArgs.pattern = pattern;\n        return this.finishNode(new AST.LiteralRegExpExpression(ctorArgs), startState);\n      }\n      case TokenType.CLASS:\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return this.parseClass({ isExpr: true, inDefault: false });\n      default:\n        throw this.createUnexpected(this.lookahead);\n    }\n  }\n\n  parseNumericLiteral() {\n    let startLocation = this.getLocation();\n    let startState = this.startNode();\n    let token = this.lex();\n    if (token.octal && this.strict) {\n      if (token.noctal) {\n        throw this.createErrorWithLocation(startLocation, 'Unexpected noctal integer literal');\n      } else {\n        throw this.createErrorWithLocation(startLocation, 'Unexpected legacy octal integer literal');\n      }\n    }\n    let node = token.value === 1 / 0\n      ? new AST.LiteralInfinityExpression\n      : new AST.LiteralNumericExpression({ value: token.value });\n    return this.finishNode(node, startState);\n  }\n\n  parseStringLiteral() {\n    let startLocation = this.getLocation();\n    let startState = this.startNode();\n    let token = this.lex();\n    if (token.octal != null && this.strict) {\n      throw this.createErrorWithLocation(startLocation, 'Unexpected legacy octal escape sequence: \\\\' + token.octal);\n    }\n    return this.finishNode(new AST.LiteralStringExpression({ value: token.str }), startState);\n  }\n\n  parseIdentifierName() {\n    if (this.lookahead.type.klass.isIdentifierName) {\n      return this.lex().value;\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n\n  parseBindingIdentifier() {\n    let startState = this.startNode();\n    return this.finishNode(new AST.BindingIdentifier({ name: this.parseIdentifier() }), startState);\n  }\n\n  parseIdentifier() {\n    if (this.lookahead.value === 'yield' && this.allowYieldExpression) {\n      throw this.createError(ErrorMessages.ILLEGAL_YIELD_IDENTIFIER);\n    }\n    if (this.lookahead.value === 'await' && this.allowAwaitExpression) {\n      throw this.createError(ErrorMessages.ILLEGAL_AWAIT_IDENTIFIER);\n    }\n    if (this.matchIdentifier()) {\n      return this.lex().value;\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n\n  parseArgumentList() {\n    this.lex();\n    let args = this.parseArguments();\n    this.expect(TokenType.RPAREN);\n    return args;\n  }\n\n  parseArguments() {\n    let args = [];\n    let locationFollowingFirstSpread = null;\n    while (!this.match(TokenType.RPAREN)) {\n      let arg;\n      let startState = this.startNode();\n      if (this.eat(TokenType.ELLIPSIS)) {\n        arg = this.finishNode(new AST.SpreadElement({ expression: this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget) }), startState);\n        if (locationFollowingFirstSpread === null) {\n          args.push(arg);\n          if (this.match(TokenType.RPAREN)) {\n            break;\n          }\n          locationFollowingFirstSpread = this.getLocation();\n          this.expect(TokenType.COMMA);\n          continue;\n        }\n      } else {\n        arg = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n      }\n      args.push(arg);\n      if (this.match(TokenType.RPAREN)) {\n        break;\n      }\n      this.expect(TokenType.COMMA);\n    }\n    return { args, locationFollowingFirstSpread };\n  }\n\n  // 11.2 Left-Hand-Side Expressions;\n\n  ensureArrow() {\n    if (this.hasLineTerminatorBeforeNext) {\n      throw this.createError(ErrorMessages.UNEXPECTED_LINE_TERMINATOR);\n    }\n    if (!this.match(TokenType.ARROW)) {\n      this.expect(TokenType.ARROW);\n    }\n  }\n\n  parseGroupExpression() {\n    // At this point, we need to parse 3 things:\n    //  1. Group expression\n    //  2. Assignment target of assignment expression\n    //  3. Parameter list of arrow function\n    let rest = null;\n    let preParenStartState = this.startNode();\n    let start = this.expect(TokenType.LPAREN);\n    let postParenStartState = this.startNode();\n    if (this.match(TokenType.RPAREN)) {\n      this.lex();\n      let paramsNode = this.finishNode({\n        type: ARROW_EXPRESSION_PARAMS,\n        params: [],\n        rest: null,\n        isAsync: false,\n      }, preParenStartState);\n      this.ensureArrow();\n      this.isBindingElement = this.isAssignmentTarget = false;\n      return paramsNode;\n    } else if (this.eat(TokenType.ELLIPSIS)) {\n      rest = this.parseBindingTarget();\n      if (this.match(TokenType.ASSIGN)) {\n        throw this.createError(ErrorMessages.INVALID_REST_PARAMETERS_INITIALIZATION);\n      }\n      if (this.match(TokenType.COMMA)) {\n        throw this.createError(ErrorMessages.INVALID_LAST_REST_PARAMETER);\n      }\n      this.expect(TokenType.RPAREN);\n      let paramsNode = this.finishNode({\n        type: ARROW_EXPRESSION_PARAMS,\n        params: [],\n        rest,\n        isAsync: false,\n      }, preParenStartState);\n      this.ensureArrow();\n      this.isBindingElement = this.isAssignmentTarget = false;\n      return paramsNode;\n    }\n    let group = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n\n    let params = this.isBindingElement ? [this.targetToBinding(this.transformDestructuringWithDefault(group))] : null;\n\n    while (this.eat(TokenType.COMMA)) {\n      if (this.match(TokenType.RPAREN)) {\n        if (!this.isBindingElement) {\n          throw this.createUnexpected(this.lookahead);\n        }\n        this.firstExprError = this.firstExprError || this.createUnexpected(this.lookahead);\n        group = null;\n        break;\n      }\n      this.isAssignmentTarget = false;\n      if (this.match(TokenType.ELLIPSIS)) {\n        if (!this.isBindingElement) {\n          throw this.createUnexpected(this.lookahead);\n        }\n        this.lex();\n        rest = this.parseBindingTarget();\n        if (this.match(TokenType.ASSIGN)) {\n          throw this.createError(ErrorMessages.INVALID_REST_PARAMETERS_INITIALIZATION);\n        }\n        if (this.match(TokenType.COMMA)) {\n          throw this.createError(ErrorMessages.INVALID_LAST_REST_PARAMETER);\n        }\n        break;\n      }\n\n      if (group) {\n        // Can be either binding element or assignment target.\n        let expr = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n        if (this.isBindingElement) {\n          params.push(this.targetToBinding(this.transformDestructuringWithDefault(expr)));\n        } else {\n          params = null;\n        }\n\n        if (this.firstExprError) {\n          group = null;\n        } else {\n          group = this.finishNode(new AST.BinaryExpression({\n            left: group,\n            operator: ',',\n            right: expr,\n          }), postParenStartState);\n        }\n      } else {\n        // Can be only binding elements.\n        let binding = this.parseBindingElement();\n        params.push(binding);\n      }\n    }\n    this.expect(TokenType.RPAREN);\n\n    if (!this.hasLineTerminatorBeforeNext && this.match(TokenType.ARROW)) {\n      if (!this.isBindingElement) {\n        throw this.createErrorWithLocation(start, ErrorMessages.ILLEGAL_ARROW_FUNCTION_PARAMS);\n      }\n\n      this.isBindingElement = false;\n      return this.finishNode({\n        type: ARROW_EXPRESSION_PARAMS,\n        params,\n        rest,\n        isAsync: false,\n      }, preParenStartState);\n    }\n    // Ensure assignment pattern:\n    if (rest) {\n      this.ensureArrow();\n    }\n    this.isBindingElement = false;\n    if (!isValidSimpleAssignmentTarget(group)) {\n      this.isAssignmentTarget = false;\n    }\n    return group;\n  }\n\n  parseArrayExpression() {\n    let startLocation = this.getLocation();\n    let startState = this.startNode();\n\n    this.lex();\n\n    let exprs = [];\n    let rest = null;\n\n    while (true) {\n      if (this.match(TokenType.RBRACK)) {\n        break;\n      }\n      if (this.eat(TokenType.COMMA)) {\n        exprs.push(null);\n      } else {\n        let elementStartState = this.startNode();\n        let expr;\n        if (this.eat(TokenType.ELLIPSIS)) {\n          // Spread/Rest element\n          expr = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n          if (!this.isAssignmentTarget && this.firstExprError) {\n            throw this.firstExprError;\n          }\n          if (expr.type === 'ArrayAssignmentTarget' || expr.type === 'ObjectAssignmentTarget') {\n            rest = expr;\n            break;\n          }\n          if (expr.type !== 'ArrayExpression' && expr.type !== 'ObjectExpression' && !isValidSimpleAssignmentTarget(expr)) {\n            this.isBindingElement = this.isAssignmentTarget = false;\n          }\n          expr = this.finishNode(new AST.SpreadElement({ expression: expr }), elementStartState);\n          if (!this.match(TokenType.RBRACK)) {\n            this.isBindingElement = this.isAssignmentTarget = false;\n          }\n        } else {\n          expr = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n          if (!this.isAssignmentTarget && this.firstExprError) {\n            throw this.firstExprError;\n          }\n        }\n        exprs.push(expr);\n\n        if (!this.match(TokenType.RBRACK)) {\n          this.expect(TokenType.COMMA);\n        }\n      }\n    }\n\n    if (rest && this.match(TokenType.COMMA)) {\n      throw this.createErrorWithLocation(startLocation, ErrorMessages.UNEXPECTED_COMMA_AFTER_REST);\n    }\n\n    this.expect(TokenType.RBRACK);\n\n    if (rest) {\n      // No need to check isAssignmentTarget: the only way to have something we know is a rest element is if we have ...Object/ArrayAssignmentTarget, which implies we have a firstExprError; as such, if isAssignmentTarget were false, we'd've thrown above before setting rest.\n      return this.finishNode(new AST.ArrayAssignmentTarget({\n        elements: exprs.map(e => e && this.transformDestructuringWithDefault(e)),\n        rest,\n      }), startState);\n    } else if (this.firstExprError) {\n      let last = exprs[exprs.length - 1];\n      if (last != null && last.type === 'SpreadElement') {\n        return this.finishNode(new AST.ArrayAssignmentTarget({\n          elements: exprs.slice(0, -1).map(e => e && this.transformDestructuringWithDefault(e)),\n          rest: this.transformDestructuring(last.expression),\n        }), startState);\n      }\n      return this.finishNode(new AST.ArrayAssignmentTarget({\n        elements: exprs.map(e => e && this.transformDestructuringWithDefault(e)),\n        rest: null,\n      }), startState);\n\n    }\n    return this.finishNode(new AST.ArrayExpression({ elements: exprs }), startState);\n  }\n\n  parseObjectExpression() {\n    let startState = this.startNode();\n    this.lex();\n    let properties = [];\n    while (!this.match(TokenType.RBRACE)) {\n      let isSpreadProperty = false;\n      if (this.match(TokenType.ELLIPSIS)) {\n        isSpreadProperty = true;\n        let spreadPropertyOrAssignmentTarget = this.parseSpreadPropertyDefinition();\n        properties.push(spreadPropertyOrAssignmentTarget);\n      } else {\n        let property = this.inheritCoverGrammar(this.parsePropertyDefinition);\n        properties.push(property);\n      }\n      if (!this.match(TokenType.RBRACE)) {\n        this.expect(TokenType.COMMA);\n        if (isSpreadProperty) {\n          this.isBindingElement = this.isAssignmentTarget = false;\n        }\n      }\n    }\n    this.expect(TokenType.RBRACE);\n    if (this.firstExprError) {\n      if (!this.isAssignmentTarget) {\n        throw this.createError(ErrorMessages.INVALID_LHS_IN_BINDING);\n      }\n      let last = properties[properties.length - 1];\n      if (last != null && last.type === 'SpreadProperty') {\n        return this.finishNode(new AST.ObjectAssignmentTarget({\n          properties: properties.slice(0, -1).map(p => this.transformDestructuringWithDefault(p)),\n          rest: this.transformDestructuring(last.expression),\n        }), startState);\n      }\n      return this.finishNode(new AST.ObjectAssignmentTarget({ properties: properties.map(p => this.transformDestructuringWithDefault(p)), rest: null }), startState);\n    }\n    return this.finishNode(new AST.ObjectExpression({ properties }), startState);\n  }\n\n  parseSpreadPropertyDefinition() {\n    let startState = this.startNode();\n    this.expect(TokenType.ELLIPSIS);\n    let expression = this.parseAssignmentExpression();\n    if (!isValidSimpleAssignmentTarget(expression)) {\n      this.isBindingElement = this.isAssignmentTarget = false;\n    } else if (expression.type !== 'IdentifierExpression') {\n      this.isBindingElement = false;\n    }\n    return this.finishNode(new AST.SpreadProperty({ expression }), startState);\n  }\n\n  parsePropertyDefinition() {\n    let startLocation = this.getLocation();\n    let startState = this.startNode();\n    let token = this.lookahead;\n\n    let { methodOrKey, kind } = this.parseMethodDefinition();\n    switch (kind) {\n      case 'method':\n        this.isBindingElement = this.isAssignmentTarget = false;\n        return methodOrKey;\n      case 'identifier':\n        if (token.value === 'await' && this.firstAwaitLocation == null) {\n          this.firstAwaitLocation = this.getLocation();\n        }\n        if (this.eat(TokenType.ASSIGN)) {\n          if (this.allowYieldExpression && token.value === 'yield') {\n            throw this.createError(ErrorMessages.ILLEGAL_YIELD_IDENTIFIER);\n          }\n          if (this.allowAwaitExpression && token.value === 'await') {\n            throw this.createError(ErrorMessages.ILLEGAL_AWAIT_IDENTIFIER);\n          }\n          // CoverInitializedName\n          let init = this.isolateCoverGrammar(this.parseAssignmentExpression);\n          this.firstExprError = this.createErrorWithLocation(startLocation, ErrorMessages.ILLEGAL_PROPERTY);\n          return this.finishNode(new AST.AssignmentTargetPropertyIdentifier({\n            binding: this.transformDestructuring(methodOrKey),\n            init,\n          }), startState);\n        } else if (!this.match(TokenType.COLON)) {\n          if (this.allowYieldExpression && token.value === 'yield') {\n            throw this.createError(ErrorMessages.ILLEGAL_YIELD_IDENTIFIER);\n          }\n          if (this.allowAwaitExpression && token.value === 'await') {\n            throw this.createError(ErrorMessages.ILLEGAL_AWAIT_IDENTIFIER);\n          }\n          if (token.type === TokenType.IDENTIFIER || token.value === 'let' || token.value === 'yield' || token.value === 'async' || token.value === 'await') {\n            return this.finishNode(new AST.ShorthandProperty({ name: this.finishNode(new AST.IdentifierExpression({ name: methodOrKey.value }), startState) }), startState);\n          }\n          throw this.createUnexpected(token);\n        }\n    }\n\n    // property\n    this.expect(TokenType.COLON);\n\n    let expr = this.inheritCoverGrammar(this.parseAssignmentExpressionOrTarget);\n    if (this.firstExprError) {\n      return this.finishNode(new AST.AssignmentTargetPropertyProperty({ name: methodOrKey, binding: expr }), startState);\n    }\n    return this.finishNode(new AST.DataProperty({ name: methodOrKey, expression: expr }), startState);\n  }\n\n  parsePropertyName() {\n    // PropertyName[Yield,GeneratorParameter]:\n    let token = this.lookahead;\n    let startState = this.startNode();\n\n    if (this.eof()) {\n      throw this.createUnexpected(token);\n    }\n\n    switch (token.type) {\n      case TokenType.STRING:\n        return {\n          name: this.finishNode(new AST.StaticPropertyName({\n            value: this.parseStringLiteral().value,\n          }), startState),\n          binding: null,\n        };\n      case TokenType.NUMBER: {\n        let numLiteral = this.parseNumericLiteral();\n        return {\n          name: this.finishNode(new AST.StaticPropertyName({\n            value: `${numLiteral.type === 'LiteralInfinityExpression' ? 1 / 0 : numLiteral.value}`,\n          }), startState),\n          binding: null,\n        };\n      }\n      case TokenType.LBRACK: {\n        this.lex();\n        let expr = this.parseAssignmentExpression();\n        this.expect(TokenType.RBRACK);\n        return { name: this.finishNode(new AST.ComputedPropertyName({ expression: expr }), startState), binding: null };\n      }\n    }\n\n    let name = this.parseIdentifierName();\n    return {\n      name: this.finishNode(new AST.StaticPropertyName({ value: name }), startState),\n      binding: this.finishNode(new AST.BindingIdentifier({ name }), startState),\n    };\n  }\n\n  /**\n   * Test if lookahead can be the beginning of a `PropertyName`.\n   * @returns {boolean}\n   */\n  lookaheadPropertyName() {\n    switch (this.lookahead.type) {\n      case TokenType.NUMBER:\n      case TokenType.STRING:\n      case TokenType.LBRACK:\n        return true;\n      default:\n        return this.lookahead.type.klass.isIdentifierName;\n    }\n  }\n\n  // eslint-disable-next-line valid-jsdoc\n  /**\n   * Try to parse a method definition.\n   *\n   * If it turns out to be one of:\n   *  * `IdentifierReference`\n   *  * `CoverInitializedName` (`IdentifierReference \"=\" AssignmentExpression`)\n   *  * `PropertyName : AssignmentExpression`\n   * The parser will stop at the end of the leading `Identifier` or `PropertyName` and return it.\n   *\n   * @returns {{methodOrKey: (Method|PropertyName), kind: string}}\n   */\n  parseMethodDefinition() {\n    let token = this.lookahead;\n    let startState = this.startNode();\n\n    let preAsyncTokenState = this.saveLexerState();\n\n    let isAsync = !!this.eat(TokenType.ASYNC);\n    if (isAsync && this.hasLineTerminatorBeforeNext) {\n      isAsync = false;\n      this.restoreLexerState(preAsyncTokenState);\n    }\n\n    let isGenerator = !!this.eat(TokenType.MUL);\n    if (isAsync && !this.lookaheadPropertyName()) {\n      isAsync = false;\n      isGenerator = false;\n      this.restoreLexerState(preAsyncTokenState);\n    }\n\n    let { name } = this.parsePropertyName();\n\n    if (!isGenerator && !isAsync) {\n      if (token.type === TokenType.IDENTIFIER && token.value.length === 3) {\n        // Property Assignment: Getter and Setter.\n        if (token.value === 'get' && this.lookaheadPropertyName() && !token.escaped) {\n          ({ name } = this.parsePropertyName());\n          this.expect(TokenType.LPAREN);\n          this.expect(TokenType.RPAREN);\n          let previousYield = this.allowYieldExpression;\n          let previousAwait = this.allowAwaitExpression;\n          let previousAwaitLocation = this.firstAwaitLocation;\n          this.allowYieldExpression = false;\n          this.allowAwaitExpression = false;\n          this.firstAwaitLocation = null;\n          let body = this.parseFunctionBody();\n          this.allowYieldExpression = previousYield;\n          this.allowAwaitExpression = previousAwait;\n          this.firstAwaitLocation = previousAwaitLocation;\n          return {\n            methodOrKey: this.finishNode(new AST.Getter({ name, body }), startState),\n            kind: 'method',\n          };\n        } else if (token.value === 'set' && this.lookaheadPropertyName() && !token.escaped) {\n          ({ name } = this.parsePropertyName());\n          this.expect(TokenType.LPAREN);\n          let previousYield = this.allowYieldExpression;\n          let previousAwait = this.allowAwaitExpression;\n          let previousAwaitLocation = this.firstAwaitLocation;\n          this.allowYieldExpression = false;\n          this.allowAwaitExpression = false;\n          this.firstAwaitLocation = null;\n          let param = this.parseBindingElement();\n          this.expect(TokenType.RPAREN);\n          let body = this.parseFunctionBody();\n          this.allowYieldExpression = previousYield;\n          this.allowAwaitExpression = previousAwait;\n          this.firstAwaitLocation = previousAwaitLocation;\n          return {\n            methodOrKey: this.finishNode(new AST.Setter({ name, param, body }), startState),\n            kind: 'method',\n          };\n        }\n      }\n    }\n    if (isAsync) {\n      let previousYield = this.allowYieldExpression;\n      let previousAwait = this.allowAwaitExpression;\n      this.allowYieldExpression = isGenerator;\n      this.allowAwaitExpression = true;\n      let params = this.parseParams();\n      this.allowYieldExpression = isGenerator;\n      this.allowAwaitExpression = true;\n      let body = this.parseFunctionBody();\n      this.allowYieldExpression = previousYield;\n      this.allowAwaitExpression = previousAwait;\n      return {\n        methodOrKey: this.finishNode(new AST.Method({ isAsync, isGenerator, name, params, body }), startState),\n        kind: 'method',\n      };\n    }\n\n    if (this.match(TokenType.LPAREN)) {\n      let previousYield = this.allowYieldExpression;\n      let previousAwait = this.allowAwaitExpression;\n      let previousAwaitLocation = this.firstAwaitLocation;\n      this.allowYieldExpression = isGenerator;\n      this.allowAwaitExpression = false;\n      this.firstAwaitLocation = null;\n      let params = this.parseParams();\n      let body = this.parseFunctionBody();\n      this.allowYieldExpression = previousYield;\n      this.allowAwaitExpression = previousAwait;\n      this.firstAwaitLocation = previousAwaitLocation;\n\n      return {\n        methodOrKey: this.finishNode(new AST.Method({ isAsync, isGenerator, name, params, body }), startState),\n        kind: 'method',\n      };\n    }\n\n    if (isGenerator && this.match(TokenType.COLON)) {\n      throw this.createUnexpected(this.lookahead);\n    }\n\n    return {\n      methodOrKey: name,\n      kind: token.type.klass.isIdentifierName ? 'identifier' : 'property',\n      escaped: token.escaped,\n    };\n  }\n\n  parseClass({ isExpr, inDefault }) {\n    let startState = this.startNode();\n\n    this.lex();\n    let name = null;\n    let heritage = null;\n\n    if (this.matchIdentifier()) {\n      name = this.parseBindingIdentifier();\n    } else if (!isExpr) {\n      if (inDefault) {\n        name = new AST.BindingIdentifier({ name: '*default*' });\n      } else {\n        throw this.createUnexpected(this.lookahead);\n      }\n    }\n\n    if (this.eat(TokenType.EXTENDS)) {\n      heritage = this.isolateCoverGrammar(() => this.parseLeftHandSideExpression({ allowCall: true }));\n    }\n\n    this.expect(TokenType.LBRACE);\n    let elements = [];\n    while (!this.eat(TokenType.RBRACE)) {\n      if (this.eat(TokenType.SEMICOLON)) {\n        continue;\n      }\n      let isStatic = false;\n      let classElementStart = this.startNode();\n      let { methodOrKey, kind, escaped } = this.parseMethodDefinition();\n      if (kind === 'identifier' && methodOrKey.value === 'static' && !escaped) {\n        isStatic = true;\n        ({ methodOrKey, kind } = this.parseMethodDefinition());\n      }\n      if (kind === 'method') {\n        elements.push(this.finishNode(new AST.ClassElement({ isStatic, method: methodOrKey }), classElementStart));\n      } else {\n        throw this.createError('Only methods are allowed in classes');\n      }\n    }\n    return this.finishNode(new (isExpr ? AST.ClassExpression : AST.ClassDeclaration)({ name, super: heritage, elements }), startState);\n  }\n\n  parseFunction({ isExpr, inDefault, allowGenerator, isAsync, startState = this.startNode() }) {\n    this.lex();\n    let name = null;\n    let isGenerator = allowGenerator && !!this.eat(TokenType.MUL);\n\n    let previousYield = this.allowYieldExpression;\n    let previousAwait = this.allowAwaitExpression;\n    let previousAwaitLocation = this.firstAwaitLocation;\n\n    if (isExpr) {\n      this.allowYieldExpression = isGenerator;\n      this.allowAwaitExpression = isAsync;\n    }\n\n    if (!this.match(TokenType.LPAREN)) {\n      name = this.parseBindingIdentifier();\n    } else if (!isExpr) {\n      if (inDefault) {\n        name = new AST.BindingIdentifier({ name: '*default*' });\n      } else {\n        throw this.createUnexpected(this.lookahead);\n      }\n    }\n    this.allowYieldExpression = isGenerator;\n    this.allowAwaitExpression = isAsync;\n    this.firstAwaitLocation = null;\n    let params = this.parseParams();\n    let body = this.parseFunctionBody();\n    this.allowYieldExpression = previousYield;\n    this.allowAwaitExpression = previousAwait;\n    this.firstAwaitLocation = previousAwaitLocation;\n\n    return this.finishNode(new (isExpr ? AST.FunctionExpression : AST.FunctionDeclaration)({ isAsync, isGenerator, name, params, body }), startState);\n  }\n\n  parseArrayBinding() {\n    let startState = this.startNode();\n\n    this.expect(TokenType.LBRACK);\n\n    let elements = [], rest = null;\n\n    while (true) {\n      if (this.match(TokenType.RBRACK)) {\n        break;\n      }\n      let el;\n\n      if (this.eat(TokenType.COMMA)) {\n        el = null;\n      } else {\n        if (this.eat(TokenType.ELLIPSIS)) {\n          rest = this.parseBindingTarget();\n          break;\n        } else {\n          el = this.parseBindingElement();\n        }\n        if (!this.match(TokenType.RBRACK)) {\n          this.expect(TokenType.COMMA);\n        }\n      }\n      elements.push(el);\n    }\n\n    this.expect(TokenType.RBRACK);\n\n    return this.finishNode(new AST.ArrayBinding({ elements, rest }), startState);\n  }\n\n  parseBindingProperty() {\n    let startState = this.startNode();\n    let isIdentifier = this.matchIdentifier();\n    let token = this.lookahead;\n    let { name, binding } = this.parsePropertyName();\n    if (isIdentifier && name.type === 'StaticPropertyName') {\n      if (!this.match(TokenType.COLON)) {\n        if (this.allowYieldExpression && token.value === 'yield') {\n          throw this.createError(ErrorMessages.ILLEGAL_YIELD_IDENTIFIER);\n        }\n        if (this.allowAwaitExpression && token.value === 'await') {\n          throw this.createError(ErrorMessages.ILLEGAL_AWAIT_IDENTIFIER);\n        }\n        let defaultValue = null;\n        if (this.eat(TokenType.ASSIGN)) {\n          defaultValue = this.parseAssignmentExpression();\n        }\n        return this.finishNode(new AST.BindingPropertyIdentifier({\n          binding,\n          init: defaultValue,\n        }), startState);\n      }\n    }\n    this.expect(TokenType.COLON);\n    binding = this.parseBindingElement();\n    return this.finishNode(new AST.BindingPropertyProperty({ name, binding }), startState);\n  }\n\n  parseObjectBinding() {\n    let startState = this.startNode();\n    this.expect(TokenType.LBRACE);\n\n    let properties = [];\n    let rest = null;\n    while (!this.match(TokenType.RBRACE)) {\n      if (this.eat(TokenType.ELLIPSIS)) {\n        rest = this.parseBindingIdentifier();\n        break;\n      }\n      properties.push(this.parseBindingProperty());\n      if (!this.match(TokenType.RBRACE)) {\n        this.expect(TokenType.COMMA);\n      }\n    }\n\n    this.expect(TokenType.RBRACE);\n\n    return this.finishNode(new AST.ObjectBinding({ properties, rest }), startState);\n  }\n\n  parseBindingTarget() {\n    if (this.matchIdentifier()) {\n      return this.parseBindingIdentifier();\n    }\n    switch (this.lookahead.type) {\n      case TokenType.LBRACK:\n        return this.parseArrayBinding();\n      case TokenType.LBRACE:\n        return this.parseObjectBinding();\n    }\n    throw this.createUnexpected(this.lookahead);\n  }\n\n  parseBindingElement() {\n    let startState = this.startNode();\n    let binding = this.parseBindingTarget();\n    if (this.eat(TokenType.ASSIGN)) {\n      let init = this.parseAssignmentExpression();\n      binding = this.finishNode(new AST.BindingWithDefault({ binding, init }), startState);\n    }\n    return binding;\n  }\n\n  parseParam() {\n    let previousInParameter = this.inParameter;\n    this.inParameter = true;\n    let param = this.parseBindingElement();\n    this.inParameter = previousInParameter;\n    return param;\n  }\n\n  parseParams() {\n    let startState = this.startNode();\n    this.expect(TokenType.LPAREN);\n\n    let items = [], rest = null;\n    while (!this.match(TokenType.RPAREN)) {\n      if (this.eat(TokenType.ELLIPSIS)) {\n        rest = this.parseBindingTarget();\n        if (this.lookahead.type === TokenType.ASSIGN) {\n          throw this.createError(ErrorMessages.UNEXPECTED_REST_PARAMETERS_INITIALIZATION);\n        }\n        if (this.match(TokenType.COMMA)) {\n          throw this.createError(ErrorMessages.UNEXPECTED_COMMA_AFTER_REST);\n        }\n        break;\n      }\n      items.push(this.parseParam());\n      if (this.match(TokenType.RPAREN)) break;\n      this.expect(TokenType.COMMA);\n    }\n\n    this.expect(TokenType.RPAREN);\n\n    return this.finishNode(new AST.FormalParameters({ items, rest }), startState);\n  }\n}\n\nmodule.exports = { GenericParser };\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}