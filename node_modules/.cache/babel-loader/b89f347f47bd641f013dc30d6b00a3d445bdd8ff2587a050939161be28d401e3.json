{"ast":null,"code":"const Precedence = {\n  Sequence: 0,\n  Yield: 1,\n  Assignment: 1,\n  Conditional: 2,\n  ArrowFunction: 2,\n  LogicalOR: 3,\n  LogicalAND: 4,\n  BitwiseOR: 5,\n  BitwiseXOR: 6,\n  BitwiseAND: 7,\n  Equality: 8,\n  Relational: 9,\n  BitwiseSHIFT: 10,\n  Additive: 11,\n  Multiplicative: 12,\n  Exponential: 13,\n  Prefix: 14,\n  Postfix: 15,\n  New: 16,\n  Call: 17,\n  TaggedTemplate: 18,\n  Member: 19,\n  Primary: 20\n};\nconst BinaryPrecedence = {\n  ',': Precedence.Sequence,\n  '||': Precedence.LogicalOR,\n  '&&': Precedence.LogicalAND,\n  '|': Precedence.BitwiseOR,\n  '^': Precedence.BitwiseXOR,\n  '&': Precedence.BitwiseAND,\n  '==': Precedence.Equality,\n  '!=': Precedence.Equality,\n  '===': Precedence.Equality,\n  '!==': Precedence.Equality,\n  '<': Precedence.Relational,\n  '>': Precedence.Relational,\n  '<=': Precedence.Relational,\n  '>=': Precedence.Relational,\n  'in': Precedence.Relational,\n  'instanceof': Precedence.Relational,\n  '<<': Precedence.BitwiseSHIFT,\n  '>>': Precedence.BitwiseSHIFT,\n  '>>>': Precedence.BitwiseSHIFT,\n  '+': Precedence.Additive,\n  '-': Precedence.Additive,\n  '*': Precedence.Multiplicative,\n  '%': Precedence.Multiplicative,\n  '/': Precedence.Multiplicative,\n  '**': Precedence.Exponential\n};\nfunction getPrecedence(node) {\n  switch (node.type) {\n    case 'ArrayExpression':\n    case 'FunctionExpression':\n    case 'ClassExpression':\n    case 'IdentifierExpression':\n    case 'AssignmentTargetIdentifier':\n    case 'NewTargetExpression':\n    case 'Super':\n    case 'LiteralBooleanExpression':\n    case 'LiteralNullExpression':\n    case 'LiteralNumericExpression':\n    case 'LiteralInfinityExpression':\n    case 'LiteralRegExpExpression':\n    case 'LiteralStringExpression':\n    case 'ObjectExpression':\n    case 'ThisExpression':\n    case 'SpreadElement':\n    case 'FunctionBody':\n      return Precedence.Primary;\n    case 'ArrowExpression':\n    case 'AssignmentExpression':\n    case 'CompoundAssignmentExpression':\n    case 'YieldExpression':\n    case 'YieldGeneratorExpression':\n      return Precedence.Assignment;\n    case 'ConditionalExpression':\n      return Precedence.Conditional;\n    case 'ComputedMemberExpression':\n    case 'StaticMemberExpression':\n    case 'ComputedMemberAssignmentTarget':\n    case 'StaticMemberAssignmentTarget':\n      switch (node.object.type) {\n        case 'CallExpression':\n        case 'ComputedMemberExpression':\n        case 'StaticMemberExpression':\n        case 'TemplateExpression':\n          return getPrecedence(node.object);\n        default:\n          return Precedence.Member;\n      }\n    case 'TemplateExpression':\n      if (node.tag == null) return Precedence.Member;\n      switch (node.tag.type) {\n        case 'CallExpression':\n        case 'ComputedMemberExpression':\n        case 'StaticMemberExpression':\n        case 'TemplateExpression':\n          return getPrecedence(node.tag);\n        default:\n          return Precedence.Member;\n      }\n    case 'BinaryExpression':\n      return BinaryPrecedence[node.operator];\n    case 'CallExpression':\n      return Precedence.Call;\n    case 'NewExpression':\n      return node.arguments.length === 0 ? Precedence.New : Precedence.Member;\n    case 'UpdateExpression':\n      return node.isPrefix ? Precedence.Prefix : Precedence.Postfix;\n    case 'AwaitExpression':\n    case 'UnaryExpression':\n      return Precedence.Prefix;\n    default:\n      throw new Error('unreachable: ' + node.type);\n  }\n}\nfunction escapeStringLiteral(stringValue) {\n  let result = '';\n  let nSingle = 0,\n    nDouble = 0;\n  for (let i = 0, l = stringValue.length; i < l; ++i) {\n    let ch = stringValue[i];\n    if (ch === '\"') {\n      ++nDouble;\n    } else if (ch === '\\'') {\n      ++nSingle;\n    }\n  }\n  let delim = nDouble > nSingle ? '\\'' : '\"';\n  result += delim;\n  for (let i = 0; i < stringValue.length; i++) {\n    let ch = stringValue.charAt(i);\n    switch (ch) {\n      case delim:\n        result += '\\\\' + delim;\n        break;\n      case '\\n':\n        result += '\\\\n';\n        break;\n      case '\\r':\n        result += '\\\\r';\n        break;\n      case '\\\\':\n        result += '\\\\\\\\';\n        break;\n      case '\\u2028':\n        result += '\\\\u2028';\n        break;\n      case '\\u2029':\n        result += '\\\\u2029';\n        break;\n      default:\n        result += ch;\n        break;\n    }\n  }\n  result += delim;\n  return result;\n}\nclass CodeRep {\n  constructor() {\n    this.containsIn = false;\n    this.containsGroup = false;\n    // restricted lookaheads: {, function, class, let, let [\n    this.startsWithCurly = false;\n    this.startsWithFunctionOrClass = false;\n    this.startsWithLet = false;\n    this.startsWithLetSquareBracket = false;\n    this.endsWithMissingElse = false;\n  }\n  forEach(f) {\n    // Call a function on every CodeRep represented by this node. Always calls f on a node and then its children, so if you're careful you can modify a node's children online.\n    f(this);\n  }\n}\nclass Empty extends CodeRep {\n  constructor() {\n    super();\n  }\n  emit() {}\n}\nclass Token extends CodeRep {\n  constructor(token, isRegExp = false) {\n    super();\n    this.token = token;\n    this.isRegExp = isRegExp;\n  }\n  emit(ts) {\n    ts.put(this.token, this.isRegExp);\n  }\n}\nclass RawToken extends CodeRep {\n  constructor(token) {\n    super();\n    this.token = token;\n  }\n  emit(ts) {\n    ts.putRaw(this.token);\n  }\n}\nclass NumberCodeRep extends CodeRep {\n  constructor(number) {\n    super();\n    this.number = number;\n  }\n  emit(ts) {\n    ts.putNumber(this.number);\n  }\n}\nclass Paren extends CodeRep {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n  emit(ts) {\n    ts.put('(');\n    this.expr.emit(ts, false);\n    ts.put(')');\n  }\n  forEach(f) {\n    f(this);\n    this.expr.forEach(f);\n  }\n}\nclass Bracket extends CodeRep {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n  emit(ts) {\n    ts.put('[');\n    this.expr.emit(ts, false);\n    ts.put(']');\n  }\n  forEach(f) {\n    f(this);\n    this.expr.forEach(f);\n  }\n}\nclass Brace extends CodeRep {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n  emit(ts) {\n    ts.put('{');\n    this.expr.emit(ts, false);\n    ts.put('}');\n  }\n  forEach(f) {\n    f(this);\n    this.expr.forEach(f);\n  }\n}\nclass NoIn extends CodeRep {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n  emit(ts) {\n    this.expr.emit(ts, true);\n  }\n  forEach(f) {\n    f(this);\n    this.expr.forEach(f);\n  }\n}\nclass ContainsIn extends CodeRep {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n  emit(ts, noIn) {\n    if (noIn) {\n      ts.put('(');\n      this.expr.emit(ts, false);\n      ts.put(')');\n    } else {\n      this.expr.emit(ts, false);\n    }\n  }\n  forEach(f) {\n    f(this);\n    this.expr.forEach(f);\n  }\n}\nclass Seq extends CodeRep {\n  constructor(children) {\n    super();\n    this.children = children;\n  }\n  emit(ts, noIn) {\n    this.children.forEach(cr => cr.emit(ts, noIn));\n  }\n  forEach(f) {\n    f(this);\n    this.children.forEach(x => x.forEach(f));\n  }\n}\nclass Semi extends Token {\n  constructor() {\n    super(';');\n  }\n}\nclass CommaSep extends CodeRep {\n  constructor(children) {\n    super();\n    this.children = children;\n  }\n  emit(ts, noIn) {\n    let first = true;\n    this.children.forEach(cr => {\n      if (first) {\n        first = false;\n      } else {\n        ts.put(',');\n      }\n      cr.emit(ts, noIn);\n    });\n  }\n  forEach(f) {\n    f(this);\n    this.children.forEach(x => x.forEach(f));\n  }\n}\nclass SemiOp extends CodeRep {\n  constructor() {\n    super();\n  }\n  emit(ts) {\n    ts.putOptionalSemi();\n  }\n}\nmodule.exports = {\n  Precedence,\n  getPrecedence,\n  escapeStringLiteral,\n  CodeRep,\n  Empty,\n  Token,\n  RawToken,\n  NumberCodeRep,\n  Paren,\n  Bracket,\n  Brace,\n  NoIn,\n  ContainsIn,\n  Seq,\n  Semi,\n  CommaSep,\n  SemiOp\n};","map":{"version":3,"names":["Precedence","Sequence","Yield","Assignment","Conditional","ArrowFunction","LogicalOR","LogicalAND","BitwiseOR","BitwiseXOR","BitwiseAND","Equality","Relational","BitwiseSHIFT","Additive","Multiplicative","Exponential","Prefix","Postfix","New","Call","TaggedTemplate","Member","Primary","BinaryPrecedence","getPrecedence","node","type","object","tag","operator","arguments","length","isPrefix","Error","escapeStringLiteral","stringValue","result","nSingle","nDouble","i","l","ch","delim","charAt","CodeRep","constructor","containsIn","containsGroup","startsWithCurly","startsWithFunctionOrClass","startsWithLet","startsWithLetSquareBracket","endsWithMissingElse","forEach","f","Empty","emit","Token","token","isRegExp","ts","put","RawToken","putRaw","NumberCodeRep","number","putNumber","Paren","expr","Bracket","Brace","NoIn","ContainsIn","noIn","Seq","children","cr","x","Semi","CommaSep","first","SemiOp","putOptionalSemi","module","exports"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/shift-codegen/src/coderep.js"],"sourcesContent":["const Precedence = {\n  Sequence: 0,\n  Yield: 1,\n  Assignment: 1,\n  Conditional: 2,\n  ArrowFunction: 2,\n  LogicalOR: 3,\n  LogicalAND: 4,\n  BitwiseOR: 5,\n  BitwiseXOR: 6,\n  BitwiseAND: 7,\n  Equality: 8,\n  Relational: 9,\n  BitwiseSHIFT: 10,\n  Additive: 11,\n  Multiplicative: 12,\n  Exponential: 13,\n  Prefix: 14,\n  Postfix: 15,\n  New: 16,\n  Call: 17,\n  TaggedTemplate: 18,\n  Member: 19,\n  Primary: 20,\n};\n\nconst BinaryPrecedence = {\n  ',': Precedence.Sequence,\n  '||': Precedence.LogicalOR,\n  '&&': Precedence.LogicalAND,\n  '|': Precedence.BitwiseOR,\n  '^': Precedence.BitwiseXOR,\n  '&': Precedence.BitwiseAND,\n  '==': Precedence.Equality,\n  '!=': Precedence.Equality,\n  '===': Precedence.Equality,\n  '!==': Precedence.Equality,\n  '<': Precedence.Relational,\n  '>': Precedence.Relational,\n  '<=': Precedence.Relational,\n  '>=': Precedence.Relational,\n  'in': Precedence.Relational,\n  'instanceof': Precedence.Relational,\n  '<<': Precedence.BitwiseSHIFT,\n  '>>': Precedence.BitwiseSHIFT,\n  '>>>': Precedence.BitwiseSHIFT,\n  '+': Precedence.Additive,\n  '-': Precedence.Additive,\n  '*': Precedence.Multiplicative,\n  '%': Precedence.Multiplicative,\n  '/': Precedence.Multiplicative,\n  '**': Precedence.Exponential,\n};\n\nfunction getPrecedence(node) {\n  switch (node.type) {\n    case 'ArrayExpression':\n    case 'FunctionExpression':\n    case 'ClassExpression':\n    case 'IdentifierExpression':\n    case 'AssignmentTargetIdentifier':\n    case 'NewTargetExpression':\n    case 'Super':\n    case 'LiteralBooleanExpression':\n    case 'LiteralNullExpression':\n    case 'LiteralNumericExpression':\n    case 'LiteralInfinityExpression':\n    case 'LiteralRegExpExpression':\n    case 'LiteralStringExpression':\n    case 'ObjectExpression':\n    case 'ThisExpression':\n    case 'SpreadElement':\n    case 'FunctionBody':\n      return Precedence.Primary;\n\n    case 'ArrowExpression':\n    case 'AssignmentExpression':\n    case 'CompoundAssignmentExpression':\n    case 'YieldExpression':\n    case 'YieldGeneratorExpression':\n      return Precedence.Assignment;\n\n    case 'ConditionalExpression':\n      return Precedence.Conditional;\n\n    case 'ComputedMemberExpression':\n    case 'StaticMemberExpression':\n    case 'ComputedMemberAssignmentTarget':\n    case 'StaticMemberAssignmentTarget':\n      switch (node.object.type) {\n        case 'CallExpression':\n        case 'ComputedMemberExpression':\n        case 'StaticMemberExpression':\n        case 'TemplateExpression':\n          return getPrecedence(node.object);\n        default:\n          return Precedence.Member;\n      }\n\n    case 'TemplateExpression':\n      if (node.tag == null) return Precedence.Member;\n      switch (node.tag.type) {\n        case 'CallExpression':\n        case 'ComputedMemberExpression':\n        case 'StaticMemberExpression':\n        case 'TemplateExpression':\n          return getPrecedence(node.tag);\n        default:\n          return Precedence.Member;\n      }\n\n    case 'BinaryExpression':\n      return BinaryPrecedence[node.operator];\n\n    case 'CallExpression':\n      return Precedence.Call;\n    case 'NewExpression':\n      return node.arguments.length === 0 ? Precedence.New : Precedence.Member;\n    case 'UpdateExpression':\n      return node.isPrefix ? Precedence.Prefix : Precedence.Postfix;\n    case 'AwaitExpression':\n    case 'UnaryExpression':\n      return Precedence.Prefix;\n    default:\n      throw new Error('unreachable: ' + node.type);\n  }\n}\n\nfunction escapeStringLiteral(stringValue) {\n  let result = '';\n  let nSingle = 0, nDouble = 0;\n  for (let i = 0, l = stringValue.length; i < l; ++i) {\n    let ch = stringValue[i];\n    if (ch === '\"') {\n      ++nDouble;\n    } else if (ch === '\\'') {\n      ++nSingle;\n    }\n  }\n  let delim = nDouble > nSingle ? '\\'' : '\"';\n  result += delim;\n  for (let i = 0; i < stringValue.length; i++) {\n    let ch = stringValue.charAt(i);\n    switch (ch) {\n      case delim:\n        result += '\\\\' + delim;\n        break;\n      case '\\n':\n        result += '\\\\n';\n        break;\n      case '\\r':\n        result += '\\\\r';\n        break;\n      case '\\\\':\n        result += '\\\\\\\\';\n        break;\n      case '\\u2028':\n        result += '\\\\u2028';\n        break;\n      case '\\u2029':\n        result += '\\\\u2029';\n        break;\n      default:\n        result += ch;\n        break;\n    }\n  }\n  result += delim;\n  return result;\n}\n\nclass CodeRep {\n  constructor() {\n    this.containsIn = false;\n    this.containsGroup = false;\n    // restricted lookaheads: {, function, class, let, let [\n    this.startsWithCurly = false;\n    this.startsWithFunctionOrClass = false;\n    this.startsWithLet = false;\n    this.startsWithLetSquareBracket = false;\n    this.endsWithMissingElse = false;\n  }\n\n  forEach(f) {\n    // Call a function on every CodeRep represented by this node. Always calls f on a node and then its children, so if you're careful you can modify a node's children online.\n    f(this);\n  }\n}\n\nclass Empty extends CodeRep {\n  constructor() {\n    super();\n  }\n\n  emit() {}\n}\n\nclass Token extends CodeRep {\n  constructor(token, isRegExp = false) {\n    super();\n    this.token = token;\n    this.isRegExp = isRegExp;\n  }\n\n  emit(ts) {\n    ts.put(this.token, this.isRegExp);\n  }\n}\n\nclass RawToken extends CodeRep {\n  constructor(token) {\n    super();\n    this.token = token;\n  }\n\n  emit(ts) {\n    ts.putRaw(this.token);\n  }\n}\n\nclass NumberCodeRep extends CodeRep {\n  constructor(number) {\n    super();\n    this.number = number;\n  }\n\n  emit(ts) {\n    ts.putNumber(this.number);\n  }\n}\n\nclass Paren extends CodeRep {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n\n  emit(ts) {\n    ts.put('(');\n    this.expr.emit(ts, false);\n    ts.put(')');\n  }\n\n  forEach(f) {\n    f(this);\n    this.expr.forEach(f);\n  }\n}\n\nclass Bracket extends CodeRep {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n\n  emit(ts) {\n    ts.put('[');\n    this.expr.emit(ts, false);\n    ts.put(']');\n  }\n\n  forEach(f) {\n    f(this);\n    this.expr.forEach(f);\n  }\n}\n\nclass Brace extends CodeRep {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n\n  emit(ts) {\n    ts.put('{');\n    this.expr.emit(ts, false);\n    ts.put('}');\n  }\n\n  forEach(f) {\n    f(this);\n    this.expr.forEach(f);\n  }\n}\n\nclass NoIn extends CodeRep {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n\n  emit(ts) {\n    this.expr.emit(ts, true);\n  }\n\n  forEach(f) {\n    f(this);\n    this.expr.forEach(f);\n  }\n}\n\nclass ContainsIn extends CodeRep {\n  constructor(expr) {\n    super();\n    this.expr = expr;\n  }\n\n  emit(ts, noIn) {\n    if (noIn) {\n      ts.put('(');\n      this.expr.emit(ts, false);\n      ts.put(')');\n    } else {\n      this.expr.emit(ts, false);\n    }\n  }\n\n  forEach(f) {\n    f(this);\n    this.expr.forEach(f);\n  }\n}\n\nclass Seq extends CodeRep {\n  constructor(children) {\n    super();\n    this.children = children;\n  }\n\n  emit(ts, noIn) {\n    this.children.forEach(cr => cr.emit(ts, noIn));\n  }\n\n  forEach(f) {\n    f(this);\n    this.children.forEach(x => x.forEach(f));\n  }\n}\n\nclass Semi extends Token {\n  constructor() {\n    super(';');\n  }\n}\n\nclass CommaSep extends CodeRep {\n  constructor(children) {\n    super();\n    this.children = children;\n  }\n\n  emit(ts, noIn) {\n    let first = true;\n    this.children.forEach(cr => {\n      if (first) {\n        first = false;\n      } else {\n        ts.put(',');\n      }\n      cr.emit(ts, noIn);\n    });\n  }\n\n  forEach(f) {\n    f(this);\n    this.children.forEach(x => x.forEach(f));\n  }\n}\n\nclass SemiOp extends CodeRep {\n  constructor() {\n    super();\n  }\n\n  emit(ts) {\n    ts.putOptionalSemi();\n  }\n}\n\nmodule.exports = {\n  Precedence,\n  getPrecedence,\n  escapeStringLiteral,\n  CodeRep,\n  Empty,\n  Token,\n  RawToken,\n  NumberCodeRep,\n  Paren,\n  Bracket,\n  Brace,\n  NoIn,\n  ContainsIn,\n  Seq,\n  Semi,\n  CommaSep,\n  SemiOp,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}