{"ast":null,"code":"'use strict';\n\n// Remove unused variables and object properties which are initialized to constants.\nconst scope = require('shift-scope');\nconst reducer = require('shift-reducer');\nconst Shift = require('shift-ast/checked');\nconst getParents = require('../../helpers/parents');\nconst inlinable = require('../../helpers/inlinable');\nfunction isOnlyWritten(node, parents, lookup) {\n  if (node.type !== 'AssignmentTargetIdentifier') {\n    return false;\n  }\n  const vs = lookup.lookup(node);\n  if (vs.length === 1 && lookup.scope.variableList.indexOf(vs[0]) === -1) {\n    const reads = vs[0].references.filter(r => r.accessibility.isRead);\n    return reads.length === 0 || reads.every(r => {\n      if (!r.accessibility.isWrite) {\n        return false;\n      }\n      const parent = parents.get(r.node);\n      if (parent == null || !(parent.type === 'CompoundAssignmentExpression' || parent.type === 'UpdateExpression')) {\n        return false;\n      }\n      const gp = parents.get(parent);\n      return gp.type === 'ExpressionStatement';\n    });\n  }\n  return false;\n}\nmodule.exports = function removeUnused(ast) {\n  const globalScope = scope.default(ast);\n  const lookup = new scope.ScopeLookup(globalScope);\n  const parents = getParents(ast);\n  class RemoveUnused extends reducer.LazyCloneReducer {\n    reduceVariableDeclarationStatement(node, {\n      declaration\n    }) {\n      // This strips declarations of variables initialized to constants if those variables are never referred to.\n      const declarators = declaration.declarators.filter((d, i) => {\n        const oldD = node.declaration.declarators[i];\n        if (d.binding.type !== 'BindingIdentifier' || d.init == null || !(inlinable.includes(d.init.type) || d.init.type === 'FunctionExpression' || d.init.type === 'ObjectExpression' && d.init.properties.length === 0 || d.init.type === 'ArrayExpression' && d.init.elements.every(e => inlinable.includes(e.type)))) return true;\n        const v = lookup.lookup(oldD.binding)[0];\n        if (v.declarations.length !== 1 || lookup.scope.variableList.includes(v)) return true;\n        return v.references.length !== 1;\n      });\n      if (declarators.length === 0) {\n        return new Shift.EmptyStatement();\n      } else if (declarators.length === 1) {\n        const binding = declarators[0].binding;\n        if (binding.type === 'BindingIdentifier') {\n          const v = lookup.lookup(binding)[0];\n          if (v.references.every(ref => ref.node === binding) && !lookup.scope.variableList.includes(v)) {\n            if (declarators[0].init === null) {\n              return new Shift.EmptyStatement();\n            }\n            return new Shift.ExpressionStatement({\n              expression: declarators[0].init\n            });\n          }\n        }\n      }\n      if (declarators.length === declaration.declarators.length) {\n        return super.reduceVariableDeclarationStatement(node, {\n          declaration\n        });\n      }\n      return new Shift.VariableDeclarationStatement({\n        declaration: new Shift.VariableDeclaration({\n          kind: declaration.kind,\n          declarators\n        })\n      });\n    }\n    reduceVariableDeclarator(node, {\n      binding,\n      init\n    }) {\n      // This strips properties from object literals used to initialize variables provided that\n      // a.) no one ever refers to that variable except to read a static property of it,\n      // b.) no one ever tries to read that property, and\n      // c.) the object contains only data properties.\n      // TODO make this safe by asserting that all properties ever referred to are present on the object (so they never go up to Object.prototype)\n      if (init !== null && init.type === 'ObjectExpression' && init.properties.every(p => p.type === 'DataProperty')) {\n        const v = lookup.lookup(node.binding)[0];\n        const referencedNames = new Set();\n        if (v.references.every(r => {\n          if (r.node === node.binding) return true; // We don't care about the declaration itself.\n          const parent = parents.get(r.node);\n          if (parent.type !== 'StaticMemberExpression') return false;\n          referencedNames.add(parent.property);\n          return true;\n        })) {\n          const properties = init.properties.filter(p => {\n            return !(inlinable.includes(p.expression.type) || p.expression.type === 'FunctionExpression') || p.name.type !== 'StaticPropertyName' || referencedNames.has(p.name.value);\n          });\n          if (properties.length === init.properties.length) {\n            return super.reduceVariableDeclarator(node, {\n              binding,\n              init\n            });\n          }\n          const obj = new Shift.ObjectExpression({\n            properties\n          });\n          return new Shift.VariableDeclarator({\n            binding,\n            init: obj\n          });\n        }\n      }\n      return super.reduceVariableDeclarator(node, {\n        binding,\n        init\n      });\n    }\n    reduceAssignmentExpression(node, {\n      binding,\n      expression\n    }) {\n      if (isOnlyWritten(node.binding, parents, lookup)) {\n        return expression;\n      }\n      return super.reduceAssignmentExpression(node, {\n        binding,\n        expression\n      });\n    }\n    reduceCompoundAssignmentExpression(node, {\n      binding,\n      expression\n    }) {\n      if (isOnlyWritten(node.binding, parents, lookup)) {\n        return expression;\n      }\n      return super.reduceCompoundAssignmentExpression(node, {\n        binding,\n        expression\n      });\n    }\n  }\n  return reducer.default(new RemoveUnused(), ast);\n};","map":{"version":3,"names":["scope","require","reducer","Shift","getParents","inlinable","isOnlyWritten","node","parents","lookup","type","vs","length","variableList","indexOf","reads","references","filter","r","accessibility","isRead","every","isWrite","parent","get","gp","module","exports","removeUnused","ast","globalScope","default","ScopeLookup","RemoveUnused","LazyCloneReducer","reduceVariableDeclarationStatement","declaration","declarators","d","i","oldD","binding","init","includes","properties","elements","e","v","declarations","EmptyStatement","ref","ExpressionStatement","expression","VariableDeclarationStatement","VariableDeclaration","kind","reduceVariableDeclarator","p","referencedNames","Set","add","property","name","has","value","obj","ObjectExpression","VariableDeclarator","reduceAssignmentExpression","reduceCompoundAssignmentExpression"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/unminify/src/transforms/unsafe/remove-unused.js"],"sourcesContent":["'use strict';\n\n// Remove unused variables and object properties which are initialized to constants.\n\nconst scope = require('shift-scope');\nconst reducer = require('shift-reducer');\nconst Shift = require('shift-ast/checked');\n\nconst getParents = require('../../helpers/parents');\nconst inlinable = require('../../helpers/inlinable');\n\n\nfunction isOnlyWritten(node, parents, lookup) {\n  if (node.type !== 'AssignmentTargetIdentifier') {\n    return false;\n  }\n  const vs = lookup.lookup(node);\n  if (vs.length === 1 && lookup.scope.variableList.indexOf(vs[0]) === -1) {\n    const reads = vs[0].references.filter(r => r.accessibility.isRead);\n\n    return reads.length === 0 || reads.every(r => {\n      if (!r.accessibility.isWrite) {\n        return false;\n      }\n      const parent = parents.get(r.node);\n      if (parent == null || !(parent.type === 'CompoundAssignmentExpression' || parent.type === 'UpdateExpression')) {\n        return false;\n      }\n\n      const gp = parents.get(parent);\n      return gp.type === 'ExpressionStatement';\n    });\n  }\n  return false;\n}\n\nmodule.exports = function removeUnused(ast) {\n  const globalScope = scope.default(ast);\n  const lookup = new scope.ScopeLookup(globalScope);\n  const parents = getParents(ast);\n\n  class RemoveUnused extends reducer.LazyCloneReducer {\n    reduceVariableDeclarationStatement(node, { declaration }) {\n      // This strips declarations of variables initialized to constants if those variables are never referred to.\n      const declarators = declaration.declarators.filter((d, i) => {\n        const oldD = node.declaration.declarators[i];\n        if (d.binding.type !== 'BindingIdentifier' || d.init == null || !(\n          inlinable.includes(d.init.type)\n          || d.init.type === 'FunctionExpression'\n          || d.init.type === 'ObjectExpression' && d.init.properties.length === 0\n          || d.init.type === 'ArrayExpression' && d.init.elements.every(e => inlinable.includes(e.type))\n        )) return true;\n        const v = lookup.lookup(oldD.binding)[0];\n        if (v.declarations.length !== 1 || lookup.scope.variableList.includes(v)) return true;\n        return v.references.length !== 1;\n      });\n      if (declarators.length === 0) {\n        return new Shift.EmptyStatement;\n      } else if (declarators.length === 1) {\n        const binding = declarators[0].binding;\n        if (binding.type === 'BindingIdentifier') {\n          const v = lookup.lookup(binding)[0];\n          if (v.references.every(ref => ref.node === binding) && !lookup.scope.variableList.includes(v)) {\n            if (declarators[0].init === null) {\n              return new Shift.EmptyStatement;\n            }\n            return new Shift.ExpressionStatement({ expression: declarators[0].init });\n          }\n        }\n      }\n\n      if (declarators.length === declaration.declarators.length) {\n        return super.reduceVariableDeclarationStatement(node, { declaration });\n      }\n\n      return new Shift.VariableDeclarationStatement({ declaration: new Shift.VariableDeclaration({ kind: declaration.kind, declarators }) });\n    }\n\n    reduceVariableDeclarator(node, { binding, init }) {\n      // This strips properties from object literals used to initialize variables provided that\n      // a.) no one ever refers to that variable except to read a static property of it,\n      // b.) no one ever tries to read that property, and\n      // c.) the object contains only data properties.\n      // TODO make this safe by asserting that all properties ever referred to are present on the object (so they never go up to Object.prototype)\n      if (init !== null && init.type === 'ObjectExpression' && init.properties.every(p => p.type === 'DataProperty')) {\n        const v = lookup.lookup(node.binding)[0];\n        const referencedNames = new Set;\n        if (v.references.every(r => {\n          if (r.node === node.binding) return true; // We don't care about the declaration itself.\n          const parent = parents.get(r.node);\n          if (parent.type !== 'StaticMemberExpression') return false;\n          referencedNames.add(parent.property);\n          return true;\n        })) {\n          const properties = init.properties.filter(p => {\n            return !(inlinable.includes(p.expression.type) || p.expression.type === 'FunctionExpression') || p.name.type !== 'StaticPropertyName' || referencedNames.has(p.name.value);\n          });\n          if (properties.length === init.properties.length) {\n            return super.reduceVariableDeclarator(node, { binding, init });\n          }\n          const obj = new Shift.ObjectExpression({ properties });\n          return new Shift.VariableDeclarator({ binding, init: obj });\n        }\n      }\n      return super.reduceVariableDeclarator(node, { binding, init });\n    }\n\n    reduceAssignmentExpression(node, { binding, expression }) {\n      if (isOnlyWritten(node.binding, parents, lookup)) {\n        return expression;\n      }\n      return super.reduceAssignmentExpression(node, { binding, expression });\n    }\n\n    reduceCompoundAssignmentExpression(node, { binding, expression }) {\n      if (isOnlyWritten(node.binding, parents, lookup)) {\n        return expression;\n      }\n      return super.reduceCompoundAssignmentExpression(node, { binding, expression });\n    }\n  }\n\n  return reducer.default(new RemoveUnused, ast);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}