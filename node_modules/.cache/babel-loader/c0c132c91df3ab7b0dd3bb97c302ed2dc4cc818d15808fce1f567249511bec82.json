{"ast":null,"code":"/**\n * Copyright 2015 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst MultiMap = require('multimap');\nconst {\n  reduce,\n  MonoidalReducer\n} = require('shift-reducer');\nconst ScopeState = require('./scope-state');\nconst {\n  Accessibility,\n  Reference\n} = require('./reference');\nconst {\n  DeclarationType\n} = require('./declaration');\nconst {\n  ScopeType\n} = require('./scope');\nconst StrictnessReducer = require('./strictness-reducer');\nfunction asSimpleFunctionDeclarationName(statement) {\n  return statement.type === 'FunctionDeclaration' && !statement.isGenerator && !statement.isAsync ? statement.name : statement.type === 'LabeledStatement' ? asSimpleFunctionDeclarationName(statement.body) : null;\n}\nfunction getUnnestedSimpleFunctionDeclarationNames(statements) {\n  let names = statements.map(asSimpleFunctionDeclarationName).filter(f => f != null);\n  // if a function declaration occurs twice in the same scope, neither can be B.3.3 hoisted\n  // see https://github.com/tc39/ecma262/issues/913\n\n  let hist = names.reduce((memo, id) => {\n    if (id.name in memo) {\n      ++memo[id.name];\n    } else {\n      memo[id.name] = 1;\n    }\n    return memo;\n  }, Object.create(null));\n  return names.filter(id => hist[id.name] === 1);\n}\nmodule.exports = class ScopeAnalyzer extends MonoidalReducer {\n  constructor(program) {\n    super(ScopeState);\n    this.sloppySet = program.type === 'Script' ? StrictnessReducer.analyze(program) : new Set();\n  }\n  fold(list, a) {\n    return list.reduce((memo, x) => this.append(memo, x), a == null ? this.identity : a);\n  }\n  static analyze(program) {\n    return reduce(new this(program), program).children[0];\n  }\n  finishFunction(fnNode, params, body) {\n    const isArrowFn = fnNode.type === 'ArrowExpression';\n    const fnType = isArrowFn ? ScopeType.ARROW_FUNCTION : ScopeType.FUNCTION;\n    if (params.hasParameterExpressions) {\n      return params.withoutParameterExpressions().concat(body.finish(fnNode, fnType, {\n        shouldResolveArguments: false,\n        paramsToBlockB33Hoisting: params,\n        shouldB33: this.sloppySet.has(fnNode)\n      })).finish(fnNode, ScopeType.PARAMETERS, {\n        shouldResolveArguments: !isArrowFn\n      });\n    }\n    return params.concat(body).finish(fnNode, fnType, {\n      shouldResolveArguments: !isArrowFn,\n      shouldB33: this.sloppySet.has(fnNode)\n    });\n  }\n  reduceArrowExpression(node, {\n    params,\n    body\n  }) {\n    return this.finishFunction(node, params, body);\n  }\n  reduceAssignmentExpression(node, {\n    binding,\n    expression\n  }) {\n    return super.reduceAssignmentExpression(node, {\n      binding: binding.addReferences(Accessibility.WRITE),\n      expression\n    });\n  }\n  reduceAssignmentTargetIdentifier(node) {\n    return new ScopeState({\n      atsForParent: [node]\n    });\n  }\n  reduceBindingIdentifier(node) {\n    if (node.name === '*default*') {\n      return new ScopeState();\n    }\n    return new ScopeState({\n      bindingsForParent: [node]\n    });\n  }\n  reduceBindingPropertyIdentifier(node, {\n    binding,\n    init\n  }) {\n    const s = super.reduceBindingPropertyIdentifier(node, {\n      binding,\n      init\n    });\n    if (init) {\n      return s.withParameterExpressions();\n    }\n    return s;\n  }\n  reduceBindingPropertyProperty(node, {\n    name,\n    binding\n  }) {\n    const s = super.reduceBindingPropertyProperty(node, {\n      name,\n      binding\n    });\n    if (node.name.type === 'ComputedPropertyName') {\n      return s.withParameterExpressions();\n    }\n    return s;\n  }\n  reduceBindingWithDefault(node, {\n    binding,\n    init\n  }) {\n    return super.reduceBindingWithDefault(node, {\n      binding,\n      init\n    }).withParameterExpressions();\n  }\n  reduceBlock(node, {\n    statements\n  }) {\n    return super.reduceBlock(node, {\n      statements\n    }).withPotentialVarFunctions(getUnnestedSimpleFunctionDeclarationNames(node.statements)).finish(node, ScopeType.BLOCK);\n  }\n  reduceCallExpression(node, {\n    callee,\n    arguments: _arguments\n  }) {\n    const s = super.reduceCallExpression(node, {\n      callee,\n      arguments: _arguments\n    });\n    if (node.callee.type === 'IdentifierExpression' && node.callee.name === 'eval') {\n      return s.taint();\n    }\n    return s;\n  }\n  reduceCatchClause(node, {\n    binding,\n    body\n  }) {\n    return super.reduceCatchClause(node, {\n      binding: binding == null ? null : binding.addDeclarations(DeclarationType.CATCH_PARAMETER),\n      body\n    }).finish(node, ScopeType.CATCH);\n  }\n  reduceClassDeclaration(node, {\n    name,\n    super: _super,\n    elements\n  }) {\n    let s = super.reduceClassDeclaration(node, {\n      name,\n      super: _super,\n      elements\n    }).addDeclarations(DeclarationType.CLASS_NAME).finish(node, ScopeType.CLASS_NAME);\n    return s.concat(name.addDeclarations(DeclarationType.CLASS_DECLARATION));\n  }\n  reduceClassExpression(node, {\n    name,\n    super: _super,\n    elements\n  }) {\n    return super.reduceClassExpression(node, {\n      name,\n      super: _super,\n      elements\n    }).addDeclarations(DeclarationType.CLASS_NAME).finish(node, ScopeType.CLASS_NAME);\n  }\n  reduceCompoundAssignmentExpression(node, {\n    binding,\n    expression\n  }) {\n    return super.reduceCompoundAssignmentExpression(node, {\n      binding: binding.addReferences(Accessibility.READWRITE),\n      expression\n    });\n  }\n  reduceComputedMemberExpression(node, {\n    object,\n    expression\n  }) {\n    return super.reduceComputedMemberExpression(node, {\n      object,\n      expression\n    }).withParameterExpressions();\n  }\n  reduceForInStatement(node, {\n    left,\n    right,\n    body\n  }) {\n    return super.reduceForInStatement(node, {\n      left: left.addReferences(Accessibility.WRITE),\n      right,\n      body\n    }).finish(node, ScopeType.BLOCK);\n  }\n  reduceForAwaitStatement(node, {\n    left,\n    right,\n    body\n  }) {\n    return super.reduceForAwaitStatement(node, {\n      left: left.addReferences(Accessibility.WRITE),\n      right,\n      body\n    }).finish(node, ScopeType.BLOCK);\n  }\n  reduceForOfStatement(node, {\n    left,\n    right,\n    body\n  }) {\n    return super.reduceForOfStatement(node, {\n      left: left.addReferences(Accessibility.WRITE),\n      right,\n      body\n    }).finish(node, ScopeType.BLOCK);\n  }\n  reduceForStatement(node, {\n    init,\n    test,\n    update,\n    body\n  }) {\n    return super.reduceForStatement(node, {\n      init: init ? init.withoutBindingsForParent() : init,\n      test,\n      update,\n      body\n    }).finish(node, ScopeType.BLOCK);\n  }\n  reduceFormalParameters(node, {\n    items,\n    rest\n  }) {\n    let s = rest ? rest : new ScopeState();\n    items.forEach((item, ind) => {\n      s = s.concat(item.hasParameterExpressions ? item.finish(node.items[ind], ScopeType.PARAMETER_EXPRESSION) : item);\n    });\n    return s.addDeclarations(DeclarationType.PARAMETER);\n  }\n  reduceFunctionDeclaration(node, {\n    name,\n    params,\n    body\n  }) {\n    return name.concat(this.finishFunction(node, params, body)).addFunctionDeclaration();\n  }\n  reduceFunctionExpression(node, {\n    name,\n    params,\n    body\n  }) {\n    let s = this.finishFunction(node, params, body);\n    if (name) {\n      return name.concat(s).addDeclarations(DeclarationType.FUNCTION_NAME).finish(node, ScopeType.FUNCTION_NAME);\n    }\n    return s;\n  }\n  reduceGetter(node, {\n    name,\n    body\n  }) {\n    return name.concat(body.finish(node, ScopeType.FUNCTION, {\n      shouldResolveArguments: true,\n      shouldB33: this.sloppySet.has(node)\n    }));\n  }\n  reduceIdentifierExpression(node) {\n    return new ScopeState({\n      freeIdentifiers: new MultiMap([[node.name, new Reference(node, Accessibility.READ)]])\n    });\n  }\n  reduceIfStatement(node, {\n    test,\n    consequent,\n    alternate\n  }) {\n    // These \"blocks\" are synthetic; see https://tc39.es/ecma262/#sec-functiondeclarations-in-ifstatement-statement-clauses\n    let consequentFunctionDeclName = asSimpleFunctionDeclarationName(node.consequent);\n    if (consequentFunctionDeclName != null) {\n      consequent = consequent.withPotentialVarFunctions([consequentFunctionDeclName]).finish(node.consequent, ScopeType.BLOCK);\n    }\n    if (node.alternate != null) {\n      let alternateFunctionDeclName = asSimpleFunctionDeclarationName(node.alternate);\n      if (alternateFunctionDeclName != null) {\n        alternate = alternate.withPotentialVarFunctions([alternateFunctionDeclName]).finish(node.alternate, ScopeType.BLOCK);\n      }\n    }\n    return super.reduceIfStatement(node, {\n      test,\n      consequent,\n      alternate\n    });\n  }\n  reduceImport(node, {\n    moduleSpecifier,\n    defaultBinding,\n    namedImports\n  }) {\n    return super.reduceImport(node, {\n      moduleSpecifier,\n      defaultBinding,\n      namedImports\n    }).addDeclarations(DeclarationType.IMPORT);\n  }\n  reduceMethod(node, {\n    name,\n    params,\n    body\n  }) {\n    return name.concat(this.finishFunction(node, params, body));\n  }\n  reduceModule(node, {\n    directives,\n    items\n  }) {\n    return super.reduceModule(node, {\n      directives,\n      items\n    }).finish(node, ScopeType.MODULE);\n  }\n  reduceScript(node, {\n    directives,\n    statements\n  }) {\n    return super.reduceScript(node, {\n      directives,\n      statements\n    }).finish(node, ScopeType.SCRIPT, {\n      shouldB33: !node.directives.some(d => d.rawValue === 'use strict')\n    });\n  }\n  reduceSetter(node, {\n    name,\n    param,\n    body\n  }) {\n    if (param.hasParameterExpressions) {\n      param = param.finish(node, ScopeType.PARAMETER_EXPRESSION);\n    }\n    return name.concat(this.finishFunction(node, param.addDeclarations(DeclarationType.PARAMETER), body));\n  }\n  reduceSwitchStatement(node, {\n    discriminant,\n    cases\n  }) {\n    return this.fold(cases).withPotentialVarFunctions(getUnnestedSimpleFunctionDeclarationNames([].concat(...node.cases.map(c => c.consequent)))).finish(node, ScopeType.BLOCK).concat(discriminant);\n  }\n  reduceSwitchStatementWithDefault(node, {\n    discriminant,\n    preDefaultCases,\n    defaultCase,\n    postDefaultCases\n  }) {\n    const functionDeclarations = getUnnestedSimpleFunctionDeclarationNames([].concat(...node.preDefaultCases.concat([node.defaultCase], node.postDefaultCases).map(c => c.consequent)));\n    const cases = preDefaultCases.concat([defaultCase], postDefaultCases);\n    return this.fold(cases).withPotentialVarFunctions(functionDeclarations).finish(node, ScopeType.BLOCK).concat(discriminant);\n  }\n  reduceUnaryExpression(node, {\n    operand\n  }) {\n    if (node.operator === 'delete' && node.operand.type === 'IdentifierExpression') {\n      // 'delete x' is a special case.\n      return new ScopeState({\n        freeIdentifiers: new MultiMap([[node.operand.name, new Reference(node.operand, Accessibility.DELETE)]])\n      });\n    }\n    return super.reduceUnaryExpression(node, {\n      operand\n    });\n  }\n  reduceUpdateExpression(node, {\n    operand\n  }) {\n    return operand.addReferences(Accessibility.READWRITE);\n  }\n  reduceVariableDeclaration(node, {\n    declarators\n  }) {\n    return super.reduceVariableDeclaration(node, {\n      declarators\n    }).addDeclarations(DeclarationType.fromVarDeclKind(node.kind), true);\n    // passes bindingsForParent up, for for-in and for-of to add their write-references\n  }\n  reduceVariableDeclarationStatement(node, {\n    declaration\n  }) {\n    return declaration.withoutBindingsForParent();\n  }\n  reduceVariableDeclarator(node, {\n    binding,\n    init\n  }) {\n    const s = super.reduceVariableDeclarator(node, {\n      binding,\n      init\n    });\n    if (init) {\n      return s.addReferences(Accessibility.WRITE, true);\n    }\n    return s;\n  }\n  reduceWithStatement(node, {\n    object,\n    body\n  }) {\n    return super.reduceWithStatement(node, {\n      object,\n      body: body.finish(node, ScopeType.WITH)\n    });\n  }\n};","map":{"version":3,"names":["MultiMap","require","reduce","MonoidalReducer","ScopeState","Accessibility","Reference","DeclarationType","ScopeType","StrictnessReducer","asSimpleFunctionDeclarationName","statement","type","isGenerator","isAsync","name","body","getUnnestedSimpleFunctionDeclarationNames","statements","names","map","filter","f","hist","memo","id","Object","create","module","exports","ScopeAnalyzer","constructor","program","sloppySet","analyze","Set","fold","list","a","x","append","identity","children","finishFunction","fnNode","params","isArrowFn","fnType","ARROW_FUNCTION","FUNCTION","hasParameterExpressions","withoutParameterExpressions","concat","finish","shouldResolveArguments","paramsToBlockB33Hoisting","shouldB33","has","PARAMETERS","reduceArrowExpression","node","reduceAssignmentExpression","binding","expression","addReferences","WRITE","reduceAssignmentTargetIdentifier","atsForParent","reduceBindingIdentifier","bindingsForParent","reduceBindingPropertyIdentifier","init","s","withParameterExpressions","reduceBindingPropertyProperty","reduceBindingWithDefault","reduceBlock","withPotentialVarFunctions","BLOCK","reduceCallExpression","callee","arguments","_arguments","taint","reduceCatchClause","addDeclarations","CATCH_PARAMETER","CATCH","reduceClassDeclaration","super","_super","elements","CLASS_NAME","CLASS_DECLARATION","reduceClassExpression","reduceCompoundAssignmentExpression","READWRITE","reduceComputedMemberExpression","object","reduceForInStatement","left","right","reduceForAwaitStatement","reduceForOfStatement","reduceForStatement","test","update","withoutBindingsForParent","reduceFormalParameters","items","rest","forEach","item","ind","PARAMETER_EXPRESSION","PARAMETER","reduceFunctionDeclaration","addFunctionDeclaration","reduceFunctionExpression","FUNCTION_NAME","reduceGetter","reduceIdentifierExpression","freeIdentifiers","READ","reduceIfStatement","consequent","alternate","consequentFunctionDeclName","alternateFunctionDeclName","reduceImport","moduleSpecifier","defaultBinding","namedImports","IMPORT","reduceMethod","reduceModule","directives","MODULE","reduceScript","SCRIPT","some","d","rawValue","reduceSetter","param","reduceSwitchStatement","discriminant","cases","c","reduceSwitchStatementWithDefault","preDefaultCases","defaultCase","postDefaultCases","functionDeclarations","reduceUnaryExpression","operand","operator","DELETE","reduceUpdateExpression","reduceVariableDeclaration","declarators","fromVarDeclKind","kind","reduceVariableDeclarationStatement","declaration","reduceVariableDeclarator","reduceWithStatement","WITH"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/shift-scope/src/scope-analyzer.js"],"sourcesContent":["/**\n * Copyright 2015 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst MultiMap = require('multimap');\nconst { reduce, MonoidalReducer } = require('shift-reducer');\nconst ScopeState = require('./scope-state');\nconst { Accessibility, Reference } = require('./reference');\nconst { DeclarationType } = require('./declaration');\nconst { ScopeType } = require('./scope');\nconst StrictnessReducer = require('./strictness-reducer');\n\nfunction asSimpleFunctionDeclarationName(statement) {\n  return statement.type === 'FunctionDeclaration' && !statement.isGenerator && !statement.isAsync\n    ? statement.name\n    : statement.type === 'LabeledStatement'\n      ? asSimpleFunctionDeclarationName(statement.body)\n      : null;\n}\n\nfunction getUnnestedSimpleFunctionDeclarationNames(statements) {\n  let names = statements.map(asSimpleFunctionDeclarationName).filter(f => f != null);\n  // if a function declaration occurs twice in the same scope, neither can be B.3.3 hoisted\n  // see https://github.com/tc39/ecma262/issues/913\n\n  let hist = names.reduce((memo, id) => {\n    if (id.name in memo) {\n      ++memo[id.name];\n    } else {\n      memo[id.name] = 1;\n    }\n    return memo;\n  }, Object.create(null));\n  return names.filter(id => hist[id.name] === 1);\n}\n\nmodule.exports = class ScopeAnalyzer extends MonoidalReducer {\n  constructor(program) {\n    super(ScopeState);\n    this.sloppySet = program.type === 'Script' ? StrictnessReducer.analyze(program) : new Set;\n  }\n\n  fold(list, a) {\n    return list.reduce((memo, x) => this.append(memo, x), a == null ? this.identity : a);\n  }\n\n  static analyze(program) {\n    return reduce(new this(program), program).children[0];\n  }\n\n  finishFunction(fnNode, params, body) {\n    const isArrowFn = fnNode.type === 'ArrowExpression';\n    const fnType = isArrowFn ? ScopeType.ARROW_FUNCTION : ScopeType.FUNCTION;\n    if (params.hasParameterExpressions) {\n      return params\n        .withoutParameterExpressions()\n        .concat(body.finish(fnNode, fnType, { shouldResolveArguments: false, paramsToBlockB33Hoisting: params, shouldB33: this.sloppySet.has(fnNode) }))\n        .finish(fnNode, ScopeType.PARAMETERS, { shouldResolveArguments: !isArrowFn });\n    }\n    return params.concat(body).finish(fnNode, fnType, { shouldResolveArguments: !isArrowFn, shouldB33: this.sloppySet.has(fnNode) });\n  }\n\n  reduceArrowExpression(node, { params, body }) {\n    return this.finishFunction(node, params, body);\n  }\n\n  reduceAssignmentExpression(node, { binding, expression }) {\n    return super.reduceAssignmentExpression(node, {\n      binding: binding.addReferences(Accessibility.WRITE),\n      expression,\n    });\n  }\n\n  reduceAssignmentTargetIdentifier(node) {\n    return new ScopeState({ atsForParent: [node] });\n  }\n\n  reduceBindingIdentifier(node) {\n    if (node.name === '*default*') {\n      return new ScopeState;\n    }\n    return new ScopeState({ bindingsForParent: [node] });\n  }\n\n  reduceBindingPropertyIdentifier(node, { binding, init }) {\n    const s = super.reduceBindingPropertyIdentifier(node, { binding, init });\n    if (init) {\n      return s.withParameterExpressions();\n    }\n    return s;\n  }\n\n  reduceBindingPropertyProperty(node, { name, binding }) {\n    const s = super.reduceBindingPropertyProperty(node, { name, binding });\n    if (node.name.type === 'ComputedPropertyName') {\n      return s.withParameterExpressions();\n    }\n    return s;\n  }\n\n  reduceBindingWithDefault(node, { binding, init }) {\n    return super.reduceBindingWithDefault(node, { binding, init }).withParameterExpressions();\n  }\n\n  reduceBlock(node, { statements }) {\n    return super\n      .reduceBlock(node, { statements })\n      .withPotentialVarFunctions(getUnnestedSimpleFunctionDeclarationNames(node.statements))\n      .finish(node, ScopeType.BLOCK);\n  }\n\n  reduceCallExpression(node, { callee, arguments: _arguments }) {\n    const s = super.reduceCallExpression(node, { callee, arguments: _arguments });\n    if (node.callee.type === 'IdentifierExpression' && node.callee.name === 'eval') {\n      return s.taint();\n    }\n    return s;\n  }\n\n  reduceCatchClause(node, { binding, body }) {\n    return super\n      .reduceCatchClause(node, {\n        binding: binding == null ? null : binding.addDeclarations(DeclarationType.CATCH_PARAMETER),\n        body,\n      })\n      .finish(node, ScopeType.CATCH);\n  }\n\n  reduceClassDeclaration(node, { name, super: _super, elements }) {\n    let s = super\n      .reduceClassDeclaration(node, { name, super: _super, elements })\n      .addDeclarations(DeclarationType.CLASS_NAME)\n      .finish(node, ScopeType.CLASS_NAME);\n    return s.concat(name.addDeclarations(DeclarationType.CLASS_DECLARATION));\n  }\n\n  reduceClassExpression(node, { name, super: _super, elements }) {\n    return super\n      .reduceClassExpression(node, { name, super: _super, elements })\n      .addDeclarations(DeclarationType.CLASS_NAME)\n      .finish(node, ScopeType.CLASS_NAME);\n  }\n\n  reduceCompoundAssignmentExpression(node, { binding, expression }) {\n    return super.reduceCompoundAssignmentExpression(node, {\n      binding: binding.addReferences(Accessibility.READWRITE),\n      expression,\n    });\n  }\n\n  reduceComputedMemberExpression(node, { object, expression }) {\n    return super\n      .reduceComputedMemberExpression(node, { object, expression })\n      .withParameterExpressions();\n  }\n\n  reduceForInStatement(node, { left, right, body }) {\n    return super\n      .reduceForInStatement(node, { left: left.addReferences(Accessibility.WRITE), right, body })\n      .finish(node, ScopeType.BLOCK);\n  }\n\n  reduceForAwaitStatement(node, { left, right, body }) {\n    return super\n      .reduceForAwaitStatement(node, { left: left.addReferences(Accessibility.WRITE), right, body })\n      .finish(node, ScopeType.BLOCK);\n  }\n\n  reduceForOfStatement(node, { left, right, body }) {\n    return super\n      .reduceForOfStatement(node, { left: left.addReferences(Accessibility.WRITE), right, body })\n      .finish(node, ScopeType.BLOCK);\n  }\n\n  reduceForStatement(node, { init, test, update, body }) {\n    return super\n      .reduceForStatement(node, {\n        init: init ? init.withoutBindingsForParent() : init,\n        test,\n        update,\n        body,\n      })\n      .finish(node, ScopeType.BLOCK);\n  }\n\n  reduceFormalParameters(node, { items, rest }) {\n    let s = rest ? rest : new ScopeState;\n    items.forEach((item, ind) => {\n      s = s.concat(\n        item.hasParameterExpressions\n          ? item.finish(node.items[ind], ScopeType.PARAMETER_EXPRESSION)\n          : item\n      );\n    });\n    return s.addDeclarations(DeclarationType.PARAMETER);\n  }\n\n  reduceFunctionDeclaration(node, { name, params, body }) {\n    return name.concat(this.finishFunction(node, params, body)).addFunctionDeclaration();\n  }\n\n  reduceFunctionExpression(node, { name, params, body }) {\n    let s = this.finishFunction(node, params, body);\n    if (name) {\n      return name\n        .concat(s)\n        .addDeclarations(DeclarationType.FUNCTION_NAME)\n        .finish(node, ScopeType.FUNCTION_NAME);\n    }\n    return s;\n  }\n\n  reduceGetter(node, { name, body }) {\n    return name.concat(\n      body.finish(node, ScopeType.FUNCTION, {\n        shouldResolveArguments: true,\n        shouldB33: this.sloppySet.has(node),\n      })\n    );\n  }\n\n  reduceIdentifierExpression(node) {\n    return new ScopeState({\n      freeIdentifiers: new MultiMap([[node.name, new Reference(node, Accessibility.READ)]]),\n    });\n  }\n\n  reduceIfStatement(node, { test, consequent, alternate }) {\n    // These \"blocks\" are synthetic; see https://tc39.es/ecma262/#sec-functiondeclarations-in-ifstatement-statement-clauses\n    let consequentFunctionDeclName = asSimpleFunctionDeclarationName(node.consequent);\n    if (consequentFunctionDeclName != null) {\n      consequent = consequent.withPotentialVarFunctions([consequentFunctionDeclName])\n        .finish(node.consequent, ScopeType.BLOCK);\n    }\n    if (node.alternate != null) {\n      let alternateFunctionDeclName = asSimpleFunctionDeclarationName(node.alternate);\n      if (alternateFunctionDeclName != null) {\n        alternate = alternate.withPotentialVarFunctions([alternateFunctionDeclName])\n          .finish(node.alternate, ScopeType.BLOCK);\n      }\n    }\n    return super\n      .reduceIfStatement(node, { test, consequent, alternate });\n  }\n\n  reduceImport(node, { moduleSpecifier, defaultBinding, namedImports }) {\n    return super\n      .reduceImport(node, { moduleSpecifier, defaultBinding, namedImports })\n      .addDeclarations(DeclarationType.IMPORT);\n  }\n\n  reduceMethod(node, { name, params, body }) {\n    return name.concat(this.finishFunction(node, params, body));\n  }\n\n  reduceModule(node, { directives, items }) {\n    return super.reduceModule(node, { directives, items }).finish(node, ScopeType.MODULE);\n  }\n\n  reduceScript(node, { directives, statements }) {\n    return super.reduceScript(node, { directives, statements }).finish(node, ScopeType.SCRIPT, { shouldB33: !node.directives.some(d => d.rawValue === 'use strict') });\n  }\n\n  reduceSetter(node, { name, param, body }) {\n    if (param.hasParameterExpressions) {\n      param = param.finish(node, ScopeType.PARAMETER_EXPRESSION);\n    }\n    return name.concat(\n      this.finishFunction(node, param.addDeclarations(DeclarationType.PARAMETER), body)\n    );\n  }\n\n  reduceSwitchStatement(node, { discriminant, cases }) {\n    return this\n      .fold(cases)\n      .withPotentialVarFunctions(getUnnestedSimpleFunctionDeclarationNames([].concat(...node.cases.map(c => c.consequent))))\n      .finish(node, ScopeType.BLOCK)\n      .concat(discriminant);\n  }\n\n  reduceSwitchStatementWithDefault(node, { discriminant, preDefaultCases, defaultCase, postDefaultCases }) {\n    const functionDeclarations = getUnnestedSimpleFunctionDeclarationNames([].concat(\n      ...node.preDefaultCases.concat([node.defaultCase], node.postDefaultCases).map(c => c.consequent)\n    ));\n    const cases = preDefaultCases.concat([defaultCase], postDefaultCases);\n    return this\n      .fold(cases)\n      .withPotentialVarFunctions(functionDeclarations)\n      .finish(node, ScopeType.BLOCK)\n      .concat(discriminant);\n  }\n\n  reduceUnaryExpression(node, { operand }) {\n    if (node.operator === 'delete' && node.operand.type === 'IdentifierExpression') {\n      // 'delete x' is a special case.\n      return new ScopeState({ freeIdentifiers: new MultiMap([[node.operand.name, new Reference(node.operand, Accessibility.DELETE)]]) });\n    }\n    return super.reduceUnaryExpression(node, { operand });\n  }\n\n  reduceUpdateExpression(node, { operand }) {\n    return operand.addReferences(Accessibility.READWRITE);\n  }\n\n  reduceVariableDeclaration(node, { declarators }) {\n    return super\n      .reduceVariableDeclaration(node, { declarators })\n      .addDeclarations(DeclarationType.fromVarDeclKind(node.kind), true);\n    // passes bindingsForParent up, for for-in and for-of to add their write-references\n  }\n\n  reduceVariableDeclarationStatement(node, { declaration }) {\n    return declaration.withoutBindingsForParent();\n  }\n\n  reduceVariableDeclarator(node, { binding, init }) {\n    const s = super.reduceVariableDeclarator(node, { binding, init });\n    if (init) {\n      return s.addReferences(Accessibility.WRITE, true);\n    }\n    return s;\n  }\n\n  reduceWithStatement(node, { object, body }) {\n    return super.reduceWithStatement(node, { object, body: body.finish(node, ScopeType.WITH) });\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}