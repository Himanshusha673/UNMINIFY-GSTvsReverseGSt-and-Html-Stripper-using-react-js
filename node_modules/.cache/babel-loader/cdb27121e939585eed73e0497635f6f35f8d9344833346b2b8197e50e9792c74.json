{"ast":null,"code":"/**\n * Copyright 2014 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {\n  getHexValue,\n  isLineTerminator,\n  isWhiteSpace,\n  isIdentifierStart,\n  isIdentifierPart,\n  isDecimalDigit\n} = require('./utils');\nconst {\n  ErrorMessages\n} = require('./errors');\nconst TokenClass = {\n  Eof: {\n    name: '<End>'\n  },\n  Ident: {\n    name: 'Identifier',\n    isIdentifierName: true\n  },\n  Keyword: {\n    name: 'Keyword',\n    isIdentifierName: true\n  },\n  NumericLiteral: {\n    name: 'Numeric'\n  },\n  TemplateElement: {\n    name: 'Template'\n  },\n  Punctuator: {\n    name: 'Punctuator'\n  },\n  StringLiteral: {\n    name: 'String'\n  },\n  RegularExpression: {\n    name: 'RegularExpression'\n  },\n  Illegal: {\n    name: 'Illegal'\n  }\n};\nconst TokenType = {\n  EOS: {\n    klass: TokenClass.Eof,\n    name: 'EOS'\n  },\n  LPAREN: {\n    klass: TokenClass.Punctuator,\n    name: '('\n  },\n  RPAREN: {\n    klass: TokenClass.Punctuator,\n    name: ')'\n  },\n  LBRACK: {\n    klass: TokenClass.Punctuator,\n    name: '['\n  },\n  RBRACK: {\n    klass: TokenClass.Punctuator,\n    name: ']'\n  },\n  LBRACE: {\n    klass: TokenClass.Punctuator,\n    name: '{'\n  },\n  RBRACE: {\n    klass: TokenClass.Punctuator,\n    name: '}'\n  },\n  COLON: {\n    klass: TokenClass.Punctuator,\n    name: ':'\n  },\n  SEMICOLON: {\n    klass: TokenClass.Punctuator,\n    name: ';'\n  },\n  PERIOD: {\n    klass: TokenClass.Punctuator,\n    name: '.'\n  },\n  ELLIPSIS: {\n    klass: TokenClass.Punctuator,\n    name: '...'\n  },\n  ARROW: {\n    klass: TokenClass.Punctuator,\n    name: '=>'\n  },\n  CONDITIONAL: {\n    klass: TokenClass.Punctuator,\n    name: '?'\n  },\n  INC: {\n    klass: TokenClass.Punctuator,\n    name: '++'\n  },\n  DEC: {\n    klass: TokenClass.Punctuator,\n    name: '--'\n  },\n  ASSIGN: {\n    klass: TokenClass.Punctuator,\n    name: '='\n  },\n  ASSIGN_BIT_OR: {\n    klass: TokenClass.Punctuator,\n    name: '|='\n  },\n  ASSIGN_BIT_XOR: {\n    klass: TokenClass.Punctuator,\n    name: '^='\n  },\n  ASSIGN_BIT_AND: {\n    klass: TokenClass.Punctuator,\n    name: '&='\n  },\n  ASSIGN_SHL: {\n    klass: TokenClass.Punctuator,\n    name: '<<='\n  },\n  ASSIGN_SHR: {\n    klass: TokenClass.Punctuator,\n    name: '>>='\n  },\n  ASSIGN_SHR_UNSIGNED: {\n    klass: TokenClass.Punctuator,\n    name: '>>>='\n  },\n  ASSIGN_ADD: {\n    klass: TokenClass.Punctuator,\n    name: '+='\n  },\n  ASSIGN_SUB: {\n    klass: TokenClass.Punctuator,\n    name: '-='\n  },\n  ASSIGN_MUL: {\n    klass: TokenClass.Punctuator,\n    name: '*='\n  },\n  ASSIGN_DIV: {\n    klass: TokenClass.Punctuator,\n    name: '/='\n  },\n  ASSIGN_MOD: {\n    klass: TokenClass.Punctuator,\n    name: '%='\n  },\n  ASSIGN_EXP: {\n    klass: TokenClass.Punctuator,\n    name: '**='\n  },\n  COMMA: {\n    klass: TokenClass.Punctuator,\n    name: ','\n  },\n  OR: {\n    klass: TokenClass.Punctuator,\n    name: '||'\n  },\n  AND: {\n    klass: TokenClass.Punctuator,\n    name: '&&'\n  },\n  BIT_OR: {\n    klass: TokenClass.Punctuator,\n    name: '|'\n  },\n  BIT_XOR: {\n    klass: TokenClass.Punctuator,\n    name: '^'\n  },\n  BIT_AND: {\n    klass: TokenClass.Punctuator,\n    name: '&'\n  },\n  SHL: {\n    klass: TokenClass.Punctuator,\n    name: '<<'\n  },\n  SHR: {\n    klass: TokenClass.Punctuator,\n    name: '>>'\n  },\n  SHR_UNSIGNED: {\n    klass: TokenClass.Punctuator,\n    name: '>>>'\n  },\n  ADD: {\n    klass: TokenClass.Punctuator,\n    name: '+'\n  },\n  SUB: {\n    klass: TokenClass.Punctuator,\n    name: '-'\n  },\n  MUL: {\n    klass: TokenClass.Punctuator,\n    name: '*'\n  },\n  DIV: {\n    klass: TokenClass.Punctuator,\n    name: '/'\n  },\n  MOD: {\n    klass: TokenClass.Punctuator,\n    name: '%'\n  },\n  EXP: {\n    klass: TokenClass.Punctuator,\n    name: '**'\n  },\n  EQ: {\n    klass: TokenClass.Punctuator,\n    name: '=='\n  },\n  NE: {\n    klass: TokenClass.Punctuator,\n    name: '!='\n  },\n  EQ_STRICT: {\n    klass: TokenClass.Punctuator,\n    name: '==='\n  },\n  NE_STRICT: {\n    klass: TokenClass.Punctuator,\n    name: '!=='\n  },\n  LT: {\n    klass: TokenClass.Punctuator,\n    name: '<'\n  },\n  GT: {\n    klass: TokenClass.Punctuator,\n    name: '>'\n  },\n  LTE: {\n    klass: TokenClass.Punctuator,\n    name: '<='\n  },\n  GTE: {\n    klass: TokenClass.Punctuator,\n    name: '>='\n  },\n  INSTANCEOF: {\n    klass: TokenClass.Keyword,\n    name: 'instanceof'\n  },\n  IN: {\n    klass: TokenClass.Keyword,\n    name: 'in'\n  },\n  NOT: {\n    klass: TokenClass.Punctuator,\n    name: '!'\n  },\n  BIT_NOT: {\n    klass: TokenClass.Punctuator,\n    name: '~'\n  },\n  ASYNC: {\n    klass: TokenClass.Keyword,\n    name: 'async'\n  },\n  AWAIT: {\n    klass: TokenClass.Keyword,\n    name: 'await'\n  },\n  ENUM: {\n    klass: TokenClass.Keyword,\n    name: 'enum'\n  },\n  DELETE: {\n    klass: TokenClass.Keyword,\n    name: 'delete'\n  },\n  TYPEOF: {\n    klass: TokenClass.Keyword,\n    name: 'typeof'\n  },\n  VOID: {\n    klass: TokenClass.Keyword,\n    name: 'void'\n  },\n  BREAK: {\n    klass: TokenClass.Keyword,\n    name: 'break'\n  },\n  CASE: {\n    klass: TokenClass.Keyword,\n    name: 'case'\n  },\n  CATCH: {\n    klass: TokenClass.Keyword,\n    name: 'catch'\n  },\n  CLASS: {\n    klass: TokenClass.Keyword,\n    name: 'class'\n  },\n  CONTINUE: {\n    klass: TokenClass.Keyword,\n    name: 'continue'\n  },\n  DEBUGGER: {\n    klass: TokenClass.Keyword,\n    name: 'debugger'\n  },\n  DEFAULT: {\n    klass: TokenClass.Keyword,\n    name: 'default'\n  },\n  DO: {\n    klass: TokenClass.Keyword,\n    name: 'do'\n  },\n  ELSE: {\n    klass: TokenClass.Keyword,\n    name: 'else'\n  },\n  EXPORT: {\n    klass: TokenClass.Keyword,\n    name: 'export'\n  },\n  EXTENDS: {\n    klass: TokenClass.Keyword,\n    name: 'extends'\n  },\n  FINALLY: {\n    klass: TokenClass.Keyword,\n    name: 'finally'\n  },\n  FOR: {\n    klass: TokenClass.Keyword,\n    name: 'for'\n  },\n  FUNCTION: {\n    klass: TokenClass.Keyword,\n    name: 'function'\n  },\n  IF: {\n    klass: TokenClass.Keyword,\n    name: 'if'\n  },\n  IMPORT: {\n    klass: TokenClass.Keyword,\n    name: 'import'\n  },\n  LET: {\n    klass: TokenClass.Keyword,\n    name: 'let'\n  },\n  NEW: {\n    klass: TokenClass.Keyword,\n    name: 'new'\n  },\n  RETURN: {\n    klass: TokenClass.Keyword,\n    name: 'return'\n  },\n  SUPER: {\n    klass: TokenClass.Keyword,\n    name: 'super'\n  },\n  SWITCH: {\n    klass: TokenClass.Keyword,\n    name: 'switch'\n  },\n  THIS: {\n    klass: TokenClass.Keyword,\n    name: 'this'\n  },\n  THROW: {\n    klass: TokenClass.Keyword,\n    name: 'throw'\n  },\n  TRY: {\n    klass: TokenClass.Keyword,\n    name: 'try'\n  },\n  VAR: {\n    klass: TokenClass.Keyword,\n    name: 'var'\n  },\n  WHILE: {\n    klass: TokenClass.Keyword,\n    name: 'while'\n  },\n  WITH: {\n    klass: TokenClass.Keyword,\n    name: 'with'\n  },\n  NULL: {\n    klass: TokenClass.Keyword,\n    name: 'null'\n  },\n  TRUE: {\n    klass: TokenClass.Keyword,\n    name: 'true'\n  },\n  FALSE: {\n    klass: TokenClass.Keyword,\n    name: 'false'\n  },\n  YIELD: {\n    klass: TokenClass.Keyword,\n    name: 'yield'\n  },\n  NUMBER: {\n    klass: TokenClass.NumericLiteral,\n    name: ''\n  },\n  STRING: {\n    klass: TokenClass.StringLiteral,\n    name: ''\n  },\n  REGEXP: {\n    klass: TokenClass.RegularExpression,\n    name: ''\n  },\n  IDENTIFIER: {\n    klass: TokenClass.Ident,\n    name: ''\n  },\n  CONST: {\n    klass: TokenClass.Keyword,\n    name: 'const'\n  },\n  TEMPLATE: {\n    klass: TokenClass.TemplateElement,\n    name: ''\n  },\n  ESCAPED_KEYWORD: {\n    klass: TokenClass.Keyword,\n    name: ''\n  },\n  ILLEGAL: {\n    klass: TokenClass.Illegal,\n    name: ''\n  }\n};\nconst TT = TokenType;\nconst I = TT.ILLEGAL;\nconst F = false;\nconst T = true;\nconst ONE_CHAR_PUNCTUATOR = [I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.NOT, I, I, I, TT.MOD, TT.BIT_AND, I, TT.LPAREN, TT.RPAREN, TT.MUL, TT.ADD, TT.COMMA, TT.SUB, TT.PERIOD, TT.DIV, I, I, I, I, I, I, I, I, I, I, TT.COLON, TT.SEMICOLON, TT.LT, TT.ASSIGN, TT.GT, TT.CONDITIONAL, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACK, I, TT.RBRACK, TT.BIT_XOR, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACE, TT.BIT_OR, TT.RBRACE, TT.BIT_NOT];\nconst PUNCTUATOR_START = [F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, F, F, T, T, F, T, T, T, T, T, T, F, T, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, T, T, T, F];\nclass JsError extends Error {\n  constructor(index, line, column, msg) {\n    super(msg);\n    this.index = index;\n    // Safari defines these properties as non-writable and non-configurable on Error objects\n    try {\n      this.line = line;\n      this.column = column;\n    } catch (e) {}\n    // define these as well so Safari still has access to this info\n    this.parseErrorLine = line;\n    this.parseErrorColumn = column;\n    this.description = msg;\n    this.message = `[${line}:${column}]: ${msg}`;\n  }\n}\nfunction fromCodePoint(cp) {\n  if (cp <= 0xFFFF) return String.fromCharCode(cp);\n  let cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);\n  let cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);\n  return cu1 + cu2;\n}\nfunction decodeUtf16(lead, trail) {\n  return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n}\nclass Tokenizer {\n  constructor(source) {\n    this.source = source;\n    this.index = 0;\n    this.line = 0;\n    this.lineStart = 0;\n    this.startIndex = 0;\n    this.startLine = 0;\n    this.startLineStart = 0;\n    this.lastIndex = 0;\n    this.lastLine = 0;\n    this.lastLineStart = 0;\n    this.hasLineTerminatorBeforeNext = false;\n    this.tokenIndex = 0;\n  }\n  saveLexerState() {\n    return {\n      source: this.source,\n      index: this.index,\n      line: this.line,\n      lineStart: this.lineStart,\n      startIndex: this.startIndex,\n      startLine: this.startLine,\n      startLineStart: this.startLineStart,\n      lastIndex: this.lastIndex,\n      lastLine: this.lastLine,\n      lastLineStart: this.lastLineStart,\n      lookahead: this.lookahead,\n      hasLineTerminatorBeforeNext: this.hasLineTerminatorBeforeNext,\n      tokenIndex: this.tokenIndex\n    };\n  }\n  restoreLexerState(state) {\n    this.source = state.source;\n    this.index = state.index;\n    this.line = state.line;\n    this.lineStart = state.lineStart;\n    this.startIndex = state.startIndex;\n    this.startLine = state.startLine;\n    this.startLineStart = state.startLineStart;\n    this.lastIndex = state.lastIndex;\n    this.lastLine = state.lastLine;\n    this.lastLineStart = state.lastLineStart;\n    this.lookahead = state.lookahead;\n    this.hasLineTerminatorBeforeNext = state.hasLineTerminatorBeforeNext;\n    this.tokenIndex = state.tokenIndex;\n  }\n  createILLEGAL() {\n    this.startIndex = this.index;\n    this.startLine = this.line;\n    this.startLineStart = this.lineStart;\n    return this.index < this.source.length ? this.createError(ErrorMessages.UNEXPECTED_ILLEGAL_TOKEN, this.source.charAt(this.index)) : this.createError(ErrorMessages.UNEXPECTED_EOS);\n  }\n  createUnexpected(token) {\n    switch (token.type.klass) {\n      case TokenClass.Eof:\n        return this.createError(ErrorMessages.UNEXPECTED_EOS);\n      case TokenClass.Ident:\n        return this.createError(ErrorMessages.UNEXPECTED_IDENTIFIER);\n      case TokenClass.Keyword:\n        if (token.type === TokenType.ESCAPED_KEYWORD) {\n          return this.createError(ErrorMessages.UNEXPECTED_ESCAPED_KEYWORD);\n        }\n        return this.createError(ErrorMessages.UNEXPECTED_TOKEN, token.slice.text);\n      case TokenClass.NumericLiteral:\n        return this.createError(ErrorMessages.UNEXPECTED_NUMBER);\n      case TokenClass.TemplateElement:\n        return this.createError(ErrorMessages.UNEXPECTED_TEMPLATE);\n      case TokenClass.Punctuator:\n        return this.createError(ErrorMessages.UNEXPECTED_TOKEN, token.type.name);\n      case TokenClass.StringLiteral:\n        return this.createError(ErrorMessages.UNEXPECTED_STRING);\n      // the other token classes are RegularExpression and Illegal, but they cannot reach here\n    }\n    // istanbul ignore next\n    throw new Error('Unreachable: unexpected token of class ' + token.type.klass);\n  }\n  createError(message, ...params) {\n    let msg;\n    if (typeof message === 'function') {\n      msg = message(...params);\n    } else {\n      msg = message;\n    }\n    return new JsError(this.startIndex, this.startLine + 1, this.startIndex - this.startLineStart + 1, msg);\n  }\n  createErrorWithLocation(location, message) {\n    /* istanbul ignore next */\n    let msg = message.replace(/\\{(\\d+)\\}/g, (_, n) => JSON.stringify(arguments[+n + 2]));\n    if (location.slice && location.slice.startLocation) {\n      location = location.slice.startLocation;\n    }\n    return new JsError(location.offset, location.line, location.column + 1, msg);\n  }\n  static cse2(id, ch1, ch2) {\n    return id.charAt(1) === ch1 && id.charAt(2) === ch2;\n  }\n  static cse3(id, ch1, ch2, ch3) {\n    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3;\n  }\n  static cse4(id, ch1, ch2, ch3, ch4) {\n    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4;\n  }\n  static cse5(id, ch1, ch2, ch3, ch4, ch5) {\n    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5;\n  }\n  static cse6(id, ch1, ch2, ch3, ch4, ch5, ch6) {\n    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6;\n  }\n  static cse7(id, ch1, ch2, ch3, ch4, ch5, ch6, ch7) {\n    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6 && id.charAt(7) === ch7;\n  }\n  getKeyword(id) {\n    if (id.length === 1 || id.length > 10) {\n      return TokenType.IDENTIFIER;\n    }\n\n    /* istanbul ignore next */\n    switch (id.length) {\n      case 2:\n        switch (id.charAt(0)) {\n          case 'i':\n            switch (id.charAt(1)) {\n              case 'f':\n                return TokenType.IF;\n              case 'n':\n                return TokenType.IN;\n              default:\n                break;\n            }\n            break;\n          case 'd':\n            if (id.charAt(1) === 'o') {\n              return TokenType.DO;\n            }\n            break;\n        }\n        break;\n      case 3:\n        switch (id.charAt(0)) {\n          case 'v':\n            if (Tokenizer.cse2(id, 'a', 'r')) {\n              return TokenType.VAR;\n            }\n            break;\n          case 'f':\n            if (Tokenizer.cse2(id, 'o', 'r')) {\n              return TokenType.FOR;\n            }\n            break;\n          case 'n':\n            if (Tokenizer.cse2(id, 'e', 'w')) {\n              return TokenType.NEW;\n            }\n            break;\n          case 't':\n            if (Tokenizer.cse2(id, 'r', 'y')) {\n              return TokenType.TRY;\n            }\n            break;\n          case 'l':\n            if (Tokenizer.cse2(id, 'e', 't')) {\n              return TokenType.LET;\n            }\n            break;\n        }\n        break;\n      case 4:\n        switch (id.charAt(0)) {\n          case 't':\n            if (Tokenizer.cse3(id, 'h', 'i', 's')) {\n              return TokenType.THIS;\n            } else if (Tokenizer.cse3(id, 'r', 'u', 'e')) {\n              return TokenType.TRUE;\n            }\n            break;\n          case 'n':\n            if (Tokenizer.cse3(id, 'u', 'l', 'l')) {\n              return TokenType.NULL;\n            }\n            break;\n          case 'e':\n            if (Tokenizer.cse3(id, 'l', 's', 'e')) {\n              return TokenType.ELSE;\n            } else if (Tokenizer.cse3(id, 'n', 'u', 'm')) {\n              return TokenType.ENUM;\n            }\n            break;\n          case 'c':\n            if (Tokenizer.cse3(id, 'a', 's', 'e')) {\n              return TokenType.CASE;\n            }\n            break;\n          case 'v':\n            if (Tokenizer.cse3(id, 'o', 'i', 'd')) {\n              return TokenType.VOID;\n            }\n            break;\n          case 'w':\n            if (Tokenizer.cse3(id, 'i', 't', 'h')) {\n              return TokenType.WITH;\n            }\n            break;\n        }\n        break;\n      case 5:\n        switch (id.charAt(0)) {\n          case 'a':\n            if (Tokenizer.cse4(id, 's', 'y', 'n', 'c')) {\n              return TokenType.ASYNC;\n            }\n            if (Tokenizer.cse4(id, 'w', 'a', 'i', 't')) {\n              return TokenType.AWAIT;\n            }\n            break;\n          case 'w':\n            if (Tokenizer.cse4(id, 'h', 'i', 'l', 'e')) {\n              return TokenType.WHILE;\n            }\n            break;\n          case 'b':\n            if (Tokenizer.cse4(id, 'r', 'e', 'a', 'k')) {\n              return TokenType.BREAK;\n            }\n            break;\n          case 'f':\n            if (Tokenizer.cse4(id, 'a', 'l', 's', 'e')) {\n              return TokenType.FALSE;\n            }\n            break;\n          case 'c':\n            if (Tokenizer.cse4(id, 'a', 't', 'c', 'h')) {\n              return TokenType.CATCH;\n            } else if (Tokenizer.cse4(id, 'o', 'n', 's', 't')) {\n              return TokenType.CONST;\n            } else if (Tokenizer.cse4(id, 'l', 'a', 's', 's')) {\n              return TokenType.CLASS;\n            }\n            break;\n          case 't':\n            if (Tokenizer.cse4(id, 'h', 'r', 'o', 'w')) {\n              return TokenType.THROW;\n            }\n            break;\n          case 'y':\n            if (Tokenizer.cse4(id, 'i', 'e', 'l', 'd')) {\n              return TokenType.YIELD;\n            }\n            break;\n          case 's':\n            if (Tokenizer.cse4(id, 'u', 'p', 'e', 'r')) {\n              return TokenType.SUPER;\n            }\n            break;\n        }\n        break;\n      case 6:\n        switch (id.charAt(0)) {\n          case 'r':\n            if (Tokenizer.cse5(id, 'e', 't', 'u', 'r', 'n')) {\n              return TokenType.RETURN;\n            }\n            break;\n          case 't':\n            if (Tokenizer.cse5(id, 'y', 'p', 'e', 'o', 'f')) {\n              return TokenType.TYPEOF;\n            }\n            break;\n          case 'd':\n            if (Tokenizer.cse5(id, 'e', 'l', 'e', 't', 'e')) {\n              return TokenType.DELETE;\n            }\n            break;\n          case 's':\n            if (Tokenizer.cse5(id, 'w', 'i', 't', 'c', 'h')) {\n              return TokenType.SWITCH;\n            }\n            break;\n          case 'e':\n            if (Tokenizer.cse5(id, 'x', 'p', 'o', 'r', 't')) {\n              return TokenType.EXPORT;\n            }\n            break;\n          case 'i':\n            if (Tokenizer.cse5(id, 'm', 'p', 'o', 'r', 't')) {\n              return TokenType.IMPORT;\n            }\n            break;\n        }\n        break;\n      case 7:\n        switch (id.charAt(0)) {\n          case 'd':\n            if (Tokenizer.cse6(id, 'e', 'f', 'a', 'u', 'l', 't')) {\n              return TokenType.DEFAULT;\n            }\n            break;\n          case 'f':\n            if (Tokenizer.cse6(id, 'i', 'n', 'a', 'l', 'l', 'y')) {\n              return TokenType.FINALLY;\n            }\n            break;\n          case 'e':\n            if (Tokenizer.cse6(id, 'x', 't', 'e', 'n', 'd', 's')) {\n              return TokenType.EXTENDS;\n            }\n            break;\n        }\n        break;\n      case 8:\n        switch (id.charAt(0)) {\n          case 'f':\n            if (Tokenizer.cse7(id, 'u', 'n', 'c', 't', 'i', 'o', 'n')) {\n              return TokenType.FUNCTION;\n            }\n            break;\n          case 'c':\n            if (Tokenizer.cse7(id, 'o', 'n', 't', 'i', 'n', 'u', 'e')) {\n              return TokenType.CONTINUE;\n            }\n            break;\n          case 'd':\n            if (Tokenizer.cse7(id, 'e', 'b', 'u', 'g', 'g', 'e', 'r')) {\n              return TokenType.DEBUGGER;\n            }\n            break;\n        }\n        break;\n      case 10:\n        if (id === 'instanceof') {\n          return TokenType.INSTANCEOF;\n        }\n        break;\n    }\n    return TokenType.IDENTIFIER;\n  }\n  skipSingleLineComment(offset) {\n    this.index += offset;\n    while (this.index < this.source.length) {\n      /**\n       * @type {Number}\n       */\n      let chCode = this.source.charCodeAt(this.index);\n      this.index++;\n      if (isLineTerminator(chCode)) {\n        this.hasLineTerminatorBeforeNext = true;\n        if (chCode === 0xD /* \"\\r\" */ && this.source.charCodeAt(this.index) === 0xA /* \"\\n\" */) {\n          this.index++;\n        }\n        this.lineStart = this.index;\n        this.line++;\n        return;\n      }\n    }\n  }\n  skipMultiLineComment() {\n    this.index += 2;\n    const length = this.source.length;\n    let isLineStart = false;\n    while (this.index < length) {\n      let chCode = this.source.charCodeAt(this.index);\n      if (chCode < 0x80) {\n        switch (chCode) {\n          case 42:\n            // \"*\"\n            // Block comment ends with \"*/\".\n            if (this.source.charAt(this.index + 1) === '/') {\n              this.index = this.index + 2;\n              return isLineStart;\n            }\n            this.index++;\n            break;\n          case 10:\n            // \"\\n\"\n            isLineStart = true;\n            this.hasLineTerminatorBeforeNext = true;\n            this.index++;\n            this.lineStart = this.index;\n            this.line++;\n            break;\n          case 13:\n            // \"\\r\":\n            isLineStart = true;\n            this.hasLineTerminatorBeforeNext = true;\n            if (this.source.charAt(this.index + 1) === '\\n') {\n              this.index++;\n            }\n            this.index++;\n            this.lineStart = this.index;\n            this.line++;\n            break;\n          default:\n            this.index++;\n        }\n      } else if (chCode === 0x2028 || chCode === 0x2029) {\n        isLineStart = true;\n        this.hasLineTerminatorBeforeNext = true;\n        this.index++;\n        this.lineStart = this.index;\n        this.line++;\n      } else {\n        this.index++;\n      }\n    }\n    throw this.createILLEGAL();\n  }\n  skipComment() {\n    this.hasLineTerminatorBeforeNext = false;\n    let isLineStart = this.index === 0;\n    const length = this.source.length;\n    while (this.index < length) {\n      let chCode = this.source.charCodeAt(this.index);\n      if (isWhiteSpace(chCode)) {\n        this.index++;\n      } else if (isLineTerminator(chCode)) {\n        this.hasLineTerminatorBeforeNext = true;\n        this.index++;\n        if (chCode === 13 /* \"\\r\" */ && this.source.charAt(this.index) === '\\n') {\n          this.index++;\n        }\n        this.lineStart = this.index;\n        this.line++;\n        isLineStart = true;\n      } else if (chCode === 47 /* \"/\" */) {\n        if (this.index + 1 >= length) {\n          break;\n        }\n        chCode = this.source.charCodeAt(this.index + 1);\n        if (chCode === 47 /* \"/\" */) {\n          this.skipSingleLineComment(2);\n          isLineStart = true;\n        } else if (chCode === 42 /* \"*\" */) {\n          isLineStart = this.skipMultiLineComment() || isLineStart;\n        } else {\n          break;\n        }\n      } else if (!this.moduleIsTheGoalSymbol && isLineStart && chCode === 45 /* \"-\" */) {\n        if (this.index + 2 >= length) {\n          break;\n        }\n        // U+003E is \">\"\n        if (this.source.charAt(this.index + 1) === '-' && this.source.charAt(this.index + 2) === '>') {\n          // \"-->\" is a single-line comment\n          this.skipSingleLineComment(3);\n        } else {\n          break;\n        }\n      } else if (!this.moduleIsTheGoalSymbol && chCode === 60 /* \"<\" */) {\n        if (this.source.slice(this.index + 1, this.index + 4) === '!--') {\n          this.skipSingleLineComment(4);\n          isLineStart = true;\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n  scanHexEscape2() {\n    if (this.index + 2 > this.source.length) {\n      return -1;\n    }\n    let r1 = getHexValue(this.source.charAt(this.index));\n    if (r1 === -1) {\n      return -1;\n    }\n    let r2 = getHexValue(this.source.charAt(this.index + 1));\n    if (r2 === -1) {\n      return -1;\n    }\n    this.index += 2;\n    return r1 << 4 | r2;\n  }\n  scanUnicode() {\n    if (this.source.charAt(this.index) === '{') {\n      // \\u{HexDigits}\n      let i = this.index + 1;\n      let hexDigits = 0,\n        ch;\n      while (i < this.source.length) {\n        ch = this.source.charAt(i);\n        let hex = getHexValue(ch);\n        if (hex === -1) {\n          break;\n        }\n        hexDigits = hexDigits << 4 | hex;\n        if (hexDigits > 0x10FFFF) {\n          throw this.createILLEGAL();\n        }\n        i++;\n      }\n      if (ch !== '}') {\n        throw this.createILLEGAL();\n      }\n      if (i === this.index + 1) {\n        ++this.index; // This is so that the error is 'Unexpected \"}\"' instead of 'Unexpected \"{\"'.\n        throw this.createILLEGAL();\n      }\n      this.index = i + 1;\n      return hexDigits;\n    }\n    // \\uHex4Digits\n    if (this.index + 4 > this.source.length) {\n      return -1;\n    }\n    let r1 = getHexValue(this.source.charAt(this.index));\n    if (r1 === -1) {\n      return -1;\n    }\n    let r2 = getHexValue(this.source.charAt(this.index + 1));\n    if (r2 === -1) {\n      return -1;\n    }\n    let r3 = getHexValue(this.source.charAt(this.index + 2));\n    if (r3 === -1) {\n      return -1;\n    }\n    let r4 = getHexValue(this.source.charAt(this.index + 3));\n    if (r4 === -1) {\n      return -1;\n    }\n    this.index += 4;\n    return r1 << 12 | r2 << 8 | r3 << 4 | r4;\n  }\n  getEscapedIdentifier() {\n    let id = '';\n    let check = isIdentifierStart;\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      let code = ch.charCodeAt(0);\n      let start = this.index;\n      ++this.index;\n      if (ch === '\\\\') {\n        if (this.index >= this.source.length) {\n          throw this.createILLEGAL();\n        }\n        if (this.source.charAt(this.index) !== 'u') {\n          throw this.createILLEGAL();\n        }\n        ++this.index;\n        code = this.scanUnicode();\n        if (code < 0) {\n          throw this.createILLEGAL();\n        }\n        ch = fromCodePoint(code);\n      } else if (code >= 0xD800 && code <= 0xDBFF) {\n        if (this.index >= this.source.length) {\n          throw this.createILLEGAL();\n        }\n        let lowSurrogateCode = this.source.charCodeAt(this.index);\n        ++this.index;\n        if (!(lowSurrogateCode >= 0xDC00 && lowSurrogateCode <= 0xDFFF)) {\n          throw this.createILLEGAL();\n        }\n        code = decodeUtf16(code, lowSurrogateCode);\n        ch = fromCodePoint(code);\n      }\n      if (!check(code)) {\n        if (id.length < 1) {\n          throw this.createILLEGAL();\n        }\n        this.index = start;\n        return id;\n      }\n      check = isIdentifierPart;\n      id += ch;\n    }\n    return id;\n  }\n  getIdentifier() {\n    let start = this.index;\n    let l = this.source.length;\n    let i = this.index;\n    let check = isIdentifierStart;\n    while (i < l) {\n      let ch = this.source.charAt(i);\n      let code = ch.charCodeAt(0);\n      if (ch === '\\\\' || code >= 0xD800 && code <= 0xDBFF) {\n        // Go back and try the hard one.\n        this.index = start;\n        return this.getEscapedIdentifier();\n      }\n      if (!check(code)) {\n        this.index = i;\n        return this.source.slice(start, i);\n      }\n      ++i;\n      check = isIdentifierPart;\n    }\n    this.index = i;\n    return this.source.slice(start, i);\n  }\n  scanIdentifier() {\n    let startLocation = this.getLocation();\n    let start = this.index;\n\n    // Backslash (U+005C) starts an escaped character.\n    let id = this.source.charAt(this.index) === '\\\\' ? this.getEscapedIdentifier() : this.getIdentifier();\n    let slice = this.getSlice(start, startLocation);\n    slice.text = id;\n    let hasEscape = this.index - start !== id.length;\n    let type = this.getKeyword(id);\n    if (hasEscape && type !== TokenType.IDENTIFIER) {\n      type = TokenType.ESCAPED_KEYWORD;\n    }\n    return {\n      type,\n      value: id,\n      slice,\n      escaped: hasEscape\n    };\n  }\n  getLocation() {\n    return {\n      line: this.startLine + 1,\n      column: this.startIndex - this.startLineStart,\n      offset: this.startIndex\n    };\n  }\n  getLastTokenEndLocation() {\n    return {\n      line: this.lastLine + 1,\n      column: this.lastIndex - this.lastLineStart,\n      offset: this.lastIndex\n    };\n  }\n  getSlice(start, startLocation) {\n    return {\n      text: this.source.slice(start, this.index),\n      start,\n      startLocation,\n      end: this.index\n    };\n  }\n  scanPunctuatorHelper() {\n    let ch1 = this.source.charAt(this.index);\n    switch (ch1) {\n      // Check for most common single-character punctuators.\n      case '.':\n        {\n          let ch2 = this.source.charAt(this.index + 1);\n          if (ch2 !== '.') return TokenType.PERIOD;\n          let ch3 = this.source.charAt(this.index + 2);\n          if (ch3 !== '.') return TokenType.PERIOD;\n          return TokenType.ELLIPSIS;\n        }\n      case '(':\n        return TokenType.LPAREN;\n      case ')':\n      case ';':\n      case ',':\n        return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];\n      case '{':\n        return TokenType.LBRACE;\n      case '}':\n      case '[':\n      case ']':\n      case ':':\n      case '?':\n      case '~':\n        return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];\n      default:\n        // \"=\" (U+003D) marks an assignment or comparison operator.\n        if (this.index + 1 < this.source.length && this.source.charAt(this.index + 1) === '=') {\n          switch (ch1) {\n            case '=':\n              if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === '=') {\n                return TokenType.EQ_STRICT;\n              }\n              return TokenType.EQ;\n            case '!':\n              if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === '=') {\n                return TokenType.NE_STRICT;\n              }\n              return TokenType.NE;\n            case '|':\n              return TokenType.ASSIGN_BIT_OR;\n            case '+':\n              return TokenType.ASSIGN_ADD;\n            case '-':\n              return TokenType.ASSIGN_SUB;\n            case '*':\n              return TokenType.ASSIGN_MUL;\n            case '<':\n              return TokenType.LTE;\n            case '>':\n              return TokenType.GTE;\n            case '/':\n              return TokenType.ASSIGN_DIV;\n            case '%':\n              return TokenType.ASSIGN_MOD;\n            case '^':\n              return TokenType.ASSIGN_BIT_XOR;\n            case '&':\n              return TokenType.ASSIGN_BIT_AND;\n            // istanbul ignore next\n            default:\n              break;\n            // failed\n          }\n        }\n    }\n    if (this.index + 1 < this.source.length) {\n      let ch2 = this.source.charAt(this.index + 1);\n      if (ch1 === ch2) {\n        if (this.index + 2 < this.source.length) {\n          let ch3 = this.source.charAt(this.index + 2);\n          if (ch1 === '>' && ch3 === '>') {\n            // 4-character punctuator: >>>=\n            if (this.index + 3 < this.source.length && this.source.charAt(this.index + 3) === '=') {\n              return TokenType.ASSIGN_SHR_UNSIGNED;\n            }\n            return TokenType.SHR_UNSIGNED;\n          }\n          if (ch1 === '<' && ch3 === '=') {\n            return TokenType.ASSIGN_SHL;\n          }\n          if (ch1 === '>' && ch3 === '=') {\n            return TokenType.ASSIGN_SHR;\n          }\n          if (ch1 === '*' && ch3 === '=') {\n            return TokenType.ASSIGN_EXP;\n          }\n        }\n        // Other 2-character punctuators: ++ -- << >> && ||\n        switch (ch1) {\n          case '*':\n            return TokenType.EXP;\n          case '+':\n            return TokenType.INC;\n          case '-':\n            return TokenType.DEC;\n          case '<':\n            return TokenType.SHL;\n          case '>':\n            return TokenType.SHR;\n          case '&':\n            return TokenType.AND;\n          case '|':\n            return TokenType.OR;\n          // istanbul ignore next\n          default:\n            break;\n          // failed\n        }\n      } else if (ch1 === '=' && ch2 === '>') {\n        return TokenType.ARROW;\n      }\n    }\n    return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];\n  }\n\n  // 7.7 Punctuators\n  scanPunctuator() {\n    let startLocation = this.getLocation();\n    let start = this.index;\n    let subType = this.scanPunctuatorHelper();\n    this.index += subType.name.length;\n    return {\n      type: subType,\n      value: subType.name,\n      slice: this.getSlice(start, startLocation)\n    };\n  }\n  scanHexLiteral(start, startLocation) {\n    let i = this.index;\n    while (i < this.source.length) {\n      let ch = this.source.charAt(i);\n      let hex = getHexValue(ch);\n      if (hex === -1) {\n        break;\n      }\n      i++;\n    }\n    if (this.index === i) {\n      throw this.createILLEGAL();\n    }\n    if (i < this.source.length && isIdentifierStart(this.source.charCodeAt(i))) {\n      throw this.createILLEGAL();\n    }\n    this.index = i;\n    let slice = this.getSlice(start, startLocation);\n    return {\n      type: TokenType.NUMBER,\n      value: parseInt(slice.text.substr(2), 16),\n      slice\n    };\n  }\n  scanBinaryLiteral(start, startLocation) {\n    let offset = this.index - start;\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      if (ch !== '0' && ch !== '1') {\n        break;\n      }\n      this.index++;\n    }\n    if (this.index - start <= offset) {\n      throw this.createILLEGAL();\n    }\n    if (this.index < this.source.length && (isIdentifierStart(this.source.charCodeAt(this.index)) || isDecimalDigit(this.source.charCodeAt(this.index)))) {\n      throw this.createILLEGAL();\n    }\n    return {\n      type: TokenType.NUMBER,\n      value: parseInt(this.getSlice(start, startLocation).text.substr(offset), 2),\n      slice: this.getSlice(start, startLocation),\n      octal: false,\n      noctal: false\n    };\n  }\n  scanOctalLiteral(start, startLocation) {\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      if (ch >= '0' && ch <= '7') {\n        this.index++;\n      } else if (isIdentifierPart(ch.charCodeAt(0))) {\n        throw this.createILLEGAL();\n      } else {\n        break;\n      }\n    }\n    if (this.index - start === 2) {\n      throw this.createILLEGAL();\n    }\n    return {\n      type: TokenType.NUMBER,\n      value: parseInt(this.getSlice(start, startLocation).text.substr(2), 8),\n      slice: this.getSlice(start, startLocation),\n      octal: false,\n      noctal: false\n    };\n  }\n  scanLegacyOctalLiteral(start, startLocation) {\n    let isOctal = true;\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      if (ch >= '0' && ch <= '7') {\n        this.index++;\n      } else if (ch === '8' || ch === '9') {\n        isOctal = false;\n        this.index++;\n      } else if (isIdentifierPart(ch.charCodeAt(0))) {\n        throw this.createILLEGAL();\n      } else {\n        break;\n      }\n    }\n    let slice = this.getSlice(start, startLocation);\n    if (!isOctal) {\n      this.eatDecimalLiteralSuffix();\n      return {\n        type: TokenType.NUMBER,\n        slice,\n        value: +slice.text,\n        octal: true,\n        noctal: !isOctal\n      };\n    }\n    return {\n      type: TokenType.NUMBER,\n      slice,\n      value: parseInt(slice.text.substr(1), 8),\n      octal: true,\n      noctal: !isOctal\n    };\n  }\n  scanNumericLiteral() {\n    let ch = this.source.charAt(this.index);\n    // assert(ch === \".\" || \"0\" <= ch && ch <= \"9\")\n    let startLocation = this.getLocation();\n    let start = this.index;\n    if (ch === '0') {\n      this.index++;\n      if (this.index < this.source.length) {\n        ch = this.source.charAt(this.index);\n        if (ch === 'x' || ch === 'X') {\n          this.index++;\n          return this.scanHexLiteral(start, startLocation);\n        } else if (ch === 'b' || ch === 'B') {\n          this.index++;\n          return this.scanBinaryLiteral(start, startLocation);\n        } else if (ch === 'o' || ch === 'O') {\n          this.index++;\n          return this.scanOctalLiteral(start, startLocation);\n        } else if (ch >= '0' && ch <= '9') {\n          return this.scanLegacyOctalLiteral(start, startLocation);\n        }\n      } else {\n        let slice = this.getSlice(start, startLocation);\n        return {\n          type: TokenType.NUMBER,\n          value: +slice.text,\n          slice,\n          octal: false,\n          noctal: false\n        };\n      }\n    } else if (ch !== '.') {\n      // Must be \"1\"..\"9\"\n      ch = this.source.charAt(this.index);\n      while (ch >= '0' && ch <= '9') {\n        this.index++;\n        if (this.index === this.source.length) {\n          let slice = this.getSlice(start, startLocation);\n          return {\n            type: TokenType.NUMBER,\n            value: +slice.text,\n            slice,\n            octal: false,\n            noctal: false\n          };\n        }\n        ch = this.source.charAt(this.index);\n      }\n    }\n    this.eatDecimalLiteralSuffix();\n    if (this.index !== this.source.length && isIdentifierStart(this.source.charCodeAt(this.index))) {\n      throw this.createILLEGAL();\n    }\n    let slice = this.getSlice(start, startLocation);\n    return {\n      type: TokenType.NUMBER,\n      value: +slice.text,\n      slice,\n      octal: false,\n      noctal: false\n    };\n  }\n  eatDecimalLiteralSuffix() {\n    let ch = this.source.charAt(this.index);\n    if (ch === '.') {\n      this.index++;\n      if (this.index === this.source.length) {\n        return;\n      }\n      ch = this.source.charAt(this.index);\n      while (ch >= '0' && ch <= '9') {\n        this.index++;\n        if (this.index === this.source.length) {\n          return;\n        }\n        ch = this.source.charAt(this.index);\n      }\n    }\n\n    // EOF not reached here\n    if (ch === 'e' || ch === 'E') {\n      this.index++;\n      if (this.index === this.source.length) {\n        throw this.createILLEGAL();\n      }\n      ch = this.source.charAt(this.index);\n      if (ch === '+' || ch === '-') {\n        this.index++;\n        if (this.index === this.source.length) {\n          throw this.createILLEGAL();\n        }\n        ch = this.source.charAt(this.index);\n      }\n      if (ch >= '0' && ch <= '9') {\n        while (ch >= '0' && ch <= '9') {\n          this.index++;\n          if (this.index === this.source.length) {\n            break;\n          }\n          ch = this.source.charAt(this.index);\n        }\n      } else {\n        throw this.createILLEGAL();\n      }\n    }\n  }\n  scanStringEscape(str, octal) {\n    this.index++;\n    if (this.index === this.source.length) {\n      throw this.createILLEGAL();\n    }\n    let ch = this.source.charAt(this.index);\n    if (isLineTerminator(ch.charCodeAt(0))) {\n      this.index++;\n      if (ch === '\\r' && this.source.charAt(this.index) === '\\n') {\n        this.index++;\n      }\n      this.lineStart = this.index;\n      this.line++;\n    } else {\n      switch (ch) {\n        case 'n':\n          str += '\\n';\n          this.index++;\n          break;\n        case 'r':\n          str += '\\r';\n          this.index++;\n          break;\n        case 't':\n          str += '\\t';\n          this.index++;\n          break;\n        case 'u':\n        case 'x':\n          {\n            let unescaped;\n            this.index++;\n            if (this.index >= this.source.length) {\n              throw this.createILLEGAL();\n            }\n            unescaped = ch === 'u' ? this.scanUnicode() : this.scanHexEscape2();\n            if (unescaped < 0) {\n              throw this.createILLEGAL();\n            }\n            str += fromCodePoint(unescaped);\n            break;\n          }\n        case 'b':\n          str += '\\b';\n          this.index++;\n          break;\n        case 'f':\n          str += '\\f';\n          this.index++;\n          break;\n        case 'v':\n          str += '\\u000B';\n          this.index++;\n          break;\n        default:\n          if (ch >= '0' && ch <= '7') {\n            let octalStart = this.index;\n            let octLen = 1;\n            // 3 digits are only allowed when string starts\n            // with 0, 1, 2, 3\n            if (ch >= '0' && ch <= '3') {\n              octLen = 0;\n            }\n            let code = 0;\n            while (octLen < 3 && ch >= '0' && ch <= '7') {\n              this.index++;\n              if (octLen > 0 || ch !== '0') {\n                octal = this.source.slice(octalStart, this.index);\n              }\n              code *= 8;\n              code += ch - '0';\n              octLen++;\n              if (this.index === this.source.length) {\n                throw this.createILLEGAL();\n              }\n              ch = this.source.charAt(this.index);\n            }\n            if (code === 0 && octLen === 1 && (ch === '8' || ch === '9')) {\n              octal = this.source.slice(octalStart, this.index + 1);\n            }\n            str += String.fromCharCode(code);\n          } else if (ch === '8' || ch === '9') {\n            throw this.createILLEGAL();\n          } else {\n            str += ch;\n            this.index++;\n          }\n      }\n    }\n    return [str, octal];\n  }\n  // 7.8.4 String Literals\n  scanStringLiteral() {\n    let str = '';\n    let quote = this.source.charAt(this.index);\n    //  assert((quote === \"\\\"\" || quote === \"\"\"), \"String literal must starts with a quote\")\n\n    let startLocation = this.getLocation();\n    let start = this.index;\n    this.index++;\n    let octal = null;\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      if (ch === quote) {\n        this.index++;\n        return {\n          type: TokenType.STRING,\n          slice: this.getSlice(start, startLocation),\n          str,\n          octal\n        };\n      } else if (ch === '\\\\') {\n        [str, octal] = this.scanStringEscape(str, octal);\n      } else if (isLineTerminator(ch.charCodeAt(0)) && ch !== 0x2028 && ch !== 0x2029) {\n        throw this.createILLEGAL();\n      } else {\n        str += ch;\n        this.index++;\n      }\n    }\n    throw this.createILLEGAL();\n  }\n  scanTemplateElement() {\n    let startLocation = this.getLocation();\n    let start = this.index;\n    this.index++;\n    while (this.index < this.source.length) {\n      let ch = this.source.charCodeAt(this.index);\n      switch (ch) {\n        case 0x60:\n          {\n            // `\n            this.index++;\n            return {\n              type: TokenType.TEMPLATE,\n              tail: true,\n              slice: this.getSlice(start, startLocation)\n            };\n          }\n        case 0x24:\n          {\n            // $\n            if (this.source.charCodeAt(this.index + 1) === 0x7B) {\n              // {\n              this.index += 2;\n              return {\n                type: TokenType.TEMPLATE,\n                tail: false,\n                slice: this.getSlice(start, startLocation)\n              };\n            }\n            this.index++;\n            break;\n          }\n        case 0x5C:\n          {\n            // \\\\\n            let octal = this.scanStringEscape('', null)[1];\n            if (octal != null) {\n              throw this.createError(ErrorMessages.NO_OCTALS_IN_TEMPLATES);\n            }\n            break;\n          }\n        case 0x0D:\n          {\n            // \\r\n            this.line++;\n            this.index++;\n            if (this.index < this.source.length && this.source.charAt(this.index) === '\\n') {\n              this.index++;\n            }\n            this.lineStart = this.index;\n            break;\n          }\n        case 0x0A: // \\r\n        case 0x2028:\n        case 0x2029:\n          {\n            this.line++;\n            this.index++;\n            this.lineStart = this.index;\n            break;\n          }\n        default:\n          this.index++;\n      }\n    }\n    throw this.createILLEGAL();\n  }\n  scanRegExp(str) {\n    let startLocation = this.getLocation();\n    let start = this.index;\n    let terminated = false;\n    let classMarker = false;\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      if (ch === '\\\\') {\n        str += ch;\n        this.index++;\n        ch = this.source.charAt(this.index);\n        // ECMA-262 7.8.5\n        if (isLineTerminator(ch.charCodeAt(0))) {\n          throw this.createError(ErrorMessages.UNTERMINATED_REGEXP);\n        }\n        str += ch;\n        this.index++;\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        throw this.createError(ErrorMessages.UNTERMINATED_REGEXP);\n      } else {\n        if (classMarker) {\n          if (ch === ']') {\n            classMarker = false;\n          }\n        } else if (ch === '/') {\n          terminated = true;\n          str += ch;\n          this.index++;\n          break;\n        } else if (ch === '[') {\n          classMarker = true;\n        }\n        str += ch;\n        this.index++;\n      }\n    }\n    if (!terminated) {\n      throw this.createError(ErrorMessages.UNTERMINATED_REGEXP);\n    }\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      if (ch === '\\\\') {\n        throw this.createError(ErrorMessages.INVALID_REGEXP_FLAGS);\n      }\n      if (!isIdentifierPart(ch.charCodeAt(0))) {\n        break;\n      }\n      this.index++;\n      str += ch;\n    }\n    return {\n      type: TokenType.REGEXP,\n      value: str,\n      slice: this.getSlice(start, startLocation)\n    };\n  }\n  advance() {\n    let startLocation = this.getLocation();\n    this.lastIndex = this.index;\n    this.lastLine = this.line;\n    this.lastLineStart = this.lineStart;\n    this.skipComment();\n    this.startIndex = this.index;\n    this.startLine = this.line;\n    this.startLineStart = this.lineStart;\n    if (this.lastIndex === 0) {\n      this.lastIndex = this.index;\n      this.lastLine = this.line;\n      this.lastLineStart = this.lineStart;\n    }\n    if (this.index >= this.source.length) {\n      return {\n        type: TokenType.EOS,\n        slice: this.getSlice(this.index, startLocation)\n      };\n    }\n    let charCode = this.source.charCodeAt(this.index);\n    if (charCode < 0x80) {\n      if (PUNCTUATOR_START[charCode]) {\n        return this.scanPunctuator();\n      }\n      if (isIdentifierStart(charCode) || charCode === 0x5C /* backslash (\\) */) {\n        return this.scanIdentifier();\n      }\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (charCode === 0x2E) {\n        if (this.index + 1 < this.source.length && isDecimalDigit(this.source.charCodeAt(this.index + 1))) {\n          return this.scanNumericLiteral();\n        }\n        return this.scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (charCode === 0x27 || charCode === 0x22) {\n        return this.scanStringLiteral();\n      }\n\n      // Template literal starts with back quote (U+0060)\n      if (charCode === 0x60) {\n        return this.scanTemplateElement();\n      }\n      if (charCode /* \"0\" */ >= 0x30 && charCode <= 0x39 /* \"9\" */) {\n        return this.scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      throw this.createILLEGAL();\n    } else {\n      if (isIdentifierStart(charCode) || charCode >= 0xD800 && charCode <= 0xDBFF) {\n        return this.scanIdentifier();\n      }\n      throw this.createILLEGAL();\n    }\n  }\n  eof() {\n    return this.lookahead.type === TokenType.EOS;\n  }\n  lex() {\n    let prevToken = this.lookahead;\n    this.lookahead = this.advance();\n    this.tokenIndex++;\n    return prevToken;\n  }\n}\nmodule.exports = {\n  default: Tokenizer,\n  Tokenizer,\n  TokenClass,\n  TokenType,\n  JsError\n};","map":{"version":3,"names":["getHexValue","isLineTerminator","isWhiteSpace","isIdentifierStart","isIdentifierPart","isDecimalDigit","require","ErrorMessages","TokenClass","Eof","name","Ident","isIdentifierName","Keyword","NumericLiteral","TemplateElement","Punctuator","StringLiteral","RegularExpression","Illegal","TokenType","EOS","klass","LPAREN","RPAREN","LBRACK","RBRACK","LBRACE","RBRACE","COLON","SEMICOLON","PERIOD","ELLIPSIS","ARROW","CONDITIONAL","INC","DEC","ASSIGN","ASSIGN_BIT_OR","ASSIGN_BIT_XOR","ASSIGN_BIT_AND","ASSIGN_SHL","ASSIGN_SHR","ASSIGN_SHR_UNSIGNED","ASSIGN_ADD","ASSIGN_SUB","ASSIGN_MUL","ASSIGN_DIV","ASSIGN_MOD","ASSIGN_EXP","COMMA","OR","AND","BIT_OR","BIT_XOR","BIT_AND","SHL","SHR","SHR_UNSIGNED","ADD","SUB","MUL","DIV","MOD","EXP","EQ","NE","EQ_STRICT","NE_STRICT","LT","GT","LTE","GTE","INSTANCEOF","IN","NOT","BIT_NOT","ASYNC","AWAIT","ENUM","DELETE","TYPEOF","VOID","BREAK","CASE","CATCH","CLASS","CONTINUE","DEBUGGER","DEFAULT","DO","ELSE","EXPORT","EXTENDS","FINALLY","FOR","FUNCTION","IF","IMPORT","LET","NEW","RETURN","SUPER","SWITCH","THIS","THROW","TRY","VAR","WHILE","WITH","NULL","TRUE","FALSE","YIELD","NUMBER","STRING","REGEXP","IDENTIFIER","CONST","TEMPLATE","ESCAPED_KEYWORD","ILLEGAL","TT","I","F","T","ONE_CHAR_PUNCTUATOR","PUNCTUATOR_START","JsError","Error","constructor","index","line","column","msg","e","parseErrorLine","parseErrorColumn","description","message","fromCodePoint","cp","String","fromCharCode","cu1","Math","floor","cu2","decodeUtf16","lead","trail","Tokenizer","source","lineStart","startIndex","startLine","startLineStart","lastIndex","lastLine","lastLineStart","hasLineTerminatorBeforeNext","tokenIndex","saveLexerState","lookahead","restoreLexerState","state","createILLEGAL","length","createError","UNEXPECTED_ILLEGAL_TOKEN","charAt","UNEXPECTED_EOS","createUnexpected","token","type","UNEXPECTED_IDENTIFIER","UNEXPECTED_ESCAPED_KEYWORD","UNEXPECTED_TOKEN","slice","text","UNEXPECTED_NUMBER","UNEXPECTED_TEMPLATE","UNEXPECTED_STRING","params","createErrorWithLocation","location","replace","_","n","JSON","stringify","arguments","startLocation","offset","cse2","id","ch1","ch2","cse3","ch3","cse4","ch4","cse5","ch5","cse6","ch6","cse7","ch7","getKeyword","skipSingleLineComment","chCode","charCodeAt","skipMultiLineComment","isLineStart","skipComment","moduleIsTheGoalSymbol","scanHexEscape2","r1","r2","scanUnicode","i","hexDigits","ch","hex","r3","r4","getEscapedIdentifier","check","code","start","lowSurrogateCode","getIdentifier","l","scanIdentifier","getLocation","getSlice","hasEscape","value","escaped","getLastTokenEndLocation","end","scanPunctuatorHelper","scanPunctuator","subType","scanHexLiteral","parseInt","substr","scanBinaryLiteral","octal","noctal","scanOctalLiteral","scanLegacyOctalLiteral","isOctal","eatDecimalLiteralSuffix","scanNumericLiteral","scanStringEscape","str","unescaped","octalStart","octLen","scanStringLiteral","quote","scanTemplateElement","tail","NO_OCTALS_IN_TEMPLATES","scanRegExp","terminated","classMarker","UNTERMINATED_REGEXP","INVALID_REGEXP_FLAGS","advance","charCode","eof","lex","prevToken","module","exports","default"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/shift-parser/src/tokenizer.js"],"sourcesContent":["/**\n * Copyright 2014 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\nconst { getHexValue, isLineTerminator, isWhiteSpace, isIdentifierStart, isIdentifierPart, isDecimalDigit } = require('./utils');\nconst { ErrorMessages } = require('./errors');\n\nconst TokenClass = {\n  Eof: { name: '<End>' },\n  Ident: { name: 'Identifier', isIdentifierName: true },\n  Keyword: { name: 'Keyword', isIdentifierName: true },\n  NumericLiteral: { name: 'Numeric' },\n  TemplateElement: { name: 'Template' },\n  Punctuator: { name: 'Punctuator' },\n  StringLiteral: { name: 'String' },\n  RegularExpression: { name: 'RegularExpression' },\n  Illegal: { name: 'Illegal' },\n};\n\nconst TokenType = {\n  EOS: { klass: TokenClass.Eof, name: 'EOS' },\n  LPAREN: { klass: TokenClass.Punctuator, name: '(' },\n  RPAREN: { klass: TokenClass.Punctuator, name: ')' },\n  LBRACK: { klass: TokenClass.Punctuator, name: '[' },\n  RBRACK: { klass: TokenClass.Punctuator, name: ']' },\n  LBRACE: { klass: TokenClass.Punctuator, name: '{' },\n  RBRACE: { klass: TokenClass.Punctuator, name: '}' },\n  COLON: { klass: TokenClass.Punctuator, name: ':' },\n  SEMICOLON: { klass: TokenClass.Punctuator, name: ';' },\n  PERIOD: { klass: TokenClass.Punctuator, name: '.' },\n  ELLIPSIS: { klass: TokenClass.Punctuator, name: '...' },\n  ARROW: { klass: TokenClass.Punctuator, name: '=>' },\n  CONDITIONAL: { klass: TokenClass.Punctuator, name: '?' },\n  INC: { klass: TokenClass.Punctuator, name: '++' },\n  DEC: { klass: TokenClass.Punctuator, name: '--' },\n  ASSIGN: { klass: TokenClass.Punctuator, name: '=' },\n  ASSIGN_BIT_OR: { klass: TokenClass.Punctuator, name: '|=' },\n  ASSIGN_BIT_XOR: { klass: TokenClass.Punctuator, name: '^=' },\n  ASSIGN_BIT_AND: { klass: TokenClass.Punctuator, name: '&=' },\n  ASSIGN_SHL: { klass: TokenClass.Punctuator, name: '<<=' },\n  ASSIGN_SHR: { klass: TokenClass.Punctuator, name: '>>=' },\n  ASSIGN_SHR_UNSIGNED: { klass: TokenClass.Punctuator, name: '>>>=' },\n  ASSIGN_ADD: { klass: TokenClass.Punctuator, name: '+=' },\n  ASSIGN_SUB: { klass: TokenClass.Punctuator, name: '-=' },\n  ASSIGN_MUL: { klass: TokenClass.Punctuator, name: '*=' },\n  ASSIGN_DIV: { klass: TokenClass.Punctuator, name: '/=' },\n  ASSIGN_MOD: { klass: TokenClass.Punctuator, name: '%=' },\n  ASSIGN_EXP: { klass: TokenClass.Punctuator, name: '**=' },\n  COMMA: { klass: TokenClass.Punctuator, name: ',' },\n  OR: { klass: TokenClass.Punctuator, name: '||' },\n  AND: { klass: TokenClass.Punctuator, name: '&&' },\n  BIT_OR: { klass: TokenClass.Punctuator, name: '|' },\n  BIT_XOR: { klass: TokenClass.Punctuator, name: '^' },\n  BIT_AND: { klass: TokenClass.Punctuator, name: '&' },\n  SHL: { klass: TokenClass.Punctuator, name: '<<' },\n  SHR: { klass: TokenClass.Punctuator, name: '>>' },\n  SHR_UNSIGNED: { klass: TokenClass.Punctuator, name: '>>>' },\n  ADD: { klass: TokenClass.Punctuator, name: '+' },\n  SUB: { klass: TokenClass.Punctuator, name: '-' },\n  MUL: { klass: TokenClass.Punctuator, name: '*' },\n  DIV: { klass: TokenClass.Punctuator, name: '/' },\n  MOD: { klass: TokenClass.Punctuator, name: '%' },\n  EXP: { klass: TokenClass.Punctuator, name: '**' },\n  EQ: { klass: TokenClass.Punctuator, name: '==' },\n  NE: { klass: TokenClass.Punctuator, name: '!=' },\n  EQ_STRICT: { klass: TokenClass.Punctuator, name: '===' },\n  NE_STRICT: { klass: TokenClass.Punctuator, name: '!==' },\n  LT: { klass: TokenClass.Punctuator, name: '<' },\n  GT: { klass: TokenClass.Punctuator, name: '>' },\n  LTE: { klass: TokenClass.Punctuator, name: '<=' },\n  GTE: { klass: TokenClass.Punctuator, name: '>=' },\n  INSTANCEOF: { klass: TokenClass.Keyword, name: 'instanceof' },\n  IN: { klass: TokenClass.Keyword, name: 'in' },\n  NOT: { klass: TokenClass.Punctuator, name: '!' },\n  BIT_NOT: { klass: TokenClass.Punctuator, name: '~' },\n  ASYNC: { klass: TokenClass.Keyword, name: 'async' },\n  AWAIT: { klass: TokenClass.Keyword, name: 'await' },\n  ENUM: { klass: TokenClass.Keyword, name: 'enum' },\n  DELETE: { klass: TokenClass.Keyword, name: 'delete' },\n  TYPEOF: { klass: TokenClass.Keyword, name: 'typeof' },\n  VOID: { klass: TokenClass.Keyword, name: 'void' },\n  BREAK: { klass: TokenClass.Keyword, name: 'break' },\n  CASE: { klass: TokenClass.Keyword, name: 'case' },\n  CATCH: { klass: TokenClass.Keyword, name: 'catch' },\n  CLASS: { klass: TokenClass.Keyword, name: 'class' },\n  CONTINUE: { klass: TokenClass.Keyword, name: 'continue' },\n  DEBUGGER: { klass: TokenClass.Keyword, name: 'debugger' },\n  DEFAULT: { klass: TokenClass.Keyword, name: 'default' },\n  DO: { klass: TokenClass.Keyword, name: 'do' },\n  ELSE: { klass: TokenClass.Keyword, name: 'else' },\n  EXPORT: { klass: TokenClass.Keyword, name: 'export' },\n  EXTENDS: { klass: TokenClass.Keyword, name: 'extends' },\n  FINALLY: { klass: TokenClass.Keyword, name: 'finally' },\n  FOR: { klass: TokenClass.Keyword, name: 'for' },\n  FUNCTION: { klass: TokenClass.Keyword, name: 'function' },\n  IF: { klass: TokenClass.Keyword, name: 'if' },\n  IMPORT: { klass: TokenClass.Keyword, name: 'import' },\n  LET: { klass: TokenClass.Keyword, name: 'let' },\n  NEW: { klass: TokenClass.Keyword, name: 'new' },\n  RETURN: { klass: TokenClass.Keyword, name: 'return' },\n  SUPER: { klass: TokenClass.Keyword, name: 'super' },\n  SWITCH: { klass: TokenClass.Keyword, name: 'switch' },\n  THIS: { klass: TokenClass.Keyword, name: 'this' },\n  THROW: { klass: TokenClass.Keyword, name: 'throw' },\n  TRY: { klass: TokenClass.Keyword, name: 'try' },\n  VAR: { klass: TokenClass.Keyword, name: 'var' },\n  WHILE: { klass: TokenClass.Keyword, name: 'while' },\n  WITH: { klass: TokenClass.Keyword, name: 'with' },\n  NULL: { klass: TokenClass.Keyword, name: 'null' },\n  TRUE: { klass: TokenClass.Keyword, name: 'true' },\n  FALSE: { klass: TokenClass.Keyword, name: 'false' },\n  YIELD: { klass: TokenClass.Keyword, name: 'yield' },\n  NUMBER: { klass: TokenClass.NumericLiteral, name: '' },\n  STRING: { klass: TokenClass.StringLiteral, name: '' },\n  REGEXP: { klass: TokenClass.RegularExpression, name: '' },\n  IDENTIFIER: { klass: TokenClass.Ident, name: '' },\n  CONST: { klass: TokenClass.Keyword, name: 'const' },\n  TEMPLATE: { klass: TokenClass.TemplateElement, name: '' },\n  ESCAPED_KEYWORD: { klass: TokenClass.Keyword, name: '' },\n  ILLEGAL: { klass: TokenClass.Illegal, name: '' },\n};\n\nconst TT = TokenType;\nconst I = TT.ILLEGAL;\nconst F = false;\nconst T = true;\n\nconst ONE_CHAR_PUNCTUATOR = [\n  I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I, TT.NOT, I, I, I,\n  TT.MOD, TT.BIT_AND, I, TT.LPAREN, TT.RPAREN, TT.MUL, TT.ADD, TT.COMMA, TT.SUB, TT.PERIOD, TT.DIV, I, I, I, I, I, I, I,\n  I, I, I, TT.COLON, TT.SEMICOLON, TT.LT, TT.ASSIGN, TT.GT, TT.CONDITIONAL, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I,\n  I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACK, I, TT.RBRACK, TT.BIT_XOR, I, I, I, I, I, I, I, I, I, I, I, I, I, I, I,\n  I, I, I, I, I, I, I, I, I, I, I, I, I, TT.LBRACE, TT.BIT_OR, TT.RBRACE, TT.BIT_NOT,\n];\n\nconst PUNCTUATOR_START = [\n  F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, F, F, T, T,\n  F, T, T, T, T, T, T, F, T, F, F, F, F, F, F, F, F, F, F, T, T, T, T, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F,\n  F, F, F, F, F, F, F, F, F, F, F, F, F, T, F, T, T, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F, F,\n  F, F, F, F, F, F, T, T, T, T, F,\n];\n\nclass JsError extends Error {\n  constructor(index, line, column, msg) {\n    super(msg);\n    this.index = index;\n    // Safari defines these properties as non-writable and non-configurable on Error objects\n    try {\n      this.line = line;\n      this.column = column;\n    } catch (e) {}\n    // define these as well so Safari still has access to this info\n    this.parseErrorLine = line;\n    this.parseErrorColumn = column;\n    this.description = msg;\n    this.message = `[${line}:${column}]: ${msg}`;\n  }\n}\n\nfunction fromCodePoint(cp) {\n  if (cp <= 0xFFFF) return String.fromCharCode(cp);\n  let cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);\n  let cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);\n  return cu1 + cu2;\n}\n\nfunction decodeUtf16(lead, trail) {\n  return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;\n}\n\nclass Tokenizer {\n  constructor(source) {\n    this.source = source;\n    this.index = 0;\n    this.line = 0;\n    this.lineStart = 0;\n    this.startIndex = 0;\n    this.startLine = 0;\n    this.startLineStart = 0;\n    this.lastIndex = 0;\n    this.lastLine = 0;\n    this.lastLineStart = 0;\n    this.hasLineTerminatorBeforeNext = false;\n    this.tokenIndex = 0;\n  }\n\n  saveLexerState() {\n    return {\n      source: this.source,\n      index: this.index,\n      line: this.line,\n      lineStart: this.lineStart,\n      startIndex: this.startIndex,\n      startLine: this.startLine,\n      startLineStart: this.startLineStart,\n      lastIndex: this.lastIndex,\n      lastLine: this.lastLine,\n      lastLineStart: this.lastLineStart,\n      lookahead: this.lookahead,\n      hasLineTerminatorBeforeNext: this.hasLineTerminatorBeforeNext,\n      tokenIndex: this.tokenIndex,\n    };\n  }\n\n  restoreLexerState(state) {\n    this.source = state.source;\n    this.index = state.index;\n    this.line = state.line;\n    this.lineStart = state.lineStart;\n    this.startIndex = state.startIndex;\n    this.startLine = state.startLine;\n    this.startLineStart = state.startLineStart;\n    this.lastIndex = state.lastIndex;\n    this.lastLine = state.lastLine;\n    this.lastLineStart = state.lastLineStart;\n    this.lookahead = state.lookahead;\n    this.hasLineTerminatorBeforeNext = state.hasLineTerminatorBeforeNext;\n    this.tokenIndex = state.tokenIndex;\n  }\n\n  createILLEGAL() {\n    this.startIndex = this.index;\n    this.startLine = this.line;\n    this.startLineStart = this.lineStart;\n    return this.index < this.source.length\n      ? this.createError(ErrorMessages.UNEXPECTED_ILLEGAL_TOKEN, this.source.charAt(this.index))\n      : this.createError(ErrorMessages.UNEXPECTED_EOS);\n  }\n\n  createUnexpected(token) {\n    switch (token.type.klass) {\n      case TokenClass.Eof:\n        return this.createError(ErrorMessages.UNEXPECTED_EOS);\n      case TokenClass.Ident:\n        return this.createError(ErrorMessages.UNEXPECTED_IDENTIFIER);\n      case TokenClass.Keyword:\n        if (token.type === TokenType.ESCAPED_KEYWORD) {\n          return this.createError(ErrorMessages.UNEXPECTED_ESCAPED_KEYWORD);\n        }\n        return this.createError(ErrorMessages.UNEXPECTED_TOKEN, token.slice.text);\n      case TokenClass.NumericLiteral:\n        return this.createError(ErrorMessages.UNEXPECTED_NUMBER);\n      case TokenClass.TemplateElement:\n        return this.createError(ErrorMessages.UNEXPECTED_TEMPLATE);\n      case TokenClass.Punctuator:\n        return this.createError(ErrorMessages.UNEXPECTED_TOKEN, token.type.name);\n      case TokenClass.StringLiteral:\n        return this.createError(ErrorMessages.UNEXPECTED_STRING);\n      // the other token classes are RegularExpression and Illegal, but they cannot reach here\n    }\n    // istanbul ignore next\n    throw new Error('Unreachable: unexpected token of class ' + token.type.klass);\n  }\n\n  createError(message, ...params) {\n    let msg;\n    if (typeof message === 'function') {\n      msg = message(...params);\n    } else {\n      msg = message;\n    }\n    return new JsError(this.startIndex, this.startLine + 1, this.startIndex - this.startLineStart + 1, msg);\n  }\n\n  createErrorWithLocation(location, message) {\n    /* istanbul ignore next */\n    let msg = message.replace(/\\{(\\d+)\\}/g, (_, n) => JSON.stringify(arguments[+n + 2]));\n    if (location.slice && location.slice.startLocation) {\n      location = location.slice.startLocation;\n    }\n    return new JsError(location.offset, location.line, location.column + 1, msg);\n  }\n\n  static cse2(id, ch1, ch2) {\n    return id.charAt(1) === ch1 && id.charAt(2) === ch2;\n  }\n\n  static cse3(id, ch1, ch2, ch3) {\n    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3;\n  }\n\n  static cse4(id, ch1, ch2, ch3, ch4) {\n    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4;\n  }\n\n  static cse5(id, ch1, ch2, ch3, ch4, ch5) {\n    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5;\n  }\n\n  static cse6(id, ch1, ch2, ch3, ch4, ch5, ch6) {\n    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6;\n  }\n\n  static cse7(id, ch1, ch2, ch3, ch4, ch5, ch6, ch7) {\n    return id.charAt(1) === ch1 && id.charAt(2) === ch2 && id.charAt(3) === ch3 && id.charAt(4) === ch4 && id.charAt(5) === ch5 && id.charAt(6) === ch6 && id.charAt(7) === ch7;\n  }\n\n  getKeyword(id) {\n    if (id.length === 1 || id.length > 10) {\n      return TokenType.IDENTIFIER;\n    }\n\n    /* istanbul ignore next */\n    switch (id.length) {\n      case 2:\n        switch (id.charAt(0)) {\n          case 'i':\n            switch (id.charAt(1)) {\n              case 'f':\n                return TokenType.IF;\n              case 'n':\n                return TokenType.IN;\n              default:\n                break;\n            }\n            break;\n          case 'd':\n            if (id.charAt(1) === 'o') {\n              return TokenType.DO;\n            }\n            break;\n        }\n        break;\n      case 3:\n        switch (id.charAt(0)) {\n          case 'v':\n            if (Tokenizer.cse2(id, 'a', 'r')) {\n              return TokenType.VAR;\n            }\n            break;\n          case 'f':\n            if (Tokenizer.cse2(id, 'o', 'r')) {\n              return TokenType.FOR;\n            }\n            break;\n          case 'n':\n            if (Tokenizer.cse2(id, 'e', 'w')) {\n              return TokenType.NEW;\n            }\n            break;\n          case 't':\n            if (Tokenizer.cse2(id, 'r', 'y')) {\n              return TokenType.TRY;\n            }\n            break;\n          case 'l':\n            if (Tokenizer.cse2(id, 'e', 't')) {\n              return TokenType.LET;\n            }\n            break;\n        }\n        break;\n      case 4:\n        switch (id.charAt(0)) {\n          case 't':\n            if (Tokenizer.cse3(id, 'h', 'i', 's')) {\n              return TokenType.THIS;\n            } else if (Tokenizer.cse3(id, 'r', 'u', 'e')) {\n              return TokenType.TRUE;\n            }\n            break;\n          case 'n':\n            if (Tokenizer.cse3(id, 'u', 'l', 'l')) {\n              return TokenType.NULL;\n            }\n            break;\n          case 'e':\n            if (Tokenizer.cse3(id, 'l', 's', 'e')) {\n              return TokenType.ELSE;\n            } else if (Tokenizer.cse3(id, 'n', 'u', 'm')) {\n              return TokenType.ENUM;\n            }\n            break;\n          case 'c':\n            if (Tokenizer.cse3(id, 'a', 's', 'e')) {\n              return TokenType.CASE;\n            }\n            break;\n          case 'v':\n            if (Tokenizer.cse3(id, 'o', 'i', 'd')) {\n              return TokenType.VOID;\n            }\n            break;\n          case 'w':\n            if (Tokenizer.cse3(id, 'i', 't', 'h')) {\n              return TokenType.WITH;\n            }\n            break;\n        }\n        break;\n      case 5:\n        switch (id.charAt(0)) {\n          case 'a':\n            if (Tokenizer.cse4(id, 's', 'y', 'n', 'c')) {\n              return TokenType.ASYNC;\n            }\n            if (Tokenizer.cse4(id, 'w', 'a', 'i', 't')) {\n              return TokenType.AWAIT;\n            }\n            break;\n          case 'w':\n            if (Tokenizer.cse4(id, 'h', 'i', 'l', 'e')) {\n              return TokenType.WHILE;\n            }\n            break;\n          case 'b':\n            if (Tokenizer.cse4(id, 'r', 'e', 'a', 'k')) {\n              return TokenType.BREAK;\n            }\n            break;\n          case 'f':\n            if (Tokenizer.cse4(id, 'a', 'l', 's', 'e')) {\n              return TokenType.FALSE;\n            }\n            break;\n          case 'c':\n            if (Tokenizer.cse4(id, 'a', 't', 'c', 'h')) {\n              return TokenType.CATCH;\n            } else if (Tokenizer.cse4(id, 'o', 'n', 's', 't')) {\n              return TokenType.CONST;\n            } else if (Tokenizer.cse4(id, 'l', 'a', 's', 's')) {\n              return TokenType.CLASS;\n            }\n            break;\n          case 't':\n            if (Tokenizer.cse4(id, 'h', 'r', 'o', 'w')) {\n              return TokenType.THROW;\n            }\n            break;\n          case 'y':\n            if (Tokenizer.cse4(id, 'i', 'e', 'l', 'd')) {\n              return TokenType.YIELD;\n            }\n            break;\n          case 's':\n            if (Tokenizer.cse4(id, 'u', 'p', 'e', 'r')) {\n              return TokenType.SUPER;\n            }\n            break;\n        }\n        break;\n      case 6:\n        switch (id.charAt(0)) {\n          case 'r':\n            if (Tokenizer.cse5(id, 'e', 't', 'u', 'r', 'n')) {\n              return TokenType.RETURN;\n            }\n            break;\n          case 't':\n            if (Tokenizer.cse5(id, 'y', 'p', 'e', 'o', 'f')) {\n              return TokenType.TYPEOF;\n            }\n            break;\n          case 'd':\n            if (Tokenizer.cse5(id, 'e', 'l', 'e', 't', 'e')) {\n              return TokenType.DELETE;\n            }\n            break;\n          case 's':\n            if (Tokenizer.cse5(id, 'w', 'i', 't', 'c', 'h')) {\n              return TokenType.SWITCH;\n            }\n            break;\n          case 'e':\n            if (Tokenizer.cse5(id, 'x', 'p', 'o', 'r', 't')) {\n              return TokenType.EXPORT;\n            }\n            break;\n          case 'i':\n            if (Tokenizer.cse5(id, 'm', 'p', 'o', 'r', 't')) {\n              return TokenType.IMPORT;\n            }\n            break;\n        }\n        break;\n      case 7:\n        switch (id.charAt(0)) {\n          case 'd':\n            if (Tokenizer.cse6(id, 'e', 'f', 'a', 'u', 'l', 't')) {\n              return TokenType.DEFAULT;\n            }\n            break;\n          case 'f':\n            if (Tokenizer.cse6(id, 'i', 'n', 'a', 'l', 'l', 'y')) {\n              return TokenType.FINALLY;\n            }\n            break;\n          case 'e':\n            if (Tokenizer.cse6(id, 'x', 't', 'e', 'n', 'd', 's')) {\n              return TokenType.EXTENDS;\n            }\n            break;\n        }\n        break;\n      case 8:\n        switch (id.charAt(0)) {\n          case 'f':\n            if (Tokenizer.cse7(id, 'u', 'n', 'c', 't', 'i', 'o', 'n')) {\n              return TokenType.FUNCTION;\n            }\n            break;\n          case 'c':\n            if (Tokenizer.cse7(id, 'o', 'n', 't', 'i', 'n', 'u', 'e')) {\n              return TokenType.CONTINUE;\n            }\n            break;\n          case 'd':\n            if (Tokenizer.cse7(id, 'e', 'b', 'u', 'g', 'g', 'e', 'r')) {\n              return TokenType.DEBUGGER;\n            }\n            break;\n        }\n        break;\n      case 10:\n        if (id === 'instanceof') {\n          return TokenType.INSTANCEOF;\n        }\n        break;\n    }\n    return TokenType.IDENTIFIER;\n  }\n\n  skipSingleLineComment(offset) {\n    this.index += offset;\n    while (this.index < this.source.length) {\n      /**\n       * @type {Number}\n       */\n      let chCode = this.source.charCodeAt(this.index);\n      this.index++;\n      if (isLineTerminator(chCode)) {\n        this.hasLineTerminatorBeforeNext = true;\n        if (chCode === 0xD /* \"\\r\" */ && this.source.charCodeAt(this.index) === 0xA /* \"\\n\" */) {\n          this.index++;\n        }\n        this.lineStart = this.index;\n        this.line++;\n        return;\n      }\n    }\n  }\n\n  skipMultiLineComment() {\n    this.index += 2;\n    const length = this.source.length;\n    let isLineStart = false;\n    while (this.index < length) {\n      let chCode = this.source.charCodeAt(this.index);\n      if (chCode < 0x80) {\n        switch (chCode) {\n          case 42: // \"*\"\n            // Block comment ends with \"*/\".\n            if (this.source.charAt(this.index + 1) === '/') {\n              this.index = this.index + 2;\n              return isLineStart;\n            }\n            this.index++;\n            break;\n          case 10: // \"\\n\"\n            isLineStart = true;\n            this.hasLineTerminatorBeforeNext = true;\n            this.index++;\n            this.lineStart = this.index;\n            this.line++;\n            break;\n          case 13: // \"\\r\":\n            isLineStart = true;\n            this.hasLineTerminatorBeforeNext = true;\n            if (this.source.charAt(this.index + 1) === '\\n') {\n              this.index++;\n            }\n            this.index++;\n            this.lineStart = this.index;\n            this.line++;\n            break;\n          default:\n            this.index++;\n        }\n      } else if (chCode === 0x2028 || chCode === 0x2029) {\n        isLineStart = true;\n        this.hasLineTerminatorBeforeNext = true;\n        this.index++;\n        this.lineStart = this.index;\n        this.line++;\n      } else {\n        this.index++;\n      }\n    }\n    throw this.createILLEGAL();\n  }\n\n\n  skipComment() {\n    this.hasLineTerminatorBeforeNext = false;\n\n    let isLineStart = this.index === 0;\n    const length = this.source.length;\n\n    while (this.index < length) {\n      let chCode = this.source.charCodeAt(this.index);\n      if (isWhiteSpace(chCode)) {\n        this.index++;\n      } else if (isLineTerminator(chCode)) {\n        this.hasLineTerminatorBeforeNext = true;\n        this.index++;\n        if (chCode === 13 /* \"\\r\" */ && this.source.charAt(this.index) === '\\n') {\n          this.index++;\n        }\n        this.lineStart = this.index;\n        this.line++;\n        isLineStart = true;\n      } else if (chCode === 47 /* \"/\" */) {\n        if (this.index + 1 >= length) {\n          break;\n        }\n        chCode = this.source.charCodeAt(this.index + 1);\n        if (chCode === 47 /* \"/\" */) {\n          this.skipSingleLineComment(2);\n          isLineStart = true;\n        } else if (chCode === 42 /* \"*\" */) {\n          isLineStart = this.skipMultiLineComment() || isLineStart;\n        } else {\n          break;\n        }\n      } else if (!this.moduleIsTheGoalSymbol && isLineStart && chCode === 45 /* \"-\" */) {\n        if (this.index + 2 >= length) {\n          break;\n        }\n        // U+003E is \">\"\n        if (this.source.charAt(this.index + 1) === '-' && this.source.charAt(this.index + 2) === '>') {\n          // \"-->\" is a single-line comment\n          this.skipSingleLineComment(3);\n        } else {\n          break;\n        }\n      } else if (!this.moduleIsTheGoalSymbol && chCode === 60 /* \"<\" */) {\n        if (this.source.slice(this.index + 1, this.index + 4) === '!--') {\n          this.skipSingleLineComment(4);\n          isLineStart = true;\n        } else {\n          break;\n        }\n      } else {\n        break;\n      }\n    }\n  }\n\n  scanHexEscape2() {\n    if (this.index + 2 > this.source.length) {\n      return -1;\n    }\n    let r1 = getHexValue(this.source.charAt(this.index));\n    if (r1 === -1) {\n      return -1;\n    }\n    let r2 = getHexValue(this.source.charAt(this.index + 1));\n    if (r2 === -1) {\n      return -1;\n    }\n    this.index += 2;\n    return r1 << 4 | r2;\n  }\n\n  scanUnicode() {\n    if (this.source.charAt(this.index) === '{') {\n      // \\u{HexDigits}\n      let i = this.index + 1;\n      let hexDigits = 0, ch;\n      while (i < this.source.length) {\n        ch = this.source.charAt(i);\n        let hex = getHexValue(ch);\n        if (hex === -1) {\n          break;\n        }\n        hexDigits = hexDigits << 4 | hex;\n        if (hexDigits > 0x10FFFF) {\n          throw this.createILLEGAL();\n        }\n        i++;\n      }\n      if (ch !== '}') {\n        throw this.createILLEGAL();\n      }\n      if (i === this.index + 1) {\n        ++this.index; // This is so that the error is 'Unexpected \"}\"' instead of 'Unexpected \"{\"'.\n        throw this.createILLEGAL();\n      }\n      this.index = i + 1;\n      return hexDigits;\n    }\n    // \\uHex4Digits\n    if (this.index + 4 > this.source.length) {\n      return -1;\n    }\n    let r1 = getHexValue(this.source.charAt(this.index));\n    if (r1 === -1) {\n      return -1;\n    }\n    let r2 = getHexValue(this.source.charAt(this.index + 1));\n    if (r2 === -1) {\n      return -1;\n    }\n    let r3 = getHexValue(this.source.charAt(this.index + 2));\n    if (r3 === -1) {\n      return -1;\n    }\n    let r4 = getHexValue(this.source.charAt(this.index + 3));\n    if (r4 === -1) {\n      return -1;\n    }\n    this.index += 4;\n    return r1 << 12 | r2 << 8 | r3 << 4 | r4;\n  }\n\n  getEscapedIdentifier() {\n    let id = '';\n    let check = isIdentifierStart;\n\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      let code = ch.charCodeAt(0);\n      let start = this.index;\n      ++this.index;\n      if (ch === '\\\\') {\n        if (this.index >= this.source.length) {\n          throw this.createILLEGAL();\n        }\n        if (this.source.charAt(this.index) !== 'u') {\n          throw this.createILLEGAL();\n        }\n        ++this.index;\n        code = this.scanUnicode();\n        if (code < 0) {\n          throw this.createILLEGAL();\n        }\n        ch = fromCodePoint(code);\n      } else if (code >= 0xD800 && code <= 0xDBFF) {\n        if (this.index >= this.source.length) {\n          throw this.createILLEGAL();\n        }\n        let lowSurrogateCode = this.source.charCodeAt(this.index);\n        ++this.index;\n        if (!(lowSurrogateCode >= 0xDC00 && lowSurrogateCode <= 0xDFFF)) {\n          throw this.createILLEGAL();\n        }\n        code = decodeUtf16(code, lowSurrogateCode);\n        ch = fromCodePoint(code);\n      }\n      if (!check(code)) {\n        if (id.length < 1) {\n          throw this.createILLEGAL();\n        }\n        this.index = start;\n        return id;\n      }\n      check = isIdentifierPart;\n      id += ch;\n    }\n    return id;\n  }\n\n  getIdentifier() {\n    let start = this.index;\n    let l = this.source.length;\n    let i = this.index;\n    let check = isIdentifierStart;\n    while (i < l) {\n      let ch = this.source.charAt(i);\n      let code = ch.charCodeAt(0);\n      if (ch === '\\\\' || code >= 0xD800 && code <= 0xDBFF) {\n        // Go back and try the hard one.\n        this.index = start;\n        return this.getEscapedIdentifier();\n      }\n      if (!check(code)) {\n        this.index = i;\n        return this.source.slice(start, i);\n      }\n      ++i;\n      check = isIdentifierPart;\n    }\n    this.index = i;\n    return this.source.slice(start, i);\n  }\n\n  scanIdentifier() {\n    let startLocation = this.getLocation();\n    let start = this.index;\n\n    // Backslash (U+005C) starts an escaped character.\n    let id = this.source.charAt(this.index) === '\\\\' ? this.getEscapedIdentifier() : this.getIdentifier();\n\n    let slice = this.getSlice(start, startLocation);\n    slice.text = id;\n    let hasEscape = this.index - start !== id.length;\n\n    let type = this.getKeyword(id);\n    if (hasEscape && type !== TokenType.IDENTIFIER) {\n      type = TokenType.ESCAPED_KEYWORD;\n    }\n    return { type, value: id, slice, escaped: hasEscape };\n  }\n\n  getLocation() {\n    return {\n      line: this.startLine + 1,\n      column: this.startIndex - this.startLineStart,\n      offset: this.startIndex,\n    };\n  }\n\n  getLastTokenEndLocation() {\n    return {\n      line: this.lastLine + 1,\n      column: this.lastIndex - this.lastLineStart,\n      offset: this.lastIndex,\n    };\n  }\n\n  getSlice(start, startLocation) {\n    return { text: this.source.slice(start, this.index), start, startLocation, end: this.index };\n  }\n\n  scanPunctuatorHelper() {\n    let ch1 = this.source.charAt(this.index);\n\n    switch (ch1) {\n      // Check for most common single-character punctuators.\n      case '.': {\n        let ch2 = this.source.charAt(this.index + 1);\n        if (ch2 !== '.') return TokenType.PERIOD;\n        let ch3 = this.source.charAt(this.index + 2);\n        if (ch3 !== '.') return TokenType.PERIOD;\n        return TokenType.ELLIPSIS;\n      }\n      case '(':\n        return TokenType.LPAREN;\n      case ')':\n      case ';':\n      case ',':\n        return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];\n      case '{':\n        return TokenType.LBRACE;\n      case '}':\n      case '[':\n      case ']':\n      case ':':\n      case '?':\n      case '~':\n        return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];\n      default:\n        // \"=\" (U+003D) marks an assignment or comparison operator.\n        if (this.index + 1 < this.source.length && this.source.charAt(this.index + 1) === '=') {\n          switch (ch1) {\n            case '=':\n              if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === '=') {\n                return TokenType.EQ_STRICT;\n              }\n              return TokenType.EQ;\n            case '!':\n              if (this.index + 2 < this.source.length && this.source.charAt(this.index + 2) === '=') {\n                return TokenType.NE_STRICT;\n              }\n              return TokenType.NE;\n            case '|':\n              return TokenType.ASSIGN_BIT_OR;\n            case '+':\n              return TokenType.ASSIGN_ADD;\n            case '-':\n              return TokenType.ASSIGN_SUB;\n            case '*':\n              return TokenType.ASSIGN_MUL;\n            case '<':\n              return TokenType.LTE;\n            case '>':\n              return TokenType.GTE;\n            case '/':\n              return TokenType.ASSIGN_DIV;\n            case '%':\n              return TokenType.ASSIGN_MOD;\n            case '^':\n              return TokenType.ASSIGN_BIT_XOR;\n            case '&':\n              return TokenType.ASSIGN_BIT_AND;\n            // istanbul ignore next\n            default:\n              break; // failed\n          }\n        }\n    }\n\n    if (this.index + 1 < this.source.length) {\n      let ch2 = this.source.charAt(this.index + 1);\n      if (ch1 === ch2) {\n        if (this.index + 2 < this.source.length) {\n          let ch3 = this.source.charAt(this.index + 2);\n          if (ch1 === '>' && ch3 === '>') {\n            // 4-character punctuator: >>>=\n            if (this.index + 3 < this.source.length && this.source.charAt(this.index + 3) === '=') {\n              return TokenType.ASSIGN_SHR_UNSIGNED;\n            }\n            return TokenType.SHR_UNSIGNED;\n          }\n\n          if (ch1 === '<' && ch3 === '=') {\n            return TokenType.ASSIGN_SHL;\n          }\n\n          if (ch1 === '>' && ch3 === '=') {\n            return TokenType.ASSIGN_SHR;\n          }\n\n          if (ch1 === '*' && ch3 === '=') {\n            return TokenType.ASSIGN_EXP;\n          }\n        }\n        // Other 2-character punctuators: ++ -- << >> && ||\n        switch (ch1) {\n          case '*':\n            return TokenType.EXP;\n          case '+':\n            return TokenType.INC;\n          case '-':\n            return TokenType.DEC;\n          case '<':\n            return TokenType.SHL;\n          case '>':\n            return TokenType.SHR;\n          case '&':\n            return TokenType.AND;\n          case '|':\n            return TokenType.OR;\n          // istanbul ignore next\n          default:\n            break; // failed\n        }\n      } else if (ch1 === '=' && ch2 === '>') {\n        return TokenType.ARROW;\n      }\n    }\n\n    return ONE_CHAR_PUNCTUATOR[ch1.charCodeAt(0)];\n  }\n\n  // 7.7 Punctuators\n  scanPunctuator() {\n    let startLocation = this.getLocation();\n    let start = this.index;\n    let subType = this.scanPunctuatorHelper();\n    this.index += subType.name.length;\n    return { type: subType, value: subType.name, slice: this.getSlice(start, startLocation) };\n  }\n\n  scanHexLiteral(start, startLocation) {\n    let i = this.index;\n    while (i < this.source.length) {\n      let ch = this.source.charAt(i);\n      let hex = getHexValue(ch);\n      if (hex === -1) {\n        break;\n      }\n      i++;\n    }\n\n    if (this.index === i) {\n      throw this.createILLEGAL();\n    }\n\n    if (i < this.source.length && isIdentifierStart(this.source.charCodeAt(i))) {\n      throw this.createILLEGAL();\n    }\n\n    this.index = i;\n\n    let slice = this.getSlice(start, startLocation);\n    return { type: TokenType.NUMBER, value: parseInt(slice.text.substr(2), 16), slice };\n  }\n\n  scanBinaryLiteral(start, startLocation) {\n    let offset = this.index - start;\n\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      if (ch !== '0' && ch !== '1') {\n        break;\n      }\n      this.index++;\n    }\n\n    if (this.index - start <= offset) {\n      throw this.createILLEGAL();\n    }\n\n    if (this.index < this.source.length && (isIdentifierStart(this.source.charCodeAt(this.index))\n        || isDecimalDigit(this.source.charCodeAt(this.index)))) {\n      throw this.createILLEGAL();\n    }\n\n    return {\n      type: TokenType.NUMBER,\n      value: parseInt(this.getSlice(start, startLocation).text.substr(offset), 2),\n      slice: this.getSlice(start, startLocation),\n      octal: false,\n      noctal: false,\n    };\n  }\n\n  scanOctalLiteral(start, startLocation) {\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      if (ch >= '0' && ch <= '7') {\n        this.index++;\n      } else if (isIdentifierPart(ch.charCodeAt(0))) {\n        throw this.createILLEGAL();\n      } else {\n        break;\n      }\n    }\n\n    if (this.index - start === 2) {\n      throw this.createILLEGAL();\n    }\n\n    return {\n      type: TokenType.NUMBER,\n      value: parseInt(this.getSlice(start, startLocation).text.substr(2), 8),\n      slice: this.getSlice(start, startLocation),\n      octal: false,\n      noctal: false,\n    };\n  }\n\n  scanLegacyOctalLiteral(start, startLocation) {\n    let isOctal = true;\n\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      if (ch >= '0' && ch <= '7') {\n        this.index++;\n      } else if (ch === '8' || ch === '9') {\n        isOctal = false;\n        this.index++;\n      } else if (isIdentifierPart(ch.charCodeAt(0))) {\n        throw this.createILLEGAL();\n      } else {\n        break;\n      }\n    }\n\n    let slice = this.getSlice(start, startLocation);\n    if (!isOctal) {\n      this.eatDecimalLiteralSuffix();\n      return {\n        type: TokenType.NUMBER,\n        slice,\n        value: +slice.text,\n        octal: true,\n        noctal: !isOctal,\n      };\n    }\n\n    return {\n      type: TokenType.NUMBER,\n      slice,\n      value: parseInt(slice.text.substr(1), 8),\n      octal: true,\n      noctal: !isOctal,\n    };\n  }\n\n  scanNumericLiteral() {\n    let ch = this.source.charAt(this.index);\n    // assert(ch === \".\" || \"0\" <= ch && ch <= \"9\")\n    let startLocation = this.getLocation();\n    let start = this.index;\n\n    if (ch === '0') {\n      this.index++;\n      if (this.index < this.source.length) {\n        ch = this.source.charAt(this.index);\n        if (ch === 'x' || ch === 'X') {\n          this.index++;\n          return this.scanHexLiteral(start, startLocation);\n        } else if (ch === 'b' || ch === 'B') {\n          this.index++;\n          return this.scanBinaryLiteral(start, startLocation);\n        } else if (ch === 'o' || ch === 'O') {\n          this.index++;\n          return this.scanOctalLiteral(start, startLocation);\n        } else if (ch >= '0' && ch <= '9') {\n          return this.scanLegacyOctalLiteral(start, startLocation);\n        }\n      } else {\n        let slice = this.getSlice(start, startLocation);\n        return {\n          type: TokenType.NUMBER,\n          value: +slice.text,\n          slice,\n          octal: false,\n          noctal: false,\n        };\n      }\n    } else if (ch !== '.') {\n      // Must be \"1\"..\"9\"\n      ch = this.source.charAt(this.index);\n      while (ch >= '0' && ch <= '9') {\n        this.index++;\n        if (this.index === this.source.length) {\n          let slice = this.getSlice(start, startLocation);\n          return {\n            type: TokenType.NUMBER,\n            value: +slice.text,\n            slice,\n            octal: false,\n            noctal: false,\n          };\n        }\n        ch = this.source.charAt(this.index);\n      }\n    }\n\n    this.eatDecimalLiteralSuffix();\n\n    if (this.index !== this.source.length && isIdentifierStart(this.source.charCodeAt(this.index))) {\n      throw this.createILLEGAL();\n    }\n\n    let slice = this.getSlice(start, startLocation);\n    return {\n      type: TokenType.NUMBER,\n      value: +slice.text,\n      slice,\n      octal: false,\n      noctal: false,\n    };\n  }\n\n  eatDecimalLiteralSuffix() {\n    let ch = this.source.charAt(this.index);\n    if (ch === '.') {\n      this.index++;\n      if (this.index === this.source.length) {\n        return;\n      }\n\n      ch = this.source.charAt(this.index);\n      while (ch >= '0' && ch <= '9') {\n        this.index++;\n        if (this.index === this.source.length) {\n          return;\n        }\n        ch = this.source.charAt(this.index);\n      }\n    }\n\n    // EOF not reached here\n    if (ch === 'e' || ch === 'E') {\n      this.index++;\n      if (this.index === this.source.length) {\n        throw this.createILLEGAL();\n      }\n\n      ch = this.source.charAt(this.index);\n      if (ch === '+' || ch === '-') {\n        this.index++;\n        if (this.index === this.source.length) {\n          throw this.createILLEGAL();\n        }\n        ch = this.source.charAt(this.index);\n      }\n\n      if (ch >= '0' && ch <= '9') {\n        while (ch >= '0' && ch <= '9') {\n          this.index++;\n          if (this.index === this.source.length) {\n            break;\n          }\n          ch = this.source.charAt(this.index);\n        }\n      } else {\n        throw this.createILLEGAL();\n      }\n    }\n  }\n\n  scanStringEscape(str, octal) {\n    this.index++;\n    if (this.index === this.source.length) {\n      throw this.createILLEGAL();\n    }\n    let ch = this.source.charAt(this.index);\n    if (isLineTerminator(ch.charCodeAt(0))) {\n      this.index++;\n      if (ch === '\\r' && this.source.charAt(this.index) === '\\n') {\n        this.index++;\n      }\n      this.lineStart = this.index;\n      this.line++;\n    } else {\n      switch (ch) {\n        case 'n':\n          str += '\\n';\n          this.index++;\n          break;\n        case 'r':\n          str += '\\r';\n          this.index++;\n          break;\n        case 't':\n          str += '\\t';\n          this.index++;\n          break;\n        case 'u':\n        case 'x': {\n          let unescaped;\n          this.index++;\n          if (this.index >= this.source.length) {\n            throw this.createILLEGAL();\n          }\n          unescaped = ch === 'u' ? this.scanUnicode() : this.scanHexEscape2();\n          if (unescaped < 0) {\n            throw this.createILLEGAL();\n          }\n          str += fromCodePoint(unescaped);\n          break;\n        }\n        case 'b':\n          str += '\\b';\n          this.index++;\n          break;\n        case 'f':\n          str += '\\f';\n          this.index++;\n          break;\n        case 'v':\n          str += '\\u000B';\n          this.index++;\n          break;\n        default:\n          if (ch >= '0' && ch <= '7') {\n            let octalStart = this.index;\n            let octLen = 1;\n            // 3 digits are only allowed when string starts\n            // with 0, 1, 2, 3\n            if (ch >= '0' && ch <= '3') {\n              octLen = 0;\n            }\n            let code = 0;\n            while (octLen < 3 && ch >= '0' && ch <= '7') {\n              this.index++;\n              if (octLen > 0 || ch !== '0') {\n                octal = this.source.slice(octalStart, this.index);\n              }\n              code *= 8;\n              code += ch - '0';\n              octLen++;\n              if (this.index === this.source.length) {\n                throw this.createILLEGAL();\n              }\n              ch = this.source.charAt(this.index);\n            }\n            if (code === 0 && octLen === 1 && (ch === '8' || ch === '9')) {\n              octal = this.source.slice(octalStart, this.index + 1);\n            }\n            str += String.fromCharCode(code);\n          } else if (ch === '8' || ch === '9') {\n            throw this.createILLEGAL();\n          } else {\n            str += ch;\n            this.index++;\n          }\n      }\n    }\n    return [str, octal];\n  }\n  // 7.8.4 String Literals\n  scanStringLiteral() {\n    let str = '';\n\n    let quote = this.source.charAt(this.index);\n    //  assert((quote === \"\\\"\" || quote === \"\"\"), \"String literal must starts with a quote\")\n\n    let startLocation = this.getLocation();\n    let start = this.index;\n    this.index++;\n\n    let octal = null;\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      if (ch === quote) {\n        this.index++;\n        return { type: TokenType.STRING, slice: this.getSlice(start, startLocation), str, octal };\n      } else if (ch === '\\\\') {\n        [str, octal] = this.scanStringEscape(str, octal);\n      } else if (isLineTerminator(ch.charCodeAt(0)) && ch !== 0x2028 && ch !== 0x2029) {\n        throw this.createILLEGAL();\n      } else {\n        str += ch;\n        this.index++;\n      }\n    }\n\n    throw this.createILLEGAL();\n  }\n\n  scanTemplateElement() {\n    let startLocation = this.getLocation();\n    let start = this.index;\n    this.index++;\n    while (this.index < this.source.length) {\n      let ch = this.source.charCodeAt(this.index);\n      switch (ch) {\n        case 0x60: { // `\n          this.index++;\n          return { type: TokenType.TEMPLATE, tail: true, slice: this.getSlice(start, startLocation) };\n        }\n        case 0x24: { // $\n          if (this.source.charCodeAt(this.index + 1) === 0x7B) { // {\n            this.index += 2;\n            return { type: TokenType.TEMPLATE, tail: false, slice: this.getSlice(start, startLocation) };\n          }\n          this.index++;\n          break;\n        }\n        case 0x5C: { // \\\\\n          let octal = this.scanStringEscape('', null)[1];\n          if (octal != null) {\n            throw this.createError(ErrorMessages.NO_OCTALS_IN_TEMPLATES);\n          }\n          break;\n        }\n        case 0x0D: { // \\r\n          this.line++;\n          this.index++;\n          if (this.index < this.source.length && this.source.charAt(this.index) === '\\n') {\n            this.index++;\n          }\n          this.lineStart = this.index;\n          break;\n        }\n        case 0x0A: // \\r\n        case 0x2028:\n        case 0x2029: {\n          this.line++;\n          this.index++;\n          this.lineStart = this.index;\n          break;\n        }\n        default:\n          this.index++;\n      }\n    }\n\n    throw this.createILLEGAL();\n  }\n\n  scanRegExp(str) {\n    let startLocation = this.getLocation();\n    let start = this.index;\n\n    let terminated = false;\n    let classMarker = false;\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      if (ch === '\\\\') {\n        str += ch;\n        this.index++;\n        ch = this.source.charAt(this.index);\n        // ECMA-262 7.8.5\n        if (isLineTerminator(ch.charCodeAt(0))) {\n          throw this.createError(ErrorMessages.UNTERMINATED_REGEXP);\n        }\n        str += ch;\n        this.index++;\n      } else if (isLineTerminator(ch.charCodeAt(0))) {\n        throw this.createError(ErrorMessages.UNTERMINATED_REGEXP);\n      } else {\n        if (classMarker) {\n          if (ch === ']') {\n            classMarker = false;\n          }\n        } else if (ch === '/') {\n          terminated = true;\n          str += ch;\n          this.index++;\n          break;\n        } else if (ch === '[') {\n          classMarker = true;\n        }\n        str += ch;\n        this.index++;\n      }\n    }\n\n    if (!terminated) {\n      throw this.createError(ErrorMessages.UNTERMINATED_REGEXP);\n    }\n\n    while (this.index < this.source.length) {\n      let ch = this.source.charAt(this.index);\n      if (ch === '\\\\') {\n        throw this.createError(ErrorMessages.INVALID_REGEXP_FLAGS);\n      }\n      if (!isIdentifierPart(ch.charCodeAt(0))) {\n        break;\n      }\n      this.index++;\n      str += ch;\n    }\n    return { type: TokenType.REGEXP, value: str, slice: this.getSlice(start, startLocation) };\n  }\n\n  advance() {\n    let startLocation = this.getLocation();\n\n    this.lastIndex = this.index;\n    this.lastLine = this.line;\n    this.lastLineStart = this.lineStart;\n\n    this.skipComment();\n\n    this.startIndex = this.index;\n    this.startLine = this.line;\n    this.startLineStart = this.lineStart;\n\n    if (this.lastIndex === 0) {\n      this.lastIndex = this.index;\n      this.lastLine = this.line;\n      this.lastLineStart = this.lineStart;\n    }\n\n    if (this.index >= this.source.length) {\n      return { type: TokenType.EOS, slice: this.getSlice(this.index, startLocation) };\n    }\n\n    let charCode = this.source.charCodeAt(this.index);\n\n    if (charCode < 0x80) {\n      if (PUNCTUATOR_START[charCode]) {\n        return this.scanPunctuator();\n      }\n\n      if (isIdentifierStart(charCode) || charCode === 0x5C /* backslash (\\) */) {\n        return this.scanIdentifier();\n      }\n\n      // Dot (.) U+002E can also start a floating-point number, hence the need\n      // to check the next character.\n      if (charCode === 0x2E) {\n        if (this.index + 1 < this.source.length && isDecimalDigit(this.source.charCodeAt(this.index + 1))) {\n          return this.scanNumericLiteral();\n        }\n        return this.scanPunctuator();\n      }\n\n      // String literal starts with single quote (U+0027) or double quote (U+0022).\n      if (charCode === 0x27 || charCode === 0x22) {\n        return this.scanStringLiteral();\n      }\n\n      // Template literal starts with back quote (U+0060)\n      if (charCode === 0x60) {\n        return this.scanTemplateElement();\n      }\n\n      if (charCode /* \"0\" */ >= 0x30 && charCode <= 0x39 /* \"9\" */) {\n        return this.scanNumericLiteral();\n      }\n\n      // Slash (/) U+002F can also start a regex.\n      throw this.createILLEGAL();\n    } else {\n      if (isIdentifierStart(charCode) || charCode >= 0xD800 && charCode <= 0xDBFF) {\n        return this.scanIdentifier();\n      }\n\n      throw this.createILLEGAL();\n    }\n  }\n\n  eof() {\n    return this.lookahead.type === TokenType.EOS;\n  }\n\n  lex() {\n    let prevToken = this.lookahead;\n    this.lookahead = this.advance();\n    this.tokenIndex++;\n    return prevToken;\n  }\n}\n\nmodule.exports = {\n  default: Tokenizer,\n  Tokenizer,\n  TokenClass,\n  TokenType,\n  JsError,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}