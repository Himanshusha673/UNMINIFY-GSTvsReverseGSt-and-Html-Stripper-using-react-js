{"ast":null,"code":"const {\n  reduce,\n  adapt\n} = require('shift-reducer');\nconst {\n  TokenStream,\n  needsDoubleDot\n} = require('./token-stream');\nconst MinimalCodeGen = require('./minimal-codegen');\nfunction mightHaveSemi(type) {\n  return /(Import)|(Export)|(Statement)|(Directive)|(SwitchCase)|(SwitchDefault)/.test(type);\n}\nclass TokenStreamWithLocation extends TokenStream {\n  constructor() {\n    super();\n    this.line = 1;\n    this.column = 0;\n    this.startingNodes = [];\n    this.finishingStatements = [];\n    this.lastNumberNode = null;\n    this.locations = new WeakMap();\n  }\n  putRaw(tokenStr) {\n    let previousLength = this.result.length;\n    super.putRaw(tokenStr);\n    this.startNodes(tokenStr, previousLength);\n  }\n  put(tokenStr, isRegExp) {\n    if (this.optionalSemi && tokenStr !== '}') {\n      for (let obj of this.finishingStatements) {\n        ++obj.end.column;\n        ++obj.end.offset;\n      }\n    }\n    this.finishingStatements = [];\n    if (this.lastNumber !== null && tokenStr === '.' && needsDoubleDot(this.lastNumber)) {\n      let loc = this.locations.get(this.lastNumberNode).end;\n      ++loc.column;\n      ++loc.offset;\n    }\n    this.lastNumberNode = null;\n    let previousLength = this.result.length;\n    super.put(tokenStr, isRegExp);\n    this.startNodes(tokenStr, previousLength);\n  }\n  startNodes(tokenStr, previousLength) {\n    let linebreakRegex = /\\r\\n?|[\\n\\u2028\\u2029]/g;\n    let matched = false;\n    let match;\n    let startLine = this.line;\n    let startColumn = this.column;\n    while (match = linebreakRegex.exec(tokenStr)) {\n      ++this.line;\n      this.column = tokenStr.length - match.index - match[0].length;\n      matched = true;\n    }\n    if (!matched) {\n      this.column += this.result.length - previousLength;\n      startColumn = this.column - tokenStr.length; // i.e., skip past any additional characters which were necessitated by, but not part of, this part\n    }\n    for (const node of this.startingNodes) {\n      this.locations.set(node, {\n        start: {\n          line: startLine,\n          column: startColumn,\n          offset: this.result.length - tokenStr.length\n        },\n        end: null\n      });\n    }\n    this.startingNodes = [];\n  }\n  startEmit(node) {\n    this.startingNodes.push(node);\n  }\n  finishEmit(node) {\n    this.locations.get(node).end = {\n      line: this.line,\n      column: this.column,\n      offset: this.result.length\n    };\n    if (mightHaveSemi(node.type)) {\n      this.finishingStatements.push(this.locations.get(node));\n    }\n  }\n}\nfunction addLocation(rep, node) {\n  const originalEmit = rep.emit.bind(rep);\n  if (node.type === 'Script' || node.type === 'Module') {\n    // These are handled specially: they include beginning and trailing whitespace.\n    rep.emit = (ts, ...args) => {\n      ts.locations.set(node, {\n        start: {\n          line: 1,\n          column: 0,\n          offset: 0\n        },\n        end: null\n      });\n      originalEmit(ts, ...args);\n      ts.locations.get(node).end = {\n        line: ts.line,\n        column: ts.column,\n        offset: ts.result.length\n      };\n    };\n  } else if (node.type === 'LiteralNumericExpression') {\n    rep.emit = (ts, ...args) => {\n      ts.startEmit(node);\n      originalEmit(ts, ...args);\n      ts.finishEmit(node);\n      ts.lastNumberNode = node;\n    };\n  } else {\n    rep.emit = (ts, ...args) => {\n      ts.startEmit(node);\n      originalEmit(ts, ...args);\n      ts.finishEmit(node);\n    };\n  }\n  return rep;\n}\nfunction addLocationToReducer(reducer) {\n  const wrapped = adapt(addLocation, reducer);\n  const originalRegenerate = wrapped.regenerateArrowParams.bind(wrapped);\n  wrapped.regenerateArrowParams = function (element, original) {\n    const out = originalRegenerate(element, original);\n    if (out !== original) {\n      addLocation(out, element);\n    }\n    return out;\n  };\n  const originalDirective = wrapped.parenToAvoidBeingDirective.bind(wrapped);\n  wrapped.parenToAvoidBeingDirective = function (element, original) {\n    const out = originalDirective(element, original);\n    if (out !== original) {\n      addLocation(out, element);\n    }\n    return out;\n  };\n  return wrapped;\n}\nfunction codeGenWithLocation(program, generator = new MinimalCodeGen()) {\n  let ts = new TokenStreamWithLocation();\n  let rep = reduce(addLocationToReducer(generator), program);\n  rep.emit(ts);\n  return {\n    source: ts.result,\n    locations: ts.locations\n  };\n}\nmodule.exports = codeGenWithLocation;","map":{"version":3,"names":["reduce","adapt","require","TokenStream","needsDoubleDot","MinimalCodeGen","mightHaveSemi","type","test","TokenStreamWithLocation","constructor","line","column","startingNodes","finishingStatements","lastNumberNode","locations","WeakMap","putRaw","tokenStr","previousLength","result","length","startNodes","put","isRegExp","optionalSemi","obj","end","offset","lastNumber","loc","get","linebreakRegex","matched","match","startLine","startColumn","exec","index","node","set","start","startEmit","push","finishEmit","addLocation","rep","originalEmit","emit","bind","ts","args","addLocationToReducer","reducer","wrapped","originalRegenerate","regenerateArrowParams","element","original","out","originalDirective","parenToAvoidBeingDirective","codeGenWithLocation","program","generator","source","module","exports"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/shift-codegen/src/with-location.js"],"sourcesContent":["const { reduce, adapt } = require('shift-reducer');\nconst { TokenStream, needsDoubleDot } = require('./token-stream');\nconst MinimalCodeGen = require('./minimal-codegen');\n\nfunction mightHaveSemi(type) {\n  return /(Import)|(Export)|(Statement)|(Directive)|(SwitchCase)|(SwitchDefault)/.test(type);\n}\n\nclass TokenStreamWithLocation extends TokenStream {\n  constructor() {\n    super();\n    this.line = 1;\n    this.column = 0;\n    this.startingNodes = [];\n    this.finishingStatements = [];\n    this.lastNumberNode = null;\n    this.locations = new WeakMap;\n  }\n\n  putRaw(tokenStr) {\n    let previousLength = this.result.length;\n    super.putRaw(tokenStr);\n    this.startNodes(tokenStr, previousLength);\n  }\n\n  put(tokenStr, isRegExp) {\n    if (this.optionalSemi && tokenStr !== '}') {\n      for (let obj of this.finishingStatements) {\n        ++obj.end.column;\n        ++obj.end.offset;\n      }\n    }\n    this.finishingStatements = [];\n\n    if (this.lastNumber !== null && tokenStr === '.' && needsDoubleDot(this.lastNumber)) {\n      let loc = this.locations.get(this.lastNumberNode).end;\n      ++loc.column;\n      ++loc.offset;\n    }\n    this.lastNumberNode = null;\n\n    let previousLength = this.result.length;\n    super.put(tokenStr, isRegExp);\n    this.startNodes(tokenStr, previousLength);\n  }\n\n  startNodes(tokenStr, previousLength) {\n    let linebreakRegex = /\\r\\n?|[\\n\\u2028\\u2029]/g;\n    let matched = false;\n    let match;\n    let startLine = this.line;\n    let startColumn = this.column;\n    while ((match = linebreakRegex.exec(tokenStr))) {\n      ++this.line;\n      this.column = tokenStr.length - match.index - match[0].length;\n      matched = true;\n    }\n\n    if (!matched) {\n      this.column += this.result.length - previousLength;\n      startColumn = this.column - tokenStr.length; // i.e., skip past any additional characters which were necessitated by, but not part of, this part\n    }\n    for (const node of this.startingNodes) {\n      this.locations.set(node, {\n        start: {\n          line: startLine,\n          column: startColumn,\n          offset: this.result.length - tokenStr.length,\n        },\n        end: null,\n      });\n    }\n    this.startingNodes = [];\n  }\n\n  startEmit(node) {\n    this.startingNodes.push(node);\n  }\n\n  finishEmit(node) {\n    this.locations.get(node).end = {\n      line: this.line,\n      column: this.column,\n      offset: this.result.length,\n    };\n    if (mightHaveSemi(node.type)) {\n      this.finishingStatements.push(this.locations.get(node));\n    }\n  }\n}\n\nfunction addLocation(rep, node) {\n  const originalEmit = rep.emit.bind(rep);\n  if (node.type === 'Script' || node.type === 'Module') {\n    // These are handled specially: they include beginning and trailing whitespace.\n    rep.emit = (ts, ...args) => {\n      ts.locations.set(node, {\n        start: {\n          line: 1,\n          column: 0,\n          offset: 0,\n        },\n        end: null,\n      });\n      originalEmit(ts, ...args);\n      ts.locations.get(node).end = {\n        line: ts.line,\n        column: ts.column,\n        offset: ts.result.length,\n      };\n    };\n  } else if (node.type === 'LiteralNumericExpression') {\n    rep.emit = (ts, ...args) => {\n      ts.startEmit(node);\n      originalEmit(ts, ...args);\n      ts.finishEmit(node);\n      ts.lastNumberNode = node;\n    };\n  } else {\n    rep.emit = (ts, ...args) => {\n      ts.startEmit(node);\n      originalEmit(ts, ...args);\n      ts.finishEmit(node);\n    };\n  }\n  return rep;\n}\n\nfunction addLocationToReducer(reducer) {\n  const wrapped = adapt(addLocation, reducer);\n\n  const originalRegenerate = wrapped.regenerateArrowParams.bind(wrapped);\n  wrapped.regenerateArrowParams = function (element, original) {\n    const out = originalRegenerate(element, original);\n    if (out !== original) {\n      addLocation(out, element);\n    }\n    return out;\n  };\n\n  const originalDirective = wrapped.parenToAvoidBeingDirective.bind(wrapped);\n  wrapped.parenToAvoidBeingDirective = function (element, original) {\n    const out = originalDirective(element, original);\n    if (out !== original) {\n      addLocation(out, element);\n    }\n    return out;\n  };\n\n  return wrapped;\n}\n\nfunction codeGenWithLocation(program, generator = new MinimalCodeGen) {\n  let ts = new TokenStreamWithLocation;\n  let rep = reduce(addLocationToReducer(generator), program);\n  rep.emit(ts);\n  return { source: ts.result, locations: ts.locations };\n}\n\nmodule.exports = codeGenWithLocation;\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}