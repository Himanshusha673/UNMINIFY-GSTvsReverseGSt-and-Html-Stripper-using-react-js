{"ast":null,"code":"/**\n * Copyright 2015 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst MultiMap = require('multimap');\nconst {\n  GlobalScope\n} = require('./scope');\nmodule.exports = class ScopeLookup {\n  constructor(globalScope) {\n    this.scope = globalScope;\n    this.variableMap = new MultiMap();\n    const addVariable = v => {\n      v.declarations.forEach(decl => this.variableMap.set(decl.node, v));\n      v.references.forEach(ref => {\n        if (!this.variableMap.has(ref.node) || this.variableMap.get(ref.node).indexOf(v) === -1) {\n          this.variableMap.set(ref.node, v);\n        }\n      });\n    };\n    (function addVariables(scope) {\n      scope.children.forEach(addVariables);\n      scope.variables.forEach(addVariable);\n    })(globalScope);\n  }\n  lookup(node) {\n    /* Gives a map from BindingIdentifiers and IdentifierExpressions to a list of Variables.\n    Assuming that the given node is defined in the scope, the map always returns at least one Variable.\n    It will return two in precisely three cases:\n    `try{}catch(e){var e = ...}`, function declarations in blocks for which annex B.3.3 applies, and class declarations.\n    In this case the same identifier refers to two variables.\n    Both are returned, with the block-scoped variable being returned first in the first two cases, and the inner variable\n    being returned first in the third case. */\n    return this.variableMap.get(node);\n  }\n  isGlobal(node) {\n    return this.scope instanceof GlobalScope && this.variableMap.has(node);\n  }\n};","map":{"version":3,"names":["MultiMap","require","GlobalScope","module","exports","ScopeLookup","constructor","globalScope","scope","variableMap","addVariable","v","declarations","forEach","decl","set","node","references","ref","has","get","indexOf","addVariables","children","variables","lookup","isGlobal"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/shift-scope/src/scope-lookup.js"],"sourcesContent":["/**\n * Copyright 2015 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst MultiMap = require('multimap');\nconst { GlobalScope } = require('./scope');\n\nmodule.exports = class ScopeLookup {\n  constructor(globalScope) {\n    this.scope = globalScope;\n    this.variableMap = new MultiMap;\n\n    const addVariable = v => {\n      v.declarations.forEach(decl => this.variableMap.set(decl.node, v));\n      v.references.forEach(ref => {\n        if (!this.variableMap.has(ref.node) || this.variableMap.get(ref.node).indexOf(v) === -1) {\n          this.variableMap.set(ref.node, v);\n        }\n      });\n    };\n    (function addVariables(scope) {\n      scope.children.forEach(addVariables);\n      scope.variables.forEach(addVariable);\n    }(globalScope));\n  }\n\n  lookup(node) {\n    /* Gives a map from BindingIdentifiers and IdentifierExpressions to a list of Variables.\n    Assuming that the given node is defined in the scope, the map always returns at least one Variable.\n    It will return two in precisely three cases:\n    `try{}catch(e){var e = ...}`, function declarations in blocks for which annex B.3.3 applies, and class declarations.\n    In this case the same identifier refers to two variables.\n    Both are returned, with the block-scoped variable being returned first in the first two cases, and the inner variable\n    being returned first in the third case. */\n    return this.variableMap.get(node);\n  }\n\n  isGlobal(node) {\n    return this.scope instanceof GlobalScope && this.variableMap.has(node);\n  }\n};\n"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,MAAMA,QAAQ,GAAGC,OAAO,CAAC,UAAU,CAAC;AACpC,MAAM;EAAEC;AAAY,CAAC,GAAGD,OAAO,CAAC,SAAS,CAAC;AAE1CE,MAAM,CAACC,OAAO,GAAG,MAAMC,WAAW,CAAC;EACjCC,WAAWA,CAACC,WAAW,EAAE;IACvB,IAAI,CAACC,KAAK,GAAGD,WAAW;IACxB,IAAI,CAACE,WAAW,GAAG,IAAIT,QAAQ,CAAD,CAAC;IAE/B,MAAMU,WAAW,GAAGC,CAAC,IAAI;MACvBA,CAAC,CAACC,YAAY,CAACC,OAAO,CAACC,IAAI,IAAI,IAAI,CAACL,WAAW,CAACM,GAAG,CAACD,IAAI,CAACE,IAAI,EAAEL,CAAC,CAAC,CAAC;MAClEA,CAAC,CAACM,UAAU,CAACJ,OAAO,CAACK,GAAG,IAAI;QAC1B,IAAI,CAAC,IAAI,CAACT,WAAW,CAACU,GAAG,CAACD,GAAG,CAACF,IAAI,CAAC,IAAI,IAAI,CAACP,WAAW,CAACW,GAAG,CAACF,GAAG,CAACF,IAAI,CAAC,CAACK,OAAO,CAACV,CAAC,CAAC,KAAK,CAAC,CAAC,EAAE;UACvF,IAAI,CAACF,WAAW,CAACM,GAAG,CAACG,GAAG,CAACF,IAAI,EAAEL,CAAC,CAAC;QACnC;MACF,CAAC,CAAC;IACJ,CAAC;IACA,UAASW,YAAYA,CAACd,KAAK,EAAE;MAC5BA,KAAK,CAACe,QAAQ,CAACV,OAAO,CAACS,YAAY,CAAC;MACpCd,KAAK,CAACgB,SAAS,CAACX,OAAO,CAACH,WAAW,CAAC;IACtC,CAAC,EAACH,WAAW,CAAC;EAChB;EAEAkB,MAAMA,CAACT,IAAI,EAAE;IACX;AACJ;AACA;AACA;AACA;AACA;AACA;IACI,OAAO,IAAI,CAACP,WAAW,CAACW,GAAG,CAACJ,IAAI,CAAC;EACnC;EAEAU,QAAQA,CAACV,IAAI,EAAE;IACb,OAAO,IAAI,CAACR,KAAK,YAAYN,WAAW,IAAI,IAAI,CAACO,WAAW,CAACU,GAAG,CAACH,IAAI,CAAC;EACxE;AACF,CAAC","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}