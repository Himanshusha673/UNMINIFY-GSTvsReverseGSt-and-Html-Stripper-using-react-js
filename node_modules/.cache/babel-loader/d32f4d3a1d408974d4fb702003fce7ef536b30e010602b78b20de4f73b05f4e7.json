{"ast":null,"code":"// Generated by scripts/generate-checked.js.\n\n/**\n * Copyright 2016 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction isNotExpression(node) {\n  return typeof node === 'undefined' || node.type !== 'ArrayExpression' && node.type !== 'ArrowExpression' && node.type !== 'AssignmentExpression' && node.type !== 'AwaitExpression' && node.type !== 'BinaryExpression' && node.type !== 'CallExpression' && node.type !== 'ClassExpression' && node.type !== 'CompoundAssignmentExpression' && node.type !== 'ConditionalExpression' && node.type !== 'FunctionExpression' && node.type !== 'IdentifierExpression' && node.type !== 'LiteralBooleanExpression' && node.type !== 'LiteralInfinityExpression' && node.type !== 'LiteralNullExpression' && node.type !== 'LiteralNumericExpression' && node.type !== 'LiteralRegExpExpression' && node.type !== 'LiteralStringExpression' && node.type !== 'ComputedMemberExpression' && node.type !== 'StaticMemberExpression' && node.type !== 'NewExpression' && node.type !== 'NewTargetExpression' && node.type !== 'ObjectExpression' && node.type !== 'TemplateExpression' && node.type !== 'ThisExpression' && node.type !== 'UnaryExpression' && node.type !== 'UpdateExpression' && node.type !== 'YieldExpression' && node.type !== 'YieldGeneratorExpression';\n}\nfunction isNotStatement(node) {\n  return typeof node === 'undefined' || node.type !== 'BlockStatement' && node.type !== 'BreakStatement' && node.type !== 'ClassDeclaration' && node.type !== 'ContinueStatement' && node.type !== 'DebuggerStatement' && node.type !== 'EmptyStatement' && node.type !== 'ExpressionStatement' && node.type !== 'FunctionDeclaration' && node.type !== 'IfStatement' && node.type !== 'DoWhileStatement' && node.type !== 'ForAwaitStatement' && node.type !== 'ForInStatement' && node.type !== 'ForOfStatement' && node.type !== 'ForStatement' && node.type !== 'WhileStatement' && node.type !== 'LabeledStatement' && node.type !== 'ReturnStatement' && node.type !== 'SwitchStatement' && node.type !== 'SwitchStatementWithDefault' && node.type !== 'ThrowStatement' && node.type !== 'TryCatchStatement' && node.type !== 'TryFinallyStatement' && node.type !== 'VariableDeclarationStatement' && node.type !== 'WithStatement';\n}\nfunction printActualType(arg) {\n  if (typeof arg !== 'object') {\n    return typeof arg;\n  }\n  if (Array.isArray(arg)) {\n    return `[${arg.map(printActualType).join(', ')}]`;\n  }\n  if (arg === null) {\n    return null;\n  }\n  if (!arg.type) {\n    return JSON.stringify(arg);\n  }\n  return arg.type;\n}\nfunction arrayEquals(a, b) {\n  return a.length === b.length && a.every((v, i) => v === b[i]);\n}\nexports.ArrayAssignmentTarget = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      elements,\n      rest\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ArrayAssignmentTarget constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'rest'])) {\n      throw new TypeError('Argument to ArrayAssignmentTarget constructor has wrong keys: expected {elements, rest}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f !== null && f.type !== 'AssignmentTargetWithDefault' && f.type !== 'ArrayAssignmentTarget' && f.type !== 'ObjectAssignmentTarget' && f.type !== 'AssignmentTargetIdentifier' && f.type !== 'ComputedMemberAssignmentTarget' && f.type !== 'StaticMemberAssignmentTarget')) {\n      throw new TypeError('Field \"elements\" of ArrayAssignmentTarget constructor argument is of incorrect type (expected [null or one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}], got ' + printActualType(elements) + ')');\n    }\n    if (typeof rest === 'undefined' || rest !== null && rest.type !== 'ArrayAssignmentTarget' && rest.type !== 'ObjectAssignmentTarget' && rest.type !== 'AssignmentTargetIdentifier' && rest.type !== 'ComputedMemberAssignmentTarget' && rest.type !== 'StaticMemberAssignmentTarget') {\n      throw new TypeError('Field \"rest\" of ArrayAssignmentTarget constructor argument is of incorrect type (expected null or one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(rest) + ')');\n    }\n    this.type = 'ArrayAssignmentTarget';\n    this.elements = elements;\n    this.rest = rest;\n  }\n};\nexports.ArrayBinding = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      elements,\n      rest\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ArrayBinding constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'rest'])) {\n      throw new TypeError('Argument to ArrayBinding constructor has wrong keys: expected {elements, rest}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f !== null && f.type !== 'BindingWithDefault' && f.type !== 'BindingIdentifier' && f.type !== 'ArrayBinding' && f.type !== 'ObjectBinding')) {\n      throw new TypeError('Field \"elements\" of ArrayBinding constructor argument is of incorrect type (expected [null or one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}], got ' + printActualType(elements) + ')');\n    }\n    if (typeof rest === 'undefined' || rest !== null && rest.type !== 'BindingIdentifier' && rest.type !== 'ArrayBinding' && rest.type !== 'ObjectBinding') {\n      throw new TypeError('Field \"rest\" of ArrayBinding constructor argument is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(rest) + ')');\n    }\n    this.type = 'ArrayBinding';\n    this.elements = elements;\n    this.rest = rest;\n  }\n};\nexports.ArrayExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      elements\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ArrayExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['elements'])) {\n      throw new TypeError('Argument to ArrayExpression constructor has wrong keys: expected {elements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f !== null && isNotExpression(f) && f.type !== 'SpreadElement')) {\n      throw new TypeError('Field \"elements\" of ArrayExpression constructor argument is of incorrect type (expected [null or one of {Expression, SpreadElement}], got ' + printActualType(elements) + ')');\n    }\n    this.type = 'ArrayExpression';\n    this.elements = elements;\n  }\n};\nexports.ArrowExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      isAsync,\n      params,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ArrowExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'isAsync', 'params'])) {\n      throw new TypeError('Argument to ArrowExpression constructor has wrong keys: expected {isAsync, params, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof isAsync !== 'boolean') {\n      throw new TypeError('Field \"isAsync\" of ArrowExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(isAsync) + ')');\n    }\n    if (typeof params === 'undefined' || params.type !== 'FormalParameters') {\n      throw new TypeError('Field \"params\" of ArrowExpression constructor argument is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');\n    }\n    if (typeof body === 'undefined' || isNotExpression(body) && body.type !== 'FunctionBody') {\n      throw new TypeError('Field \"body\" of ArrowExpression constructor argument is of incorrect type (expected one of {Expression, FunctionBody}, got ' + printActualType(body) + ')');\n    }\n    this.type = 'ArrowExpression';\n    this.isAsync = isAsync;\n    this.params = params;\n    this.body = body;\n  }\n};\nexports.AssignmentExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      binding,\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('AssignmentExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'expression'])) {\n      throw new TypeError('Argument to AssignmentExpression constructor has wrong keys: expected {binding, expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'ArrayAssignmentTarget' && binding.type !== 'ObjectAssignmentTarget' && binding.type !== 'AssignmentTargetIdentifier' && binding.type !== 'ComputedMemberAssignmentTarget' && binding.type !== 'StaticMemberAssignmentTarget') {\n      throw new TypeError('Field \"binding\" of AssignmentExpression constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of AssignmentExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'AssignmentExpression';\n    this.binding = binding;\n    this.expression = expression;\n  }\n};\nexports.AssignmentTargetIdentifier = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('AssignmentTargetIdentifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['name'])) {\n      throw new TypeError('Argument to AssignmentTargetIdentifier constructor has wrong keys: expected {name}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name !== 'string') {\n      throw new TypeError('Field \"name\" of AssignmentTargetIdentifier constructor argument is of incorrect type (expected string, got ' + printActualType(name) + ')');\n    }\n    this.type = 'AssignmentTargetIdentifier';\n    this.name = name;\n  }\n};\nexports.AssignmentTargetPropertyIdentifier = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      binding,\n      init\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('AssignmentTargetPropertyIdentifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {\n      throw new TypeError('Argument to AssignmentTargetPropertyIdentifier constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'AssignmentTargetIdentifier') {\n      throw new TypeError('Field \"binding\" of AssignmentTargetPropertyIdentifier constructor argument is of incorrect type (expected AssignmentTargetIdentifier, got ' + printActualType(binding) + ')');\n    }\n    if (typeof init === 'undefined' || init !== null && isNotExpression(init)) {\n      throw new TypeError('Field \"init\" of AssignmentTargetPropertyIdentifier constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');\n    }\n    this.type = 'AssignmentTargetPropertyIdentifier';\n    this.binding = binding;\n    this.init = init;\n  }\n};\nexports.AssignmentTargetPropertyProperty = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name,\n      binding\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('AssignmentTargetPropertyProperty constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'name'])) {\n      throw new TypeError('Argument to AssignmentTargetPropertyProperty constructor has wrong keys: expected {name, binding}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {\n      throw new TypeError('Field \"name\" of AssignmentTargetPropertyProperty constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'AssignmentTargetWithDefault' && binding.type !== 'ArrayAssignmentTarget' && binding.type !== 'ObjectAssignmentTarget' && binding.type !== 'AssignmentTargetIdentifier' && binding.type !== 'ComputedMemberAssignmentTarget' && binding.type !== 'StaticMemberAssignmentTarget') {\n      throw new TypeError('Field \"binding\" of AssignmentTargetPropertyProperty constructor argument is of incorrect type (expected one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');\n    }\n    this.type = 'AssignmentTargetPropertyProperty';\n    this.name = name;\n    this.binding = binding;\n  }\n};\nexports.AssignmentTargetWithDefault = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      binding,\n      init\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('AssignmentTargetWithDefault constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {\n      throw new TypeError('Argument to AssignmentTargetWithDefault constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'ArrayAssignmentTarget' && binding.type !== 'ObjectAssignmentTarget' && binding.type !== 'AssignmentTargetIdentifier' && binding.type !== 'ComputedMemberAssignmentTarget' && binding.type !== 'StaticMemberAssignmentTarget') {\n      throw new TypeError('Field \"binding\" of AssignmentTargetWithDefault constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');\n    }\n    if (isNotExpression(init)) {\n      throw new TypeError('Field \"init\" of AssignmentTargetWithDefault constructor argument is of incorrect type (expected Expression, got ' + printActualType(init) + ')');\n    }\n    this.type = 'AssignmentTargetWithDefault';\n    this.binding = binding;\n    this.init = init;\n  }\n};\nexports.AwaitExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('AwaitExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to AwaitExpression constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of AwaitExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'AwaitExpression';\n    this.expression = expression;\n  }\n};\nexports.BinaryExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      left,\n      operator,\n      right\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BinaryExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['left', 'operator', 'right'])) {\n      throw new TypeError('Argument to BinaryExpression constructor has wrong keys: expected {left, operator, right}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(left)) {\n      throw new TypeError('Field \"left\" of BinaryExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(left) + ')');\n    }\n    if (typeof operator === 'undefined' || ['==', '!=', '===', '!==', '<', '<=', '>', '>=', 'in', 'instanceof', '<<', '>>', '>>>', '+', '-', '*', '/', '%', '**', ',', '||', '&&', '|', '^', '&'].indexOf(operator) === -1) {\n      throw new TypeError('Field \"operator\" of BinaryExpression constructor argument is of incorrect type (expected one of {\"==\", \"!=\", \"===\", \"!==\", \"<\", \"<=\", \">\", \">=\", \"in\", \"instanceof\", \"<<\", \">>\", \">>>\", \"+\", \"-\", \"*\", \"/\", \"%\", \"**\", \",\", \"||\", \"&&\", \"|\", \"^\", \"&\"}, got ' + printActualType(operator) + ')');\n    }\n    if (isNotExpression(right)) {\n      throw new TypeError('Field \"right\" of BinaryExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(right) + ')');\n    }\n    this.type = 'BinaryExpression';\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n};\nexports.BindingIdentifier = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BindingIdentifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['name'])) {\n      throw new TypeError('Argument to BindingIdentifier constructor has wrong keys: expected {name}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name !== 'string') {\n      throw new TypeError('Field \"name\" of BindingIdentifier constructor argument is of incorrect type (expected string, got ' + printActualType(name) + ')');\n    }\n    this.type = 'BindingIdentifier';\n    this.name = name;\n  }\n};\nexports.BindingPropertyIdentifier = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      binding,\n      init\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BindingPropertyIdentifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {\n      throw new TypeError('Argument to BindingPropertyIdentifier constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"binding\" of BindingPropertyIdentifier constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(binding) + ')');\n    }\n    if (typeof init === 'undefined' || init !== null && isNotExpression(init)) {\n      throw new TypeError('Field \"init\" of BindingPropertyIdentifier constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');\n    }\n    this.type = 'BindingPropertyIdentifier';\n    this.binding = binding;\n    this.init = init;\n  }\n};\nexports.BindingPropertyProperty = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name,\n      binding\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BindingPropertyProperty constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'name'])) {\n      throw new TypeError('Argument to BindingPropertyProperty constructor has wrong keys: expected {name, binding}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {\n      throw new TypeError('Field \"name\" of BindingPropertyProperty constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'BindingWithDefault' && binding.type !== 'BindingIdentifier' && binding.type !== 'ArrayBinding' && binding.type !== 'ObjectBinding') {\n      throw new TypeError('Field \"binding\" of BindingPropertyProperty constructor argument is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');\n    }\n    this.type = 'BindingPropertyProperty';\n    this.name = name;\n    this.binding = binding;\n  }\n};\nexports.BindingWithDefault = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      binding,\n      init\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BindingWithDefault constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {\n      throw new TypeError('Argument to BindingWithDefault constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier' && binding.type !== 'ArrayBinding' && binding.type !== 'ObjectBinding') {\n      throw new TypeError('Field \"binding\" of BindingWithDefault constructor argument is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');\n    }\n    if (isNotExpression(init)) {\n      throw new TypeError('Field \"init\" of BindingWithDefault constructor argument is of incorrect type (expected Expression, got ' + printActualType(init) + ')');\n    }\n    this.type = 'BindingWithDefault';\n    this.binding = binding;\n    this.init = init;\n  }\n};\nexports.Block = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      statements\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Block constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['statements'])) {\n      throw new TypeError('Argument to Block constructor has wrong keys: expected {statements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(statements) || statements.some(f => isNotStatement(f))) {\n      throw new TypeError('Field \"statements\" of Block constructor argument is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');\n    }\n    this.type = 'Block';\n    this.statements = statements;\n  }\n};\nexports.BlockStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      block\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BlockStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['block'])) {\n      throw new TypeError('Argument to BlockStatement constructor has wrong keys: expected {block}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof block === 'undefined' || block.type !== 'Block') {\n      throw new TypeError('Field \"block\" of BlockStatement constructor argument is of incorrect type (expected Block, got ' + printActualType(block) + ')');\n    }\n    this.type = 'BlockStatement';\n    this.block = block;\n  }\n};\nexports.BreakStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      label\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BreakStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['label'])) {\n      throw new TypeError('Argument to BreakStatement constructor has wrong keys: expected {label}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof label === 'undefined' || label !== null && typeof label !== 'string') {\n      throw new TypeError('Field \"label\" of BreakStatement constructor argument is of incorrect type (expected null or string, got ' + printActualType(label) + ')');\n    }\n    this.type = 'BreakStatement';\n    this.label = label;\n  }\n};\nexports.CallExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      callee,\n      arguments: _arguments\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('CallExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['arguments', 'callee'])) {\n      throw new TypeError('Argument to CallExpression constructor has wrong keys: expected {callee, arguments}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof callee === 'undefined' || isNotExpression(callee) && callee.type !== 'Super') {\n      throw new TypeError('Field \"callee\" of CallExpression constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(callee) + ')');\n    }\n    if (!Array.isArray(_arguments) || _arguments.some(f => typeof f === 'undefined' || isNotExpression(f) && f.type !== 'SpreadElement')) {\n      throw new TypeError('Field \"arguments\" of CallExpression constructor argument is of incorrect type (expected [one of {Expression, SpreadElement}], got ' + printActualType(_arguments) + ')');\n    }\n    this.type = 'CallExpression';\n    this.callee = callee;\n    this.arguments = _arguments;\n  }\n};\nexports.CatchClause = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      binding,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('CatchClause constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'body'])) {\n      throw new TypeError('Argument to CatchClause constructor has wrong keys: expected {binding, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || binding !== null && binding.type !== 'BindingIdentifier' && binding.type !== 'ArrayBinding' && binding.type !== 'ObjectBinding') {\n      throw new TypeError('Field \"binding\" of CatchClause constructor argument is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');\n    }\n    if (typeof body === 'undefined' || body.type !== 'Block') {\n      throw new TypeError('Field \"body\" of CatchClause constructor argument is of incorrect type (expected Block, got ' + printActualType(body) + ')');\n    }\n    this.type = 'CatchClause';\n    this.binding = binding;\n    this.body = body;\n  }\n};\nexports.ClassDeclaration = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name,\n      super: _super,\n      elements\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ClassDeclaration constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'name', 'super'])) {\n      throw new TypeError('Argument to ClassDeclaration constructor has wrong keys: expected {name, super, elements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"name\" of ClassDeclaration constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(name) + ')');\n    }\n    if (typeof _super === 'undefined' || _super !== null && isNotExpression(_super)) {\n      throw new TypeError('Field \"super\" of ClassDeclaration constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(_super) + ')');\n    }\n    if (!Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f.type !== 'ClassElement')) {\n      throw new TypeError('Field \"elements\" of ClassDeclaration constructor argument is of incorrect type (expected [ClassElement], got ' + printActualType(elements) + ')');\n    }\n    this.type = 'ClassDeclaration';\n    this.name = name;\n    this.super = _super;\n    this.elements = elements;\n  }\n};\nexports.ClassElement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      isStatic,\n      method\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ClassElement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['isStatic', 'method'])) {\n      throw new TypeError('Argument to ClassElement constructor has wrong keys: expected {isStatic, method}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof isStatic !== 'boolean') {\n      throw new TypeError('Field \"isStatic\" of ClassElement constructor argument is of incorrect type (expected boolean, got ' + printActualType(isStatic) + ')');\n    }\n    if (typeof method === 'undefined' || method.type !== 'Getter' && method.type !== 'Method' && method.type !== 'Setter') {\n      throw new TypeError('Field \"method\" of ClassElement constructor argument is of incorrect type (expected one of {Getter, Method, Setter}, got ' + printActualType(method) + ')');\n    }\n    this.type = 'ClassElement';\n    this.isStatic = isStatic;\n    this.method = method;\n  }\n};\nexports.ClassExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name,\n      super: _super,\n      elements\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ClassExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'name', 'super'])) {\n      throw new TypeError('Argument to ClassExpression constructor has wrong keys: expected {name, super, elements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name !== null && name.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"name\" of ClassExpression constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(name) + ')');\n    }\n    if (typeof _super === 'undefined' || _super !== null && isNotExpression(_super)) {\n      throw new TypeError('Field \"super\" of ClassExpression constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(_super) + ')');\n    }\n    if (!Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f.type !== 'ClassElement')) {\n      throw new TypeError('Field \"elements\" of ClassExpression constructor argument is of incorrect type (expected [ClassElement], got ' + printActualType(elements) + ')');\n    }\n    this.type = 'ClassExpression';\n    this.name = name;\n    this.super = _super;\n    this.elements = elements;\n  }\n};\nexports.CompoundAssignmentExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      binding,\n      operator,\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('CompoundAssignmentExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'expression', 'operator'])) {\n      throw new TypeError('Argument to CompoundAssignmentExpression constructor has wrong keys: expected {binding, operator, expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'AssignmentTargetIdentifier' && binding.type !== 'ComputedMemberAssignmentTarget' && binding.type !== 'StaticMemberAssignmentTarget') {\n      throw new TypeError('Field \"binding\" of CompoundAssignmentExpression constructor argument is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');\n    }\n    if (typeof operator === 'undefined' || ['+=', '-=', '*=', '/=', '%=', '**=', '<<=', '>>=', '>>>=', '|=', '^=', '&='].indexOf(operator) === -1) {\n      throw new TypeError('Field \"operator\" of CompoundAssignmentExpression constructor argument is of incorrect type (expected one of {\"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"**=\", \"<<=\", \">>=\", \">>>=\", \"|=\", \"^=\", \"&=\"}, got ' + printActualType(operator) + ')');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of CompoundAssignmentExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'CompoundAssignmentExpression';\n    this.binding = binding;\n    this.operator = operator;\n    this.expression = expression;\n  }\n};\nexports.ComputedMemberAssignmentTarget = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      object,\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ComputedMemberAssignmentTarget constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression', 'object'])) {\n      throw new TypeError('Argument to ComputedMemberAssignmentTarget constructor has wrong keys: expected {object, expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof object === 'undefined' || isNotExpression(object) && object.type !== 'Super') {\n      throw new TypeError('Field \"object\" of ComputedMemberAssignmentTarget constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of ComputedMemberAssignmentTarget constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'ComputedMemberAssignmentTarget';\n    this.object = object;\n    this.expression = expression;\n  }\n};\nexports.ComputedMemberExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      object,\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ComputedMemberExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression', 'object'])) {\n      throw new TypeError('Argument to ComputedMemberExpression constructor has wrong keys: expected {object, expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof object === 'undefined' || isNotExpression(object) && object.type !== 'Super') {\n      throw new TypeError('Field \"object\" of ComputedMemberExpression constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of ComputedMemberExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'ComputedMemberExpression';\n    this.object = object;\n    this.expression = expression;\n  }\n};\nexports.ComputedPropertyName = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ComputedPropertyName constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to ComputedPropertyName constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of ComputedPropertyName constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'ComputedPropertyName';\n    this.expression = expression;\n  }\n};\nexports.ConditionalExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      test,\n      consequent,\n      alternate\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ConditionalExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['alternate', 'consequent', 'test'])) {\n      throw new TypeError('Argument to ConditionalExpression constructor has wrong keys: expected {test, consequent, alternate}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(test)) {\n      throw new TypeError('Field \"test\" of ConditionalExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');\n    }\n    if (isNotExpression(consequent)) {\n      throw new TypeError('Field \"consequent\" of ConditionalExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(consequent) + ')');\n    }\n    if (isNotExpression(alternate)) {\n      throw new TypeError('Field \"alternate\" of ConditionalExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(alternate) + ')');\n    }\n    this.type = 'ConditionalExpression';\n    this.test = test;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n};\nexports.ContinueStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      label\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ContinueStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['label'])) {\n      throw new TypeError('Argument to ContinueStatement constructor has wrong keys: expected {label}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof label === 'undefined' || label !== null && typeof label !== 'string') {\n      throw new TypeError('Field \"label\" of ContinueStatement constructor argument is of incorrect type (expected null or string, got ' + printActualType(label) + ')');\n    }\n    this.type = 'ContinueStatement';\n    this.label = label;\n  }\n};\nexports.DataProperty = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name,\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('DataProperty constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression', 'name'])) {\n      throw new TypeError('Argument to DataProperty constructor has wrong keys: expected {name, expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {\n      throw new TypeError('Field \"name\" of DataProperty constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of DataProperty constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'DataProperty';\n    this.name = name;\n    this.expression = expression;\n  }\n};\nexports.DebuggerStatement = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('DebuggerStatement constructor takes no arguments');\n    }\n    this.type = 'DebuggerStatement';\n  }\n};\nexports.Directive = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      rawValue\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Directive constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['rawValue'])) {\n      throw new TypeError('Argument to Directive constructor has wrong keys: expected {rawValue}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof rawValue !== 'string') {\n      throw new TypeError('Field \"rawValue\" of Directive constructor argument is of incorrect type (expected string, got ' + printActualType(rawValue) + ')');\n    }\n    this.type = 'Directive';\n    this.rawValue = rawValue;\n  }\n};\nexports.DoWhileStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      body,\n      test\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('DoWhileStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'test'])) {\n      throw new TypeError('Argument to DoWhileStatement constructor has wrong keys: expected {body, test}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of DoWhileStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    if (isNotExpression(test)) {\n      throw new TypeError('Field \"test\" of DoWhileStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');\n    }\n    this.type = 'DoWhileStatement';\n    this.body = body;\n    this.test = test;\n  }\n};\nexports.EmptyStatement = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('EmptyStatement constructor takes no arguments');\n    }\n    this.type = 'EmptyStatement';\n  }\n};\nexports.Export = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      declaration\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Export constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['declaration'])) {\n      throw new TypeError('Argument to Export constructor has wrong keys: expected {declaration}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof declaration === 'undefined' || declaration.type !== 'ClassDeclaration' && declaration.type !== 'FunctionDeclaration' && declaration.type !== 'VariableDeclaration') {\n      throw new TypeError('Field \"declaration\" of Export constructor argument is of incorrect type (expected one of {ClassDeclaration, FunctionDeclaration, VariableDeclaration}, got ' + printActualType(declaration) + ')');\n    }\n    this.type = 'Export';\n    this.declaration = declaration;\n  }\n};\nexports.ExportAllFrom = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      moduleSpecifier\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExportAllFrom constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['moduleSpecifier'])) {\n      throw new TypeError('Argument to ExportAllFrom constructor has wrong keys: expected {moduleSpecifier}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof moduleSpecifier !== 'string') {\n      throw new TypeError('Field \"moduleSpecifier\" of ExportAllFrom constructor argument is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');\n    }\n    this.type = 'ExportAllFrom';\n    this.moduleSpecifier = moduleSpecifier;\n  }\n};\nexports.ExportDefault = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExportDefault constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body'])) {\n      throw new TypeError('Argument to ExportDefault constructor has wrong keys: expected {body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof body === 'undefined' || body.type !== 'ClassDeclaration' && isNotExpression(body) && body.type !== 'FunctionDeclaration') {\n      throw new TypeError('Field \"body\" of ExportDefault constructor argument is of incorrect type (expected one of {ClassDeclaration, Expression, FunctionDeclaration}, got ' + printActualType(body) + ')');\n    }\n    this.type = 'ExportDefault';\n    this.body = body;\n  }\n};\nexports.ExportFrom = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      namedExports,\n      moduleSpecifier\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExportFrom constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['moduleSpecifier', 'namedExports'])) {\n      throw new TypeError('Argument to ExportFrom constructor has wrong keys: expected {namedExports, moduleSpecifier}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(namedExports) || namedExports.some(f => typeof f === 'undefined' || f.type !== 'ExportFromSpecifier')) {\n      throw new TypeError('Field \"namedExports\" of ExportFrom constructor argument is of incorrect type (expected [ExportFromSpecifier], got ' + printActualType(namedExports) + ')');\n    }\n    if (typeof moduleSpecifier !== 'string') {\n      throw new TypeError('Field \"moduleSpecifier\" of ExportFrom constructor argument is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');\n    }\n    this.type = 'ExportFrom';\n    this.namedExports = namedExports;\n    this.moduleSpecifier = moduleSpecifier;\n  }\n};\nexports.ExportFromSpecifier = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name,\n      exportedName\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExportFromSpecifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['exportedName', 'name'])) {\n      throw new TypeError('Argument to ExportFromSpecifier constructor has wrong keys: expected {name, exportedName}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name !== 'string') {\n      throw new TypeError('Field \"name\" of ExportFromSpecifier constructor argument is of incorrect type (expected string, got ' + printActualType(name) + ')');\n    }\n    if (typeof exportedName === 'undefined' || exportedName !== null && typeof exportedName !== 'string') {\n      throw new TypeError('Field \"exportedName\" of ExportFromSpecifier constructor argument is of incorrect type (expected null or string, got ' + printActualType(exportedName) + ')');\n    }\n    this.type = 'ExportFromSpecifier';\n    this.name = name;\n    this.exportedName = exportedName;\n  }\n};\nexports.ExportLocalSpecifier = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name,\n      exportedName\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExportLocalSpecifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['exportedName', 'name'])) {\n      throw new TypeError('Argument to ExportLocalSpecifier constructor has wrong keys: expected {name, exportedName}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name.type !== 'IdentifierExpression') {\n      throw new TypeError('Field \"name\" of ExportLocalSpecifier constructor argument is of incorrect type (expected IdentifierExpression, got ' + printActualType(name) + ')');\n    }\n    if (typeof exportedName === 'undefined' || exportedName !== null && typeof exportedName !== 'string') {\n      throw new TypeError('Field \"exportedName\" of ExportLocalSpecifier constructor argument is of incorrect type (expected null or string, got ' + printActualType(exportedName) + ')');\n    }\n    this.type = 'ExportLocalSpecifier';\n    this.name = name;\n    this.exportedName = exportedName;\n  }\n};\nexports.ExportLocals = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      namedExports\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExportLocals constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['namedExports'])) {\n      throw new TypeError('Argument to ExportLocals constructor has wrong keys: expected {namedExports}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(namedExports) || namedExports.some(f => typeof f === 'undefined' || f.type !== 'ExportLocalSpecifier')) {\n      throw new TypeError('Field \"namedExports\" of ExportLocals constructor argument is of incorrect type (expected [ExportLocalSpecifier], got ' + printActualType(namedExports) + ')');\n    }\n    this.type = 'ExportLocals';\n    this.namedExports = namedExports;\n  }\n};\nexports.ExpressionStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExpressionStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to ExpressionStatement constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of ExpressionStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'ExpressionStatement';\n    this.expression = expression;\n  }\n};\nexports.ForAwaitStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      left,\n      right,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ForAwaitStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'left', 'right'])) {\n      throw new TypeError('Argument to ForAwaitStatement constructor has wrong keys: expected {left, right, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof left === 'undefined' || left.type !== 'ArrayAssignmentTarget' && left.type !== 'ObjectAssignmentTarget' && left.type !== 'AssignmentTargetIdentifier' && left.type !== 'ComputedMemberAssignmentTarget' && left.type !== 'StaticMemberAssignmentTarget' && left.type !== 'VariableDeclaration') {\n      throw new TypeError('Field \"left\" of ForAwaitStatement constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');\n    }\n    if (isNotExpression(right)) {\n      throw new TypeError('Field \"right\" of ForAwaitStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(right) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of ForAwaitStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'ForAwaitStatement';\n    this.left = left;\n    this.right = right;\n    this.body = body;\n  }\n};\nexports.ForInStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      left,\n      right,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ForInStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'left', 'right'])) {\n      throw new TypeError('Argument to ForInStatement constructor has wrong keys: expected {left, right, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof left === 'undefined' || left.type !== 'ArrayAssignmentTarget' && left.type !== 'ObjectAssignmentTarget' && left.type !== 'AssignmentTargetIdentifier' && left.type !== 'ComputedMemberAssignmentTarget' && left.type !== 'StaticMemberAssignmentTarget' && left.type !== 'VariableDeclaration') {\n      throw new TypeError('Field \"left\" of ForInStatement constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');\n    }\n    if (isNotExpression(right)) {\n      throw new TypeError('Field \"right\" of ForInStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(right) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of ForInStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'ForInStatement';\n    this.left = left;\n    this.right = right;\n    this.body = body;\n  }\n};\nexports.ForOfStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      left,\n      right,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ForOfStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'left', 'right'])) {\n      throw new TypeError('Argument to ForOfStatement constructor has wrong keys: expected {left, right, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof left === 'undefined' || left.type !== 'ArrayAssignmentTarget' && left.type !== 'ObjectAssignmentTarget' && left.type !== 'AssignmentTargetIdentifier' && left.type !== 'ComputedMemberAssignmentTarget' && left.type !== 'StaticMemberAssignmentTarget' && left.type !== 'VariableDeclaration') {\n      throw new TypeError('Field \"left\" of ForOfStatement constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');\n    }\n    if (isNotExpression(right)) {\n      throw new TypeError('Field \"right\" of ForOfStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(right) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of ForOfStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'ForOfStatement';\n    this.left = left;\n    this.right = right;\n    this.body = body;\n  }\n};\nexports.ForStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      init,\n      test,\n      update,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ForStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'init', 'test', 'update'])) {\n      throw new TypeError('Argument to ForStatement constructor has wrong keys: expected {init, test, update, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof init === 'undefined' || init !== null && isNotExpression(init) && init.type !== 'VariableDeclaration') {\n      throw new TypeError('Field \"init\" of ForStatement constructor argument is of incorrect type (expected null or one of {Expression, VariableDeclaration}, got ' + printActualType(init) + ')');\n    }\n    if (typeof test === 'undefined' || test !== null && isNotExpression(test)) {\n      throw new TypeError('Field \"test\" of ForStatement constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(test) + ')');\n    }\n    if (typeof update === 'undefined' || update !== null && isNotExpression(update)) {\n      throw new TypeError('Field \"update\" of ForStatement constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(update) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of ForStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'ForStatement';\n    this.init = init;\n    this.test = test;\n    this.update = update;\n    this.body = body;\n  }\n};\nexports.FormalParameters = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      items,\n      rest\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('FormalParameters constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['items', 'rest'])) {\n      throw new TypeError('Argument to FormalParameters constructor has wrong keys: expected {items, rest}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(items) || items.some(f => typeof f === 'undefined' || f.type !== 'BindingWithDefault' && f.type !== 'BindingIdentifier' && f.type !== 'ArrayBinding' && f.type !== 'ObjectBinding')) {\n      throw new TypeError('Field \"items\" of FormalParameters constructor argument is of incorrect type (expected [one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}], got ' + printActualType(items) + ')');\n    }\n    if (typeof rest === 'undefined' || rest !== null && rest.type !== 'BindingIdentifier' && rest.type !== 'ArrayBinding' && rest.type !== 'ObjectBinding') {\n      throw new TypeError('Field \"rest\" of FormalParameters constructor argument is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(rest) + ')');\n    }\n    this.type = 'FormalParameters';\n    this.items = items;\n    this.rest = rest;\n  }\n};\nexports.FunctionBody = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      directives,\n      statements\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('FunctionBody constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['directives', 'statements'])) {\n      throw new TypeError('Argument to FunctionBody constructor has wrong keys: expected {directives, statements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(directives) || directives.some(f => typeof f === 'undefined' || f.type !== 'Directive')) {\n      throw new TypeError('Field \"directives\" of FunctionBody constructor argument is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');\n    }\n    if (!Array.isArray(statements) || statements.some(f => isNotStatement(f))) {\n      throw new TypeError('Field \"statements\" of FunctionBody constructor argument is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');\n    }\n    this.type = 'FunctionBody';\n    this.directives = directives;\n    this.statements = statements;\n  }\n};\nexports.FunctionDeclaration = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      isAsync,\n      isGenerator,\n      name,\n      params,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('FunctionDeclaration constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'isAsync', 'isGenerator', 'name', 'params'])) {\n      throw new TypeError('Argument to FunctionDeclaration constructor has wrong keys: expected {isAsync, isGenerator, name, params, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof isAsync !== 'boolean') {\n      throw new TypeError('Field \"isAsync\" of FunctionDeclaration constructor argument is of incorrect type (expected boolean, got ' + printActualType(isAsync) + ')');\n    }\n    if (typeof isGenerator !== 'boolean') {\n      throw new TypeError('Field \"isGenerator\" of FunctionDeclaration constructor argument is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');\n    }\n    if (typeof name === 'undefined' || name.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"name\" of FunctionDeclaration constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(name) + ')');\n    }\n    if (typeof params === 'undefined' || params.type !== 'FormalParameters') {\n      throw new TypeError('Field \"params\" of FunctionDeclaration constructor argument is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');\n    }\n    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {\n      throw new TypeError('Field \"body\" of FunctionDeclaration constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');\n    }\n    this.type = 'FunctionDeclaration';\n    this.isAsync = isAsync;\n    this.isGenerator = isGenerator;\n    this.name = name;\n    this.params = params;\n    this.body = body;\n  }\n};\nexports.FunctionExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      isAsync,\n      isGenerator,\n      name,\n      params,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('FunctionExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'isAsync', 'isGenerator', 'name', 'params'])) {\n      throw new TypeError('Argument to FunctionExpression constructor has wrong keys: expected {isAsync, isGenerator, name, params, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof isAsync !== 'boolean') {\n      throw new TypeError('Field \"isAsync\" of FunctionExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(isAsync) + ')');\n    }\n    if (typeof isGenerator !== 'boolean') {\n      throw new TypeError('Field \"isGenerator\" of FunctionExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');\n    }\n    if (typeof name === 'undefined' || name !== null && name.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"name\" of FunctionExpression constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(name) + ')');\n    }\n    if (typeof params === 'undefined' || params.type !== 'FormalParameters') {\n      throw new TypeError('Field \"params\" of FunctionExpression constructor argument is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');\n    }\n    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {\n      throw new TypeError('Field \"body\" of FunctionExpression constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');\n    }\n    this.type = 'FunctionExpression';\n    this.isAsync = isAsync;\n    this.isGenerator = isGenerator;\n    this.name = name;\n    this.params = params;\n    this.body = body;\n  }\n};\nexports.Getter = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Getter constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'name'])) {\n      throw new TypeError('Argument to Getter constructor has wrong keys: expected {name, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {\n      throw new TypeError('Field \"name\" of Getter constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');\n    }\n    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {\n      throw new TypeError('Field \"body\" of Getter constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');\n    }\n    this.type = 'Getter';\n    this.name = name;\n    this.body = body;\n  }\n};\nexports.IdentifierExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('IdentifierExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['name'])) {\n      throw new TypeError('Argument to IdentifierExpression constructor has wrong keys: expected {name}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name !== 'string') {\n      throw new TypeError('Field \"name\" of IdentifierExpression constructor argument is of incorrect type (expected string, got ' + printActualType(name) + ')');\n    }\n    this.type = 'IdentifierExpression';\n    this.name = name;\n  }\n};\nexports.IfStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      test,\n      consequent,\n      alternate\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('IfStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['alternate', 'consequent', 'test'])) {\n      throw new TypeError('Argument to IfStatement constructor has wrong keys: expected {test, consequent, alternate}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(test)) {\n      throw new TypeError('Field \"test\" of IfStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');\n    }\n    if (isNotStatement(consequent)) {\n      throw new TypeError('Field \"consequent\" of IfStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(consequent) + ')');\n    }\n    if (typeof alternate === 'undefined' || alternate !== null && isNotStatement(alternate)) {\n      throw new TypeError('Field \"alternate\" of IfStatement constructor argument is of incorrect type (expected null or Statement, got ' + printActualType(alternate) + ')');\n    }\n    this.type = 'IfStatement';\n    this.test = test;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n};\nexports.Import = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      defaultBinding,\n      namedImports,\n      moduleSpecifier\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Import constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['defaultBinding', 'moduleSpecifier', 'namedImports'])) {\n      throw new TypeError('Argument to Import constructor has wrong keys: expected {defaultBinding, namedImports, moduleSpecifier}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof defaultBinding === 'undefined' || defaultBinding !== null && defaultBinding.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"defaultBinding\" of Import constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(defaultBinding) + ')');\n    }\n    if (!Array.isArray(namedImports) || namedImports.some(f => typeof f === 'undefined' || f.type !== 'ImportSpecifier')) {\n      throw new TypeError('Field \"namedImports\" of Import constructor argument is of incorrect type (expected [ImportSpecifier], got ' + printActualType(namedImports) + ')');\n    }\n    if (typeof moduleSpecifier !== 'string') {\n      throw new TypeError('Field \"moduleSpecifier\" of Import constructor argument is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');\n    }\n    this.type = 'Import';\n    this.defaultBinding = defaultBinding;\n    this.namedImports = namedImports;\n    this.moduleSpecifier = moduleSpecifier;\n  }\n};\nexports.ImportNamespace = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      defaultBinding,\n      namespaceBinding,\n      moduleSpecifier\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ImportNamespace constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['defaultBinding', 'moduleSpecifier', 'namespaceBinding'])) {\n      throw new TypeError('Argument to ImportNamespace constructor has wrong keys: expected {defaultBinding, namespaceBinding, moduleSpecifier}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof defaultBinding === 'undefined' || defaultBinding !== null && defaultBinding.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"defaultBinding\" of ImportNamespace constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(defaultBinding) + ')');\n    }\n    if (typeof namespaceBinding === 'undefined' || namespaceBinding.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"namespaceBinding\" of ImportNamespace constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(namespaceBinding) + ')');\n    }\n    if (typeof moduleSpecifier !== 'string') {\n      throw new TypeError('Field \"moduleSpecifier\" of ImportNamespace constructor argument is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');\n    }\n    this.type = 'ImportNamespace';\n    this.defaultBinding = defaultBinding;\n    this.namespaceBinding = namespaceBinding;\n    this.moduleSpecifier = moduleSpecifier;\n  }\n};\nexports.ImportSpecifier = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name,\n      binding\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ImportSpecifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'name'])) {\n      throw new TypeError('Argument to ImportSpecifier constructor has wrong keys: expected {name, binding}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name !== null && typeof name !== 'string') {\n      throw new TypeError('Field \"name\" of ImportSpecifier constructor argument is of incorrect type (expected null or string, got ' + printActualType(name) + ')');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"binding\" of ImportSpecifier constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(binding) + ')');\n    }\n    this.type = 'ImportSpecifier';\n    this.name = name;\n    this.binding = binding;\n  }\n};\nexports.LabeledStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      label,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('LabeledStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'label'])) {\n      throw new TypeError('Argument to LabeledStatement constructor has wrong keys: expected {label, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof label !== 'string') {\n      throw new TypeError('Field \"label\" of LabeledStatement constructor argument is of incorrect type (expected string, got ' + printActualType(label) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of LabeledStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'LabeledStatement';\n    this.label = label;\n    this.body = body;\n  }\n};\nexports.LiteralBooleanExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      value\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('LiteralBooleanExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['value'])) {\n      throw new TypeError('Argument to LiteralBooleanExpression constructor has wrong keys: expected {value}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof value !== 'boolean') {\n      throw new TypeError('Field \"value\" of LiteralBooleanExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(value) + ')');\n    }\n    this.type = 'LiteralBooleanExpression';\n    this.value = value;\n  }\n};\nexports.LiteralInfinityExpression = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('LiteralInfinityExpression constructor takes no arguments');\n    }\n    this.type = 'LiteralInfinityExpression';\n  }\n};\nexports.LiteralNullExpression = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('LiteralNullExpression constructor takes no arguments');\n    }\n    this.type = 'LiteralNullExpression';\n  }\n};\nexports.LiteralNumericExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      value\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('LiteralNumericExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['value'])) {\n      throw new TypeError('Argument to LiteralNumericExpression constructor has wrong keys: expected {value}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof value !== 'number') {\n      throw new TypeError('Field \"value\" of LiteralNumericExpression constructor argument is of incorrect type (expected number, got ' + printActualType(value) + ')');\n    }\n    this.type = 'LiteralNumericExpression';\n    this.value = value;\n  }\n};\nexports.LiteralRegExpExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      pattern,\n      global,\n      ignoreCase,\n      multiLine,\n      dotAll,\n      unicode,\n      sticky\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('LiteralRegExpExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['dotAll', 'global', 'ignoreCase', 'multiLine', 'pattern', 'sticky', 'unicode'])) {\n      throw new TypeError('Argument to LiteralRegExpExpression constructor has wrong keys: expected {pattern, global, ignoreCase, multiLine, dotAll, unicode, sticky}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof pattern !== 'string') {\n      throw new TypeError('Field \"pattern\" of LiteralRegExpExpression constructor argument is of incorrect type (expected string, got ' + printActualType(pattern) + ')');\n    }\n    if (typeof global !== 'boolean') {\n      throw new TypeError('Field \"global\" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(global) + ')');\n    }\n    if (typeof ignoreCase !== 'boolean') {\n      throw new TypeError('Field \"ignoreCase\" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(ignoreCase) + ')');\n    }\n    if (typeof multiLine !== 'boolean') {\n      throw new TypeError('Field \"multiLine\" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(multiLine) + ')');\n    }\n    if (typeof dotAll !== 'boolean') {\n      throw new TypeError('Field \"dotAll\" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(dotAll) + ')');\n    }\n    if (typeof unicode !== 'boolean') {\n      throw new TypeError('Field \"unicode\" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(unicode) + ')');\n    }\n    if (typeof sticky !== 'boolean') {\n      throw new TypeError('Field \"sticky\" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(sticky) + ')');\n    }\n    this.type = 'LiteralRegExpExpression';\n    this.pattern = pattern;\n    this.global = global;\n    this.ignoreCase = ignoreCase;\n    this.multiLine = multiLine;\n    this.dotAll = dotAll;\n    this.unicode = unicode;\n    this.sticky = sticky;\n  }\n};\nexports.LiteralStringExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      value\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('LiteralStringExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['value'])) {\n      throw new TypeError('Argument to LiteralStringExpression constructor has wrong keys: expected {value}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof value !== 'string') {\n      throw new TypeError('Field \"value\" of LiteralStringExpression constructor argument is of incorrect type (expected string, got ' + printActualType(value) + ')');\n    }\n    this.type = 'LiteralStringExpression';\n    this.value = value;\n  }\n};\nexports.Method = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      isAsync,\n      isGenerator,\n      name,\n      params,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Method constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'isAsync', 'isGenerator', 'name', 'params'])) {\n      throw new TypeError('Argument to Method constructor has wrong keys: expected {isAsync, isGenerator, name, params, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof isAsync !== 'boolean') {\n      throw new TypeError('Field \"isAsync\" of Method constructor argument is of incorrect type (expected boolean, got ' + printActualType(isAsync) + ')');\n    }\n    if (typeof isGenerator !== 'boolean') {\n      throw new TypeError('Field \"isGenerator\" of Method constructor argument is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');\n    }\n    if (typeof name === 'undefined' || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {\n      throw new TypeError('Field \"name\" of Method constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');\n    }\n    if (typeof params === 'undefined' || params.type !== 'FormalParameters') {\n      throw new TypeError('Field \"params\" of Method constructor argument is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');\n    }\n    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {\n      throw new TypeError('Field \"body\" of Method constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');\n    }\n    this.type = 'Method';\n    this.isAsync = isAsync;\n    this.isGenerator = isGenerator;\n    this.name = name;\n    this.params = params;\n    this.body = body;\n  }\n};\nexports.Module = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      directives,\n      items\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Module constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['directives', 'items'])) {\n      throw new TypeError('Argument to Module constructor has wrong keys: expected {directives, items}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(directives) || directives.some(f => typeof f === 'undefined' || f.type !== 'Directive')) {\n      throw new TypeError('Field \"directives\" of Module constructor argument is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');\n    }\n    if (!Array.isArray(items) || items.some(f => typeof f === 'undefined' || f.type !== 'Export' && f.type !== 'ExportAllFrom' && f.type !== 'ExportDefault' && f.type !== 'ExportFrom' && f.type !== 'ExportLocals' && f.type !== 'Import' && f.type !== 'ImportNamespace' && isNotStatement(f))) {\n      throw new TypeError('Field \"items\" of Module constructor argument is of incorrect type (expected [one of {Export, ExportAllFrom, ExportDefault, ExportFrom, ExportLocals, Import, ImportNamespace, Statement}], got ' + printActualType(items) + ')');\n    }\n    this.type = 'Module';\n    this.directives = directives;\n    this.items = items;\n  }\n};\nexports.NewExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      callee,\n      arguments: _arguments\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('NewExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['arguments', 'callee'])) {\n      throw new TypeError('Argument to NewExpression constructor has wrong keys: expected {callee, arguments}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(callee)) {\n      throw new TypeError('Field \"callee\" of NewExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(callee) + ')');\n    }\n    if (!Array.isArray(_arguments) || _arguments.some(f => typeof f === 'undefined' || isNotExpression(f) && f.type !== 'SpreadElement')) {\n      throw new TypeError('Field \"arguments\" of NewExpression constructor argument is of incorrect type (expected [one of {Expression, SpreadElement}], got ' + printActualType(_arguments) + ')');\n    }\n    this.type = 'NewExpression';\n    this.callee = callee;\n    this.arguments = _arguments;\n  }\n};\nexports.NewTargetExpression = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('NewTargetExpression constructor takes no arguments');\n    }\n    this.type = 'NewTargetExpression';\n  }\n};\nexports.ObjectAssignmentTarget = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      properties,\n      rest\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ObjectAssignmentTarget constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['properties', 'rest'])) {\n      throw new TypeError('Argument to ObjectAssignmentTarget constructor has wrong keys: expected {properties, rest}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(properties) || properties.some(f => typeof f === 'undefined' || f.type !== 'AssignmentTargetPropertyIdentifier' && f.type !== 'AssignmentTargetPropertyProperty')) {\n      throw new TypeError('Field \"properties\" of ObjectAssignmentTarget constructor argument is of incorrect type (expected [one of {AssignmentTargetPropertyIdentifier, AssignmentTargetPropertyProperty}], got ' + printActualType(properties) + ')');\n    }\n    if (typeof rest === 'undefined' || rest !== null && rest.type !== 'AssignmentTargetIdentifier' && rest.type !== 'ComputedMemberAssignmentTarget' && rest.type !== 'StaticMemberAssignmentTarget') {\n      throw new TypeError('Field \"rest\" of ObjectAssignmentTarget constructor argument is of incorrect type (expected null or one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(rest) + ')');\n    }\n    this.type = 'ObjectAssignmentTarget';\n    this.properties = properties;\n    this.rest = rest;\n  }\n};\nexports.ObjectBinding = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      properties,\n      rest\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ObjectBinding constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['properties', 'rest'])) {\n      throw new TypeError('Argument to ObjectBinding constructor has wrong keys: expected {properties, rest}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(properties) || properties.some(f => typeof f === 'undefined' || f.type !== 'BindingPropertyIdentifier' && f.type !== 'BindingPropertyProperty')) {\n      throw new TypeError('Field \"properties\" of ObjectBinding constructor argument is of incorrect type (expected [one of {BindingPropertyIdentifier, BindingPropertyProperty}], got ' + printActualType(properties) + ')');\n    }\n    if (typeof rest === 'undefined' || rest !== null && rest.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"rest\" of ObjectBinding constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(rest) + ')');\n    }\n    this.type = 'ObjectBinding';\n    this.properties = properties;\n    this.rest = rest;\n  }\n};\nexports.ObjectExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      properties\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ObjectExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['properties'])) {\n      throw new TypeError('Argument to ObjectExpression constructor has wrong keys: expected {properties}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(properties) || properties.some(f => typeof f === 'undefined' || f.type !== 'DataProperty' && f.type !== 'Getter' && f.type !== 'Method' && f.type !== 'Setter' && f.type !== 'ShorthandProperty' && f.type !== 'SpreadProperty')) {\n      throw new TypeError('Field \"properties\" of ObjectExpression constructor argument is of incorrect type (expected [one of {DataProperty, Getter, Method, Setter, ShorthandProperty, SpreadProperty}], got ' + printActualType(properties) + ')');\n    }\n    this.type = 'ObjectExpression';\n    this.properties = properties;\n  }\n};\nexports.ReturnStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ReturnStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to ReturnStatement constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof expression === 'undefined' || expression !== null && isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of ReturnStatement constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'ReturnStatement';\n    this.expression = expression;\n  }\n};\nexports.Script = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      directives,\n      statements\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Script constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['directives', 'statements'])) {\n      throw new TypeError('Argument to Script constructor has wrong keys: expected {directives, statements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(directives) || directives.some(f => typeof f === 'undefined' || f.type !== 'Directive')) {\n      throw new TypeError('Field \"directives\" of Script constructor argument is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');\n    }\n    if (!Array.isArray(statements) || statements.some(f => isNotStatement(f))) {\n      throw new TypeError('Field \"statements\" of Script constructor argument is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');\n    }\n    this.type = 'Script';\n    this.directives = directives;\n    this.statements = statements;\n  }\n};\nexports.Setter = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name,\n      param,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Setter constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'name', 'param'])) {\n      throw new TypeError('Argument to Setter constructor has wrong keys: expected {name, param, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name.type !== 'ComputedPropertyName' && name.type !== 'StaticPropertyName') {\n      throw new TypeError('Field \"name\" of Setter constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');\n    }\n    if (typeof param === 'undefined' || param.type !== 'BindingWithDefault' && param.type !== 'BindingIdentifier' && param.type !== 'ArrayBinding' && param.type !== 'ObjectBinding') {\n      throw new TypeError('Field \"param\" of Setter constructor argument is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(param) + ')');\n    }\n    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {\n      throw new TypeError('Field \"body\" of Setter constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');\n    }\n    this.type = 'Setter';\n    this.name = name;\n    this.param = param;\n    this.body = body;\n  }\n};\nexports.ShorthandProperty = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      name\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ShorthandProperty constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['name'])) {\n      throw new TypeError('Argument to ShorthandProperty constructor has wrong keys: expected {name}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name.type !== 'IdentifierExpression') {\n      throw new TypeError('Field \"name\" of ShorthandProperty constructor argument is of incorrect type (expected IdentifierExpression, got ' + printActualType(name) + ')');\n    }\n    this.type = 'ShorthandProperty';\n    this.name = name;\n  }\n};\nexports.SpreadElement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('SpreadElement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to SpreadElement constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of SpreadElement constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'SpreadElement';\n    this.expression = expression;\n  }\n};\nexports.SpreadProperty = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('SpreadProperty constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to SpreadProperty constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of SpreadProperty constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'SpreadProperty';\n    this.expression = expression;\n  }\n};\nexports.StaticMemberAssignmentTarget = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      object,\n      property\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('StaticMemberAssignmentTarget constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['object', 'property'])) {\n      throw new TypeError('Argument to StaticMemberAssignmentTarget constructor has wrong keys: expected {object, property}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof object === 'undefined' || isNotExpression(object) && object.type !== 'Super') {\n      throw new TypeError('Field \"object\" of StaticMemberAssignmentTarget constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');\n    }\n    if (typeof property !== 'string') {\n      throw new TypeError('Field \"property\" of StaticMemberAssignmentTarget constructor argument is of incorrect type (expected string, got ' + printActualType(property) + ')');\n    }\n    this.type = 'StaticMemberAssignmentTarget';\n    this.object = object;\n    this.property = property;\n  }\n};\nexports.StaticMemberExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      object,\n      property\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('StaticMemberExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['object', 'property'])) {\n      throw new TypeError('Argument to StaticMemberExpression constructor has wrong keys: expected {object, property}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof object === 'undefined' || isNotExpression(object) && object.type !== 'Super') {\n      throw new TypeError('Field \"object\" of StaticMemberExpression constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');\n    }\n    if (typeof property !== 'string') {\n      throw new TypeError('Field \"property\" of StaticMemberExpression constructor argument is of incorrect type (expected string, got ' + printActualType(property) + ')');\n    }\n    this.type = 'StaticMemberExpression';\n    this.object = object;\n    this.property = property;\n  }\n};\nexports.StaticPropertyName = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      value\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('StaticPropertyName constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['value'])) {\n      throw new TypeError('Argument to StaticPropertyName constructor has wrong keys: expected {value}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof value !== 'string') {\n      throw new TypeError('Field \"value\" of StaticPropertyName constructor argument is of incorrect type (expected string, got ' + printActualType(value) + ')');\n    }\n    this.type = 'StaticPropertyName';\n    this.value = value;\n  }\n};\nexports.Super = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('Super constructor takes no arguments');\n    }\n    this.type = 'Super';\n  }\n};\nexports.SwitchCase = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      test,\n      consequent\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('SwitchCase constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['consequent', 'test'])) {\n      throw new TypeError('Argument to SwitchCase constructor has wrong keys: expected {test, consequent}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(test)) {\n      throw new TypeError('Field \"test\" of SwitchCase constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');\n    }\n    if (!Array.isArray(consequent) || consequent.some(f => isNotStatement(f))) {\n      throw new TypeError('Field \"consequent\" of SwitchCase constructor argument is of incorrect type (expected [Statement], got ' + printActualType(consequent) + ')');\n    }\n    this.type = 'SwitchCase';\n    this.test = test;\n    this.consequent = consequent;\n  }\n};\nexports.SwitchDefault = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      consequent\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('SwitchDefault constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['consequent'])) {\n      throw new TypeError('Argument to SwitchDefault constructor has wrong keys: expected {consequent}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(consequent) || consequent.some(f => isNotStatement(f))) {\n      throw new TypeError('Field \"consequent\" of SwitchDefault constructor argument is of incorrect type (expected [Statement], got ' + printActualType(consequent) + ')');\n    }\n    this.type = 'SwitchDefault';\n    this.consequent = consequent;\n  }\n};\nexports.SwitchStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      discriminant,\n      cases\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('SwitchStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['cases', 'discriminant'])) {\n      throw new TypeError('Argument to SwitchStatement constructor has wrong keys: expected {discriminant, cases}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(discriminant)) {\n      throw new TypeError('Field \"discriminant\" of SwitchStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(discriminant) + ')');\n    }\n    if (!Array.isArray(cases) || cases.some(f => typeof f === 'undefined' || f.type !== 'SwitchCase')) {\n      throw new TypeError('Field \"cases\" of SwitchStatement constructor argument is of incorrect type (expected [SwitchCase], got ' + printActualType(cases) + ')');\n    }\n    this.type = 'SwitchStatement';\n    this.discriminant = discriminant;\n    this.cases = cases;\n  }\n};\nexports.SwitchStatementWithDefault = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      discriminant,\n      preDefaultCases,\n      defaultCase,\n      postDefaultCases\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('SwitchStatementWithDefault constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['defaultCase', 'discriminant', 'postDefaultCases', 'preDefaultCases'])) {\n      throw new TypeError('Argument to SwitchStatementWithDefault constructor has wrong keys: expected {discriminant, preDefaultCases, defaultCase, postDefaultCases}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(discriminant)) {\n      throw new TypeError('Field \"discriminant\" of SwitchStatementWithDefault constructor argument is of incorrect type (expected Expression, got ' + printActualType(discriminant) + ')');\n    }\n    if (!Array.isArray(preDefaultCases) || preDefaultCases.some(f => typeof f === 'undefined' || f.type !== 'SwitchCase')) {\n      throw new TypeError('Field \"preDefaultCases\" of SwitchStatementWithDefault constructor argument is of incorrect type (expected [SwitchCase], got ' + printActualType(preDefaultCases) + ')');\n    }\n    if (typeof defaultCase === 'undefined' || defaultCase.type !== 'SwitchDefault') {\n      throw new TypeError('Field \"defaultCase\" of SwitchStatementWithDefault constructor argument is of incorrect type (expected SwitchDefault, got ' + printActualType(defaultCase) + ')');\n    }\n    if (!Array.isArray(postDefaultCases) || postDefaultCases.some(f => typeof f === 'undefined' || f.type !== 'SwitchCase')) {\n      throw new TypeError('Field \"postDefaultCases\" of SwitchStatementWithDefault constructor argument is of incorrect type (expected [SwitchCase], got ' + printActualType(postDefaultCases) + ')');\n    }\n    this.type = 'SwitchStatementWithDefault';\n    this.discriminant = discriminant;\n    this.preDefaultCases = preDefaultCases;\n    this.defaultCase = defaultCase;\n    this.postDefaultCases = postDefaultCases;\n  }\n};\nexports.TemplateElement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      rawValue\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('TemplateElement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['rawValue'])) {\n      throw new TypeError('Argument to TemplateElement constructor has wrong keys: expected {rawValue}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof rawValue !== 'string') {\n      throw new TypeError('Field \"rawValue\" of TemplateElement constructor argument is of incorrect type (expected string, got ' + printActualType(rawValue) + ')');\n    }\n    this.type = 'TemplateElement';\n    this.rawValue = rawValue;\n  }\n};\nexports.TemplateExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      tag,\n      elements\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('TemplateExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'tag'])) {\n      throw new TypeError('Argument to TemplateExpression constructor has wrong keys: expected {tag, elements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof tag === 'undefined' || tag !== null && isNotExpression(tag)) {\n      throw new TypeError('Field \"tag\" of TemplateExpression constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(tag) + ')');\n    }\n    if (!Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || isNotExpression(f) && f.type !== 'TemplateElement')) {\n      throw new TypeError('Field \"elements\" of TemplateExpression constructor argument is of incorrect type (expected [one of {Expression, TemplateElement}], got ' + printActualType(elements) + ')');\n    }\n    this.type = 'TemplateExpression';\n    this.tag = tag;\n    this.elements = elements;\n  }\n};\nexports.ThisExpression = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('ThisExpression constructor takes no arguments');\n    }\n    this.type = 'ThisExpression';\n  }\n};\nexports.ThrowStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ThrowStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to ThrowStatement constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of ThrowStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'ThrowStatement';\n    this.expression = expression;\n  }\n};\nexports.TryCatchStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      body,\n      catchClause\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('TryCatchStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'catchClause'])) {\n      throw new TypeError('Argument to TryCatchStatement constructor has wrong keys: expected {body, catchClause}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof body === 'undefined' || body.type !== 'Block') {\n      throw new TypeError('Field \"body\" of TryCatchStatement constructor argument is of incorrect type (expected Block, got ' + printActualType(body) + ')');\n    }\n    if (typeof catchClause === 'undefined' || catchClause.type !== 'CatchClause') {\n      throw new TypeError('Field \"catchClause\" of TryCatchStatement constructor argument is of incorrect type (expected CatchClause, got ' + printActualType(catchClause) + ')');\n    }\n    this.type = 'TryCatchStatement';\n    this.body = body;\n    this.catchClause = catchClause;\n  }\n};\nexports.TryFinallyStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      body,\n      catchClause,\n      finalizer\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('TryFinallyStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'catchClause', 'finalizer'])) {\n      throw new TypeError('Argument to TryFinallyStatement constructor has wrong keys: expected {body, catchClause, finalizer}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof body === 'undefined' || body.type !== 'Block') {\n      throw new TypeError('Field \"body\" of TryFinallyStatement constructor argument is of incorrect type (expected Block, got ' + printActualType(body) + ')');\n    }\n    if (typeof catchClause === 'undefined' || catchClause !== null && catchClause.type !== 'CatchClause') {\n      throw new TypeError('Field \"catchClause\" of TryFinallyStatement constructor argument is of incorrect type (expected null or CatchClause, got ' + printActualType(catchClause) + ')');\n    }\n    if (typeof finalizer === 'undefined' || finalizer.type !== 'Block') {\n      throw new TypeError('Field \"finalizer\" of TryFinallyStatement constructor argument is of incorrect type (expected Block, got ' + printActualType(finalizer) + ')');\n    }\n    this.type = 'TryFinallyStatement';\n    this.body = body;\n    this.catchClause = catchClause;\n    this.finalizer = finalizer;\n  }\n};\nexports.UnaryExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      operator,\n      operand\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('UnaryExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['operand', 'operator'])) {\n      throw new TypeError('Argument to UnaryExpression constructor has wrong keys: expected {operator, operand}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof operator === 'undefined' || ['+', '-', '!', '~', 'typeof', 'void', 'delete'].indexOf(operator) === -1) {\n      throw new TypeError('Field \"operator\" of UnaryExpression constructor argument is of incorrect type (expected one of {\"+\", \"-\", \"!\", \"~\", \"typeof\", \"void\", \"delete\"}, got ' + printActualType(operator) + ')');\n    }\n    if (isNotExpression(operand)) {\n      throw new TypeError('Field \"operand\" of UnaryExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(operand) + ')');\n    }\n    this.type = 'UnaryExpression';\n    this.operator = operator;\n    this.operand = operand;\n  }\n};\nexports.UpdateExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      isPrefix,\n      operator,\n      operand\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('UpdateExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['isPrefix', 'operand', 'operator'])) {\n      throw new TypeError('Argument to UpdateExpression constructor has wrong keys: expected {isPrefix, operator, operand}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof isPrefix !== 'boolean') {\n      throw new TypeError('Field \"isPrefix\" of UpdateExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(isPrefix) + ')');\n    }\n    if (typeof operator === 'undefined' || ['++', '--'].indexOf(operator) === -1) {\n      throw new TypeError('Field \"operator\" of UpdateExpression constructor argument is of incorrect type (expected one of {\"++\", \"--\"}, got ' + printActualType(operator) + ')');\n    }\n    if (typeof operand === 'undefined' || operand.type !== 'AssignmentTargetIdentifier' && operand.type !== 'ComputedMemberAssignmentTarget' && operand.type !== 'StaticMemberAssignmentTarget') {\n      throw new TypeError('Field \"operand\" of UpdateExpression constructor argument is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(operand) + ')');\n    }\n    this.type = 'UpdateExpression';\n    this.isPrefix = isPrefix;\n    this.operator = operator;\n    this.operand = operand;\n  }\n};\nexports.VariableDeclaration = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      kind,\n      declarators\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('VariableDeclaration constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['declarators', 'kind'])) {\n      throw new TypeError('Argument to VariableDeclaration constructor has wrong keys: expected {kind, declarators}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof kind === 'undefined' || ['var', 'let', 'const'].indexOf(kind) === -1) {\n      throw new TypeError('Field \"kind\" of VariableDeclaration constructor argument is of incorrect type (expected one of {\"var\", \"let\", \"const\"}, got ' + printActualType(kind) + ')');\n    }\n    if (!Array.isArray(declarators) || declarators.some(f => typeof f === 'undefined' || f.type !== 'VariableDeclarator')) {\n      throw new TypeError('Field \"declarators\" of VariableDeclaration constructor argument is of incorrect type (expected [VariableDeclarator], got ' + printActualType(declarators) + ')');\n    }\n    this.type = 'VariableDeclaration';\n    this.kind = kind;\n    this.declarators = declarators;\n  }\n};\nexports.VariableDeclarationStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      declaration\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('VariableDeclarationStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['declaration'])) {\n      throw new TypeError('Argument to VariableDeclarationStatement constructor has wrong keys: expected {declaration}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof declaration === 'undefined' || declaration.type !== 'VariableDeclaration') {\n      throw new TypeError('Field \"declaration\" of VariableDeclarationStatement constructor argument is of incorrect type (expected VariableDeclaration, got ' + printActualType(declaration) + ')');\n    }\n    this.type = 'VariableDeclarationStatement';\n    this.declaration = declaration;\n  }\n};\nexports.VariableDeclarator = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      binding,\n      init\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('VariableDeclarator constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {\n      throw new TypeError('Argument to VariableDeclarator constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier' && binding.type !== 'ArrayBinding' && binding.type !== 'ObjectBinding') {\n      throw new TypeError('Field \"binding\" of VariableDeclarator constructor argument is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');\n    }\n    if (typeof init === 'undefined' || init !== null && isNotExpression(init)) {\n      throw new TypeError('Field \"init\" of VariableDeclarator constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');\n    }\n    this.type = 'VariableDeclarator';\n    this.binding = binding;\n    this.init = init;\n  }\n};\nexports.WhileStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      test,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('WhileStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'test'])) {\n      throw new TypeError('Argument to WhileStatement constructor has wrong keys: expected {test, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(test)) {\n      throw new TypeError('Field \"test\" of WhileStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of WhileStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'WhileStatement';\n    this.test = test;\n    this.body = body;\n  }\n};\nexports.WithStatement = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      object,\n      body\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('WithStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'object'])) {\n      throw new TypeError('Argument to WithStatement constructor has wrong keys: expected {object, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(object)) {\n      throw new TypeError('Field \"object\" of WithStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(object) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of WithStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'WithStatement';\n    this.object = object;\n    this.body = body;\n  }\n};\nexports.YieldExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('YieldExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to YieldExpression constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof expression === 'undefined' || expression !== null && isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of YieldExpression constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'YieldExpression';\n    this.expression = expression;\n  }\n};\nexports.YieldGeneratorExpression = class {\n  constructor(arg, ...extraArgs) {\n    const {\n      expression\n    } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('YieldGeneratorExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to YieldGeneratorExpression constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of YieldGeneratorExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'YieldGeneratorExpression';\n    this.expression = expression;\n  }\n};","map":{"version":3,"names":["isNotExpression","node","type","isNotStatement","printActualType","arg","Array","isArray","map","join","JSON","stringify","arrayEquals","a","b","length","every","v","i","exports","ArrayAssignmentTarget","constructor","extraArgs","elements","rest","TypeError","Object","keys","sort","some","f","ArrayBinding","ArrayExpression","ArrowExpression","isAsync","params","body","AssignmentExpression","binding","expression","AssignmentTargetIdentifier","name","AssignmentTargetPropertyIdentifier","init","AssignmentTargetPropertyProperty","AssignmentTargetWithDefault","AwaitExpression","BinaryExpression","left","operator","right","indexOf","BindingIdentifier","BindingPropertyIdentifier","BindingPropertyProperty","BindingWithDefault","Block","statements","BlockStatement","block","BreakStatement","label","CallExpression","callee","arguments","_arguments","CatchClause","ClassDeclaration","super","_super","ClassElement","isStatic","method","ClassExpression","CompoundAssignmentExpression","ComputedMemberAssignmentTarget","object","ComputedMemberExpression","ComputedPropertyName","ConditionalExpression","test","consequent","alternate","ContinueStatement","DataProperty","DebuggerStatement","Directive","rawValue","DoWhileStatement","EmptyStatement","Export","declaration","ExportAllFrom","moduleSpecifier","ExportDefault","ExportFrom","namedExports","ExportFromSpecifier","exportedName","ExportLocalSpecifier","ExportLocals","ExpressionStatement","ForAwaitStatement","ForInStatement","ForOfStatement","ForStatement","update","FormalParameters","items","FunctionBody","directives","FunctionDeclaration","isGenerator","FunctionExpression","Getter","IdentifierExpression","IfStatement","Import","defaultBinding","namedImports","ImportNamespace","namespaceBinding","ImportSpecifier","LabeledStatement","LiteralBooleanExpression","value","LiteralInfinityExpression","LiteralNullExpression","LiteralNumericExpression","LiteralRegExpExpression","pattern","global","ignoreCase","multiLine","dotAll","unicode","sticky","LiteralStringExpression","Method","Module","NewExpression","NewTargetExpression","ObjectAssignmentTarget","properties","ObjectBinding","ObjectExpression","ReturnStatement","Script","Setter","param","ShorthandProperty","SpreadElement","SpreadProperty","StaticMemberAssignmentTarget","property","StaticMemberExpression","StaticPropertyName","Super","SwitchCase","SwitchDefault","SwitchStatement","discriminant","cases","SwitchStatementWithDefault","preDefaultCases","defaultCase","postDefaultCases","TemplateElement","TemplateExpression","tag","ThisExpression","ThrowStatement","TryCatchStatement","catchClause","TryFinallyStatement","finalizer","UnaryExpression","operand","UpdateExpression","isPrefix","VariableDeclaration","kind","declarators","VariableDeclarationStatement","VariableDeclarator","WhileStatement","WithStatement","YieldExpression","YieldGeneratorExpression"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/shift-ast/gen/checked.js"],"sourcesContent":["// Generated by scripts/generate-checked.js.\n\n/**\n * Copyright 2016 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nfunction isNotExpression(node) {\n  return typeof node === 'undefined' || (node.type !== 'ArrayExpression') && (node.type !== 'ArrowExpression') && (node.type !== 'AssignmentExpression') && (node.type !== 'AwaitExpression') && (node.type !== 'BinaryExpression') && (node.type !== 'CallExpression') && (node.type !== 'ClassExpression') && (node.type !== 'CompoundAssignmentExpression') && (node.type !== 'ConditionalExpression') && (node.type !== 'FunctionExpression') && (node.type !== 'IdentifierExpression') && (node.type !== 'LiteralBooleanExpression') && (node.type !== 'LiteralInfinityExpression') && (node.type !== 'LiteralNullExpression') && (node.type !== 'LiteralNumericExpression') && (node.type !== 'LiteralRegExpExpression') && (node.type !== 'LiteralStringExpression') && ((node.type !== 'ComputedMemberExpression') && (node.type !== 'StaticMemberExpression')) && (node.type !== 'NewExpression') && (node.type !== 'NewTargetExpression') && (node.type !== 'ObjectExpression') && (node.type !== 'TemplateExpression') && (node.type !== 'ThisExpression') && (node.type !== 'UnaryExpression') && (node.type !== 'UpdateExpression') && (node.type !== 'YieldExpression') && (node.type !== 'YieldGeneratorExpression');\n}\n\nfunction isNotStatement(node) {\n  return typeof node === 'undefined' || (node.type !== 'BlockStatement') && (node.type !== 'BreakStatement') && (node.type !== 'ClassDeclaration') && (node.type !== 'ContinueStatement') && (node.type !== 'DebuggerStatement') && (node.type !== 'EmptyStatement') && (node.type !== 'ExpressionStatement') && (node.type !== 'FunctionDeclaration') && (node.type !== 'IfStatement') && ((node.type !== 'DoWhileStatement') && (node.type !== 'ForAwaitStatement') && (node.type !== 'ForInStatement') && (node.type !== 'ForOfStatement') && (node.type !== 'ForStatement') && (node.type !== 'WhileStatement')) && (node.type !== 'LabeledStatement') && (node.type !== 'ReturnStatement') && (node.type !== 'SwitchStatement') && (node.type !== 'SwitchStatementWithDefault') && (node.type !== 'ThrowStatement') && (node.type !== 'TryCatchStatement') && (node.type !== 'TryFinallyStatement') && (node.type !== 'VariableDeclarationStatement') && (node.type !== 'WithStatement');\n}\n\nfunction printActualType(arg) {\n  if (typeof arg !== 'object') {\n    return typeof arg;\n  }\n  if (Array.isArray(arg)) {\n    return `[${arg.map(printActualType).join(', ')}]`;\n  }\n  if (arg === null) {\n    return null;\n  }\n  if (!arg.type) {\n    return JSON.stringify(arg);\n  }\n  return arg.type;\n}\n\nfunction arrayEquals(a, b) {\n  return a.length === b.length && a.every((v, i) => v === b[i]);\n}\n\nexports.ArrayAssignmentTarget = class {\n  constructor(arg, ...extraArgs) {\n    const { elements, rest } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ArrayAssignmentTarget constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'rest'])) {\n      throw new TypeError('Argument to ArrayAssignmentTarget constructor has wrong keys: expected {elements, rest}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f !== null && ((f.type !== 'AssignmentTargetWithDefault') && (((f.type !== 'ArrayAssignmentTarget') && (f.type !== 'ObjectAssignmentTarget')) && ((f.type !== 'AssignmentTargetIdentifier') && ((f.type !== 'ComputedMemberAssignmentTarget') && (f.type !== 'StaticMemberAssignmentTarget'))))))) {\n      throw new TypeError('Field \"elements\" of ArrayAssignmentTarget constructor argument is of incorrect type (expected [null or one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}], got ' + printActualType(elements) + ')');\n    }\n    if (typeof rest === 'undefined' || rest !== null && (((rest.type !== 'ArrayAssignmentTarget') && (rest.type !== 'ObjectAssignmentTarget')) && ((rest.type !== 'AssignmentTargetIdentifier') && ((rest.type !== 'ComputedMemberAssignmentTarget') && (rest.type !== 'StaticMemberAssignmentTarget'))))) {\n      throw new TypeError('Field \"rest\" of ArrayAssignmentTarget constructor argument is of incorrect type (expected null or one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(rest) + ')');\n    }\n    this.type = 'ArrayAssignmentTarget';\n    this.elements = elements;\n    this.rest = rest;\n  }\n};\n\nexports.ArrayBinding = class {\n  constructor(arg, ...extraArgs) {\n    const { elements, rest } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ArrayBinding constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'rest'])) {\n      throw new TypeError('Argument to ArrayBinding constructor has wrong keys: expected {elements, rest}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f !== null && ((f.type !== 'BindingWithDefault') && ((f.type !== 'BindingIdentifier') && ((f.type !== 'ArrayBinding') && (f.type !== 'ObjectBinding')))))) {\n      throw new TypeError('Field \"elements\" of ArrayBinding constructor argument is of incorrect type (expected [null or one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}], got ' + printActualType(elements) + ')');\n    }\n    if (typeof rest === 'undefined' || rest !== null && ((rest.type !== 'BindingIdentifier') && ((rest.type !== 'ArrayBinding') && (rest.type !== 'ObjectBinding')))) {\n      throw new TypeError('Field \"rest\" of ArrayBinding constructor argument is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(rest) + ')');\n    }\n    this.type = 'ArrayBinding';\n    this.elements = elements;\n    this.rest = rest;\n  }\n};\n\nexports.ArrayExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { elements } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ArrayExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['elements'])) {\n      throw new TypeError('Argument to ArrayExpression constructor has wrong keys: expected {elements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f !== null && ((isNotExpression(f)) && (f.type !== 'SpreadElement')))) {\n      throw new TypeError('Field \"elements\" of ArrayExpression constructor argument is of incorrect type (expected [null or one of {Expression, SpreadElement}], got ' + printActualType(elements) + ')');\n    }\n    this.type = 'ArrayExpression';\n    this.elements = elements;\n  }\n};\n\nexports.ArrowExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { isAsync, params, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ArrowExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'isAsync', 'params'])) {\n      throw new TypeError('Argument to ArrowExpression constructor has wrong keys: expected {isAsync, params, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof isAsync !== 'boolean') {\n      throw new TypeError('Field \"isAsync\" of ArrowExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(isAsync) + ')');\n    }\n    if (typeof params === 'undefined' || params.type !== 'FormalParameters') {\n      throw new TypeError('Field \"params\" of ArrowExpression constructor argument is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');\n    }\n    if (typeof body === 'undefined' || (isNotExpression(body)) && (body.type !== 'FunctionBody')) {\n      throw new TypeError('Field \"body\" of ArrowExpression constructor argument is of incorrect type (expected one of {Expression, FunctionBody}, got ' + printActualType(body) + ')');\n    }\n    this.type = 'ArrowExpression';\n    this.isAsync = isAsync;\n    this.params = params;\n    this.body = body;\n  }\n};\n\nexports.AssignmentExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { binding, expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('AssignmentExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'expression'])) {\n      throw new TypeError('Argument to AssignmentExpression constructor has wrong keys: expected {binding, expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || ((binding.type !== 'ArrayAssignmentTarget') && (binding.type !== 'ObjectAssignmentTarget')) && ((binding.type !== 'AssignmentTargetIdentifier') && ((binding.type !== 'ComputedMemberAssignmentTarget') && (binding.type !== 'StaticMemberAssignmentTarget')))) {\n      throw new TypeError('Field \"binding\" of AssignmentExpression constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of AssignmentExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'AssignmentExpression';\n    this.binding = binding;\n    this.expression = expression;\n  }\n};\n\nexports.AssignmentTargetIdentifier = class {\n  constructor(arg, ...extraArgs) {\n    const { name } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('AssignmentTargetIdentifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['name'])) {\n      throw new TypeError('Argument to AssignmentTargetIdentifier constructor has wrong keys: expected {name}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name !== 'string') {\n      throw new TypeError('Field \"name\" of AssignmentTargetIdentifier constructor argument is of incorrect type (expected string, got ' + printActualType(name) + ')');\n    }\n    this.type = 'AssignmentTargetIdentifier';\n    this.name = name;\n  }\n};\n\nexports.AssignmentTargetPropertyIdentifier = class {\n  constructor(arg, ...extraArgs) {\n    const { binding, init } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('AssignmentTargetPropertyIdentifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {\n      throw new TypeError('Argument to AssignmentTargetPropertyIdentifier constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'AssignmentTargetIdentifier') {\n      throw new TypeError('Field \"binding\" of AssignmentTargetPropertyIdentifier constructor argument is of incorrect type (expected AssignmentTargetIdentifier, got ' + printActualType(binding) + ')');\n    }\n    if (typeof init === 'undefined' || init !== null && (isNotExpression(init))) {\n      throw new TypeError('Field \"init\" of AssignmentTargetPropertyIdentifier constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');\n    }\n    this.type = 'AssignmentTargetPropertyIdentifier';\n    this.binding = binding;\n    this.init = init;\n  }\n};\n\nexports.AssignmentTargetPropertyProperty = class {\n  constructor(arg, ...extraArgs) {\n    const { name, binding } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('AssignmentTargetPropertyProperty constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'name'])) {\n      throw new TypeError('Argument to AssignmentTargetPropertyProperty constructor has wrong keys: expected {name, binding}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {\n      throw new TypeError('Field \"name\" of AssignmentTargetPropertyProperty constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');\n    }\n    if (typeof binding === 'undefined' || (binding.type !== 'AssignmentTargetWithDefault') && (((binding.type !== 'ArrayAssignmentTarget') && (binding.type !== 'ObjectAssignmentTarget')) && ((binding.type !== 'AssignmentTargetIdentifier') && ((binding.type !== 'ComputedMemberAssignmentTarget') && (binding.type !== 'StaticMemberAssignmentTarget'))))) {\n      throw new TypeError('Field \"binding\" of AssignmentTargetPropertyProperty constructor argument is of incorrect type (expected one of {AssignmentTargetWithDefault, ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');\n    }\n    this.type = 'AssignmentTargetPropertyProperty';\n    this.name = name;\n    this.binding = binding;\n  }\n};\n\nexports.AssignmentTargetWithDefault = class {\n  constructor(arg, ...extraArgs) {\n    const { binding, init } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('AssignmentTargetWithDefault constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {\n      throw new TypeError('Argument to AssignmentTargetWithDefault constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || ((binding.type !== 'ArrayAssignmentTarget') && (binding.type !== 'ObjectAssignmentTarget')) && ((binding.type !== 'AssignmentTargetIdentifier') && ((binding.type !== 'ComputedMemberAssignmentTarget') && (binding.type !== 'StaticMemberAssignmentTarget')))) {\n      throw new TypeError('Field \"binding\" of AssignmentTargetWithDefault constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');\n    }\n    if (isNotExpression(init)) {\n      throw new TypeError('Field \"init\" of AssignmentTargetWithDefault constructor argument is of incorrect type (expected Expression, got ' + printActualType(init) + ')');\n    }\n    this.type = 'AssignmentTargetWithDefault';\n    this.binding = binding;\n    this.init = init;\n  }\n};\n\nexports.AwaitExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('AwaitExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to AwaitExpression constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of AwaitExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'AwaitExpression';\n    this.expression = expression;\n  }\n};\n\nexports.BinaryExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { left, operator, right } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BinaryExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['left', 'operator', 'right'])) {\n      throw new TypeError('Argument to BinaryExpression constructor has wrong keys: expected {left, operator, right}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(left)) {\n      throw new TypeError('Field \"left\" of BinaryExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(left) + ')');\n    }\n    if (typeof operator === 'undefined' || ['==', '!=', '===', '!==', '<', '<=', '>', '>=', 'in', 'instanceof', '<<', '>>', '>>>', '+', '-', '*', '/', '%', '**', ',', '||', '&&', '|', '^', '&'].indexOf(operator) === -1) {\n      throw new TypeError('Field \"operator\" of BinaryExpression constructor argument is of incorrect type (expected one of {\"==\", \"!=\", \"===\", \"!==\", \"<\", \"<=\", \">\", \">=\", \"in\", \"instanceof\", \"<<\", \">>\", \">>>\", \"+\", \"-\", \"*\", \"/\", \"%\", \"**\", \",\", \"||\", \"&&\", \"|\", \"^\", \"&\"}, got ' + printActualType(operator) + ')');\n    }\n    if (isNotExpression(right)) {\n      throw new TypeError('Field \"right\" of BinaryExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(right) + ')');\n    }\n    this.type = 'BinaryExpression';\n    this.left = left;\n    this.operator = operator;\n    this.right = right;\n  }\n};\n\nexports.BindingIdentifier = class {\n  constructor(arg, ...extraArgs) {\n    const { name } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BindingIdentifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['name'])) {\n      throw new TypeError('Argument to BindingIdentifier constructor has wrong keys: expected {name}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name !== 'string') {\n      throw new TypeError('Field \"name\" of BindingIdentifier constructor argument is of incorrect type (expected string, got ' + printActualType(name) + ')');\n    }\n    this.type = 'BindingIdentifier';\n    this.name = name;\n  }\n};\n\nexports.BindingPropertyIdentifier = class {\n  constructor(arg, ...extraArgs) {\n    const { binding, init } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BindingPropertyIdentifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {\n      throw new TypeError('Argument to BindingPropertyIdentifier constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"binding\" of BindingPropertyIdentifier constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(binding) + ')');\n    }\n    if (typeof init === 'undefined' || init !== null && (isNotExpression(init))) {\n      throw new TypeError('Field \"init\" of BindingPropertyIdentifier constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');\n    }\n    this.type = 'BindingPropertyIdentifier';\n    this.binding = binding;\n    this.init = init;\n  }\n};\n\nexports.BindingPropertyProperty = class {\n  constructor(arg, ...extraArgs) {\n    const { name, binding } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BindingPropertyProperty constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'name'])) {\n      throw new TypeError('Argument to BindingPropertyProperty constructor has wrong keys: expected {name, binding}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {\n      throw new TypeError('Field \"name\" of BindingPropertyProperty constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');\n    }\n    if (typeof binding === 'undefined' || (binding.type !== 'BindingWithDefault') && ((binding.type !== 'BindingIdentifier') && ((binding.type !== 'ArrayBinding') && (binding.type !== 'ObjectBinding')))) {\n      throw new TypeError('Field \"binding\" of BindingPropertyProperty constructor argument is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');\n    }\n    this.type = 'BindingPropertyProperty';\n    this.name = name;\n    this.binding = binding;\n  }\n};\n\nexports.BindingWithDefault = class {\n  constructor(arg, ...extraArgs) {\n    const { binding, init } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BindingWithDefault constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {\n      throw new TypeError('Argument to BindingWithDefault constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || (binding.type !== 'BindingIdentifier') && ((binding.type !== 'ArrayBinding') && (binding.type !== 'ObjectBinding'))) {\n      throw new TypeError('Field \"binding\" of BindingWithDefault constructor argument is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');\n    }\n    if (isNotExpression(init)) {\n      throw new TypeError('Field \"init\" of BindingWithDefault constructor argument is of incorrect type (expected Expression, got ' + printActualType(init) + ')');\n    }\n    this.type = 'BindingWithDefault';\n    this.binding = binding;\n    this.init = init;\n  }\n};\n\nexports.Block = class {\n  constructor(arg, ...extraArgs) {\n    const { statements } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Block constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['statements'])) {\n      throw new TypeError('Argument to Block constructor has wrong keys: expected {statements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(statements) || statements.some(f => isNotStatement(f))) {\n      throw new TypeError('Field \"statements\" of Block constructor argument is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');\n    }\n    this.type = 'Block';\n    this.statements = statements;\n  }\n};\n\nexports.BlockStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { block } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BlockStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['block'])) {\n      throw new TypeError('Argument to BlockStatement constructor has wrong keys: expected {block}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof block === 'undefined' || block.type !== 'Block') {\n      throw new TypeError('Field \"block\" of BlockStatement constructor argument is of incorrect type (expected Block, got ' + printActualType(block) + ')');\n    }\n    this.type = 'BlockStatement';\n    this.block = block;\n  }\n};\n\nexports.BreakStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { label } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('BreakStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['label'])) {\n      throw new TypeError('Argument to BreakStatement constructor has wrong keys: expected {label}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof label === 'undefined' || label !== null && (typeof label !== 'string')) {\n      throw new TypeError('Field \"label\" of BreakStatement constructor argument is of incorrect type (expected null or string, got ' + printActualType(label) + ')');\n    }\n    this.type = 'BreakStatement';\n    this.label = label;\n  }\n};\n\nexports.CallExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { callee, arguments: _arguments } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('CallExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['arguments', 'callee'])) {\n      throw new TypeError('Argument to CallExpression constructor has wrong keys: expected {callee, arguments}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof callee === 'undefined' || (isNotExpression(callee)) && (callee.type !== 'Super')) {\n      throw new TypeError('Field \"callee\" of CallExpression constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(callee) + ')');\n    }\n    if (!Array.isArray(_arguments) || _arguments.some(f => typeof f === 'undefined' || (isNotExpression(f)) && (f.type !== 'SpreadElement'))) {\n      throw new TypeError('Field \"arguments\" of CallExpression constructor argument is of incorrect type (expected [one of {Expression, SpreadElement}], got ' + printActualType(_arguments) + ')');\n    }\n    this.type = 'CallExpression';\n    this.callee = callee;\n    this.arguments = _arguments;\n  }\n};\n\nexports.CatchClause = class {\n  constructor(arg, ...extraArgs) {\n    const { binding, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('CatchClause constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'body'])) {\n      throw new TypeError('Argument to CatchClause constructor has wrong keys: expected {binding, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || binding !== null && ((binding.type !== 'BindingIdentifier') && ((binding.type !== 'ArrayBinding') && (binding.type !== 'ObjectBinding')))) {\n      throw new TypeError('Field \"binding\" of CatchClause constructor argument is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');\n    }\n    if (typeof body === 'undefined' || body.type !== 'Block') {\n      throw new TypeError('Field \"body\" of CatchClause constructor argument is of incorrect type (expected Block, got ' + printActualType(body) + ')');\n    }\n    this.type = 'CatchClause';\n    this.binding = binding;\n    this.body = body;\n  }\n};\n\nexports.ClassDeclaration = class {\n  constructor(arg, ...extraArgs) {\n    const { name, super: _super, elements } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ClassDeclaration constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'name', 'super'])) {\n      throw new TypeError('Argument to ClassDeclaration constructor has wrong keys: expected {name, super, elements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"name\" of ClassDeclaration constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(name) + ')');\n    }\n    if (typeof _super === 'undefined' || _super !== null && (isNotExpression(_super))) {\n      throw new TypeError('Field \"super\" of ClassDeclaration constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(_super) + ')');\n    }\n    if (!Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f.type !== 'ClassElement')) {\n      throw new TypeError('Field \"elements\" of ClassDeclaration constructor argument is of incorrect type (expected [ClassElement], got ' + printActualType(elements) + ')');\n    }\n    this.type = 'ClassDeclaration';\n    this.name = name;\n    this.super = _super;\n    this.elements = elements;\n  }\n};\n\nexports.ClassElement = class {\n  constructor(arg, ...extraArgs) {\n    const { isStatic, method } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ClassElement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['isStatic', 'method'])) {\n      throw new TypeError('Argument to ClassElement constructor has wrong keys: expected {isStatic, method}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof isStatic !== 'boolean') {\n      throw new TypeError('Field \"isStatic\" of ClassElement constructor argument is of incorrect type (expected boolean, got ' + printActualType(isStatic) + ')');\n    }\n    if (typeof method === 'undefined' || (method.type !== 'Getter') && (method.type !== 'Method') && (method.type !== 'Setter')) {\n      throw new TypeError('Field \"method\" of ClassElement constructor argument is of incorrect type (expected one of {Getter, Method, Setter}, got ' + printActualType(method) + ')');\n    }\n    this.type = 'ClassElement';\n    this.isStatic = isStatic;\n    this.method = method;\n  }\n};\n\nexports.ClassExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { name, super: _super, elements } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ClassExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'name', 'super'])) {\n      throw new TypeError('Argument to ClassExpression constructor has wrong keys: expected {name, super, elements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name !== null && (name.type !== 'BindingIdentifier')) {\n      throw new TypeError('Field \"name\" of ClassExpression constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(name) + ')');\n    }\n    if (typeof _super === 'undefined' || _super !== null && (isNotExpression(_super))) {\n      throw new TypeError('Field \"super\" of ClassExpression constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(_super) + ')');\n    }\n    if (!Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || f.type !== 'ClassElement')) {\n      throw new TypeError('Field \"elements\" of ClassExpression constructor argument is of incorrect type (expected [ClassElement], got ' + printActualType(elements) + ')');\n    }\n    this.type = 'ClassExpression';\n    this.name = name;\n    this.super = _super;\n    this.elements = elements;\n  }\n};\n\nexports.CompoundAssignmentExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { binding, operator, expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('CompoundAssignmentExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'expression', 'operator'])) {\n      throw new TypeError('Argument to CompoundAssignmentExpression constructor has wrong keys: expected {binding, operator, expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || (binding.type !== 'AssignmentTargetIdentifier') && ((binding.type !== 'ComputedMemberAssignmentTarget') && (binding.type !== 'StaticMemberAssignmentTarget'))) {\n      throw new TypeError('Field \"binding\" of CompoundAssignmentExpression constructor argument is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(binding) + ')');\n    }\n    if (typeof operator === 'undefined' || ['+=', '-=', '*=', '/=', '%=', '**=', '<<=', '>>=', '>>>=', '|=', '^=', '&='].indexOf(operator) === -1) {\n      throw new TypeError('Field \"operator\" of CompoundAssignmentExpression constructor argument is of incorrect type (expected one of {\"+=\", \"-=\", \"*=\", \"/=\", \"%=\", \"**=\", \"<<=\", \">>=\", \">>>=\", \"|=\", \"^=\", \"&=\"}, got ' + printActualType(operator) + ')');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of CompoundAssignmentExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'CompoundAssignmentExpression';\n    this.binding = binding;\n    this.operator = operator;\n    this.expression = expression;\n  }\n};\n\nexports.ComputedMemberAssignmentTarget = class {\n  constructor(arg, ...extraArgs) {\n    const { object, expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ComputedMemberAssignmentTarget constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression', 'object'])) {\n      throw new TypeError('Argument to ComputedMemberAssignmentTarget constructor has wrong keys: expected {object, expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof object === 'undefined' || (isNotExpression(object)) && (object.type !== 'Super')) {\n      throw new TypeError('Field \"object\" of ComputedMemberAssignmentTarget constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of ComputedMemberAssignmentTarget constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'ComputedMemberAssignmentTarget';\n    this.object = object;\n    this.expression = expression;\n  }\n};\n\nexports.ComputedMemberExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { object, expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ComputedMemberExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression', 'object'])) {\n      throw new TypeError('Argument to ComputedMemberExpression constructor has wrong keys: expected {object, expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof object === 'undefined' || (isNotExpression(object)) && (object.type !== 'Super')) {\n      throw new TypeError('Field \"object\" of ComputedMemberExpression constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of ComputedMemberExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'ComputedMemberExpression';\n    this.object = object;\n    this.expression = expression;\n  }\n};\n\nexports.ComputedPropertyName = class {\n  constructor(arg, ...extraArgs) {\n    const { expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ComputedPropertyName constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to ComputedPropertyName constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of ComputedPropertyName constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'ComputedPropertyName';\n    this.expression = expression;\n  }\n};\n\nexports.ConditionalExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { test, consequent, alternate } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ConditionalExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['alternate', 'consequent', 'test'])) {\n      throw new TypeError('Argument to ConditionalExpression constructor has wrong keys: expected {test, consequent, alternate}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(test)) {\n      throw new TypeError('Field \"test\" of ConditionalExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');\n    }\n    if (isNotExpression(consequent)) {\n      throw new TypeError('Field \"consequent\" of ConditionalExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(consequent) + ')');\n    }\n    if (isNotExpression(alternate)) {\n      throw new TypeError('Field \"alternate\" of ConditionalExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(alternate) + ')');\n    }\n    this.type = 'ConditionalExpression';\n    this.test = test;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n};\n\nexports.ContinueStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { label } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ContinueStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['label'])) {\n      throw new TypeError('Argument to ContinueStatement constructor has wrong keys: expected {label}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof label === 'undefined' || label !== null && (typeof label !== 'string')) {\n      throw new TypeError('Field \"label\" of ContinueStatement constructor argument is of incorrect type (expected null or string, got ' + printActualType(label) + ')');\n    }\n    this.type = 'ContinueStatement';\n    this.label = label;\n  }\n};\n\nexports.DataProperty = class {\n  constructor(arg, ...extraArgs) {\n    const { name, expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('DataProperty constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression', 'name'])) {\n      throw new TypeError('Argument to DataProperty constructor has wrong keys: expected {name, expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {\n      throw new TypeError('Field \"name\" of DataProperty constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of DataProperty constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'DataProperty';\n    this.name = name;\n    this.expression = expression;\n  }\n};\n\nexports.DebuggerStatement = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('DebuggerStatement constructor takes no arguments');\n    }\n    this.type = 'DebuggerStatement';\n  }\n};\n\nexports.Directive = class {\n  constructor(arg, ...extraArgs) {\n    const { rawValue } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Directive constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['rawValue'])) {\n      throw new TypeError('Argument to Directive constructor has wrong keys: expected {rawValue}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof rawValue !== 'string') {\n      throw new TypeError('Field \"rawValue\" of Directive constructor argument is of incorrect type (expected string, got ' + printActualType(rawValue) + ')');\n    }\n    this.type = 'Directive';\n    this.rawValue = rawValue;\n  }\n};\n\nexports.DoWhileStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { body, test } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('DoWhileStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'test'])) {\n      throw new TypeError('Argument to DoWhileStatement constructor has wrong keys: expected {body, test}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of DoWhileStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    if (isNotExpression(test)) {\n      throw new TypeError('Field \"test\" of DoWhileStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');\n    }\n    this.type = 'DoWhileStatement';\n    this.body = body;\n    this.test = test;\n  }\n};\n\nexports.EmptyStatement = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('EmptyStatement constructor takes no arguments');\n    }\n    this.type = 'EmptyStatement';\n  }\n};\n\nexports.Export = class {\n  constructor(arg, ...extraArgs) {\n    const { declaration } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Export constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['declaration'])) {\n      throw new TypeError('Argument to Export constructor has wrong keys: expected {declaration}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof declaration === 'undefined' || (declaration.type !== 'ClassDeclaration') && (declaration.type !== 'FunctionDeclaration') && (declaration.type !== 'VariableDeclaration')) {\n      throw new TypeError('Field \"declaration\" of Export constructor argument is of incorrect type (expected one of {ClassDeclaration, FunctionDeclaration, VariableDeclaration}, got ' + printActualType(declaration) + ')');\n    }\n    this.type = 'Export';\n    this.declaration = declaration;\n  }\n};\n\nexports.ExportAllFrom = class {\n  constructor(arg, ...extraArgs) {\n    const { moduleSpecifier } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExportAllFrom constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['moduleSpecifier'])) {\n      throw new TypeError('Argument to ExportAllFrom constructor has wrong keys: expected {moduleSpecifier}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof moduleSpecifier !== 'string') {\n      throw new TypeError('Field \"moduleSpecifier\" of ExportAllFrom constructor argument is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');\n    }\n    this.type = 'ExportAllFrom';\n    this.moduleSpecifier = moduleSpecifier;\n  }\n};\n\nexports.ExportDefault = class {\n  constructor(arg, ...extraArgs) {\n    const { body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExportDefault constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body'])) {\n      throw new TypeError('Argument to ExportDefault constructor has wrong keys: expected {body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof body === 'undefined' || (body.type !== 'ClassDeclaration') && (isNotExpression(body)) && (body.type !== 'FunctionDeclaration')) {\n      throw new TypeError('Field \"body\" of ExportDefault constructor argument is of incorrect type (expected one of {ClassDeclaration, Expression, FunctionDeclaration}, got ' + printActualType(body) + ')');\n    }\n    this.type = 'ExportDefault';\n    this.body = body;\n  }\n};\n\nexports.ExportFrom = class {\n  constructor(arg, ...extraArgs) {\n    const { namedExports, moduleSpecifier } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExportFrom constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['moduleSpecifier', 'namedExports'])) {\n      throw new TypeError('Argument to ExportFrom constructor has wrong keys: expected {namedExports, moduleSpecifier}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(namedExports) || namedExports.some(f => typeof f === 'undefined' || f.type !== 'ExportFromSpecifier')) {\n      throw new TypeError('Field \"namedExports\" of ExportFrom constructor argument is of incorrect type (expected [ExportFromSpecifier], got ' + printActualType(namedExports) + ')');\n    }\n    if (typeof moduleSpecifier !== 'string') {\n      throw new TypeError('Field \"moduleSpecifier\" of ExportFrom constructor argument is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');\n    }\n    this.type = 'ExportFrom';\n    this.namedExports = namedExports;\n    this.moduleSpecifier = moduleSpecifier;\n  }\n};\n\nexports.ExportFromSpecifier = class {\n  constructor(arg, ...extraArgs) {\n    const { name, exportedName } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExportFromSpecifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['exportedName', 'name'])) {\n      throw new TypeError('Argument to ExportFromSpecifier constructor has wrong keys: expected {name, exportedName}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name !== 'string') {\n      throw new TypeError('Field \"name\" of ExportFromSpecifier constructor argument is of incorrect type (expected string, got ' + printActualType(name) + ')');\n    }\n    if (typeof exportedName === 'undefined' || exportedName !== null && (typeof exportedName !== 'string')) {\n      throw new TypeError('Field \"exportedName\" of ExportFromSpecifier constructor argument is of incorrect type (expected null or string, got ' + printActualType(exportedName) + ')');\n    }\n    this.type = 'ExportFromSpecifier';\n    this.name = name;\n    this.exportedName = exportedName;\n  }\n};\n\nexports.ExportLocalSpecifier = class {\n  constructor(arg, ...extraArgs) {\n    const { name, exportedName } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExportLocalSpecifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['exportedName', 'name'])) {\n      throw new TypeError('Argument to ExportLocalSpecifier constructor has wrong keys: expected {name, exportedName}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name.type !== 'IdentifierExpression') {\n      throw new TypeError('Field \"name\" of ExportLocalSpecifier constructor argument is of incorrect type (expected IdentifierExpression, got ' + printActualType(name) + ')');\n    }\n    if (typeof exportedName === 'undefined' || exportedName !== null && (typeof exportedName !== 'string')) {\n      throw new TypeError('Field \"exportedName\" of ExportLocalSpecifier constructor argument is of incorrect type (expected null or string, got ' + printActualType(exportedName) + ')');\n    }\n    this.type = 'ExportLocalSpecifier';\n    this.name = name;\n    this.exportedName = exportedName;\n  }\n};\n\nexports.ExportLocals = class {\n  constructor(arg, ...extraArgs) {\n    const { namedExports } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExportLocals constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['namedExports'])) {\n      throw new TypeError('Argument to ExportLocals constructor has wrong keys: expected {namedExports}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(namedExports) || namedExports.some(f => typeof f === 'undefined' || f.type !== 'ExportLocalSpecifier')) {\n      throw new TypeError('Field \"namedExports\" of ExportLocals constructor argument is of incorrect type (expected [ExportLocalSpecifier], got ' + printActualType(namedExports) + ')');\n    }\n    this.type = 'ExportLocals';\n    this.namedExports = namedExports;\n  }\n};\n\nexports.ExpressionStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ExpressionStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to ExpressionStatement constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of ExpressionStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'ExpressionStatement';\n    this.expression = expression;\n  }\n};\n\nexports.ForAwaitStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { left, right, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ForAwaitStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'left', 'right'])) {\n      throw new TypeError('Argument to ForAwaitStatement constructor has wrong keys: expected {left, right, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof left === 'undefined' || (((left.type !== 'ArrayAssignmentTarget') && (left.type !== 'ObjectAssignmentTarget')) && ((left.type !== 'AssignmentTargetIdentifier') && ((left.type !== 'ComputedMemberAssignmentTarget') && (left.type !== 'StaticMemberAssignmentTarget')))) && (left.type !== 'VariableDeclaration')) {\n      throw new TypeError('Field \"left\" of ForAwaitStatement constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');\n    }\n    if (isNotExpression(right)) {\n      throw new TypeError('Field \"right\" of ForAwaitStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(right) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of ForAwaitStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'ForAwaitStatement';\n    this.left = left;\n    this.right = right;\n    this.body = body;\n  }\n};\n\nexports.ForInStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { left, right, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ForInStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'left', 'right'])) {\n      throw new TypeError('Argument to ForInStatement constructor has wrong keys: expected {left, right, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof left === 'undefined' || (((left.type !== 'ArrayAssignmentTarget') && (left.type !== 'ObjectAssignmentTarget')) && ((left.type !== 'AssignmentTargetIdentifier') && ((left.type !== 'ComputedMemberAssignmentTarget') && (left.type !== 'StaticMemberAssignmentTarget')))) && (left.type !== 'VariableDeclaration')) {\n      throw new TypeError('Field \"left\" of ForInStatement constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');\n    }\n    if (isNotExpression(right)) {\n      throw new TypeError('Field \"right\" of ForInStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(right) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of ForInStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'ForInStatement';\n    this.left = left;\n    this.right = right;\n    this.body = body;\n  }\n};\n\nexports.ForOfStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { left, right, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ForOfStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'left', 'right'])) {\n      throw new TypeError('Argument to ForOfStatement constructor has wrong keys: expected {left, right, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof left === 'undefined' || (((left.type !== 'ArrayAssignmentTarget') && (left.type !== 'ObjectAssignmentTarget')) && ((left.type !== 'AssignmentTargetIdentifier') && ((left.type !== 'ComputedMemberAssignmentTarget') && (left.type !== 'StaticMemberAssignmentTarget')))) && (left.type !== 'VariableDeclaration')) {\n      throw new TypeError('Field \"left\" of ForOfStatement constructor argument is of incorrect type (expected one of {ArrayAssignmentTarget, ObjectAssignmentTarget, AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget, VariableDeclaration}, got ' + printActualType(left) + ')');\n    }\n    if (isNotExpression(right)) {\n      throw new TypeError('Field \"right\" of ForOfStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(right) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of ForOfStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'ForOfStatement';\n    this.left = left;\n    this.right = right;\n    this.body = body;\n  }\n};\n\nexports.ForStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { init, test, update, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ForStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'init', 'test', 'update'])) {\n      throw new TypeError('Argument to ForStatement constructor has wrong keys: expected {init, test, update, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof init === 'undefined' || init !== null && ((isNotExpression(init)) && (init.type !== 'VariableDeclaration'))) {\n      throw new TypeError('Field \"init\" of ForStatement constructor argument is of incorrect type (expected null or one of {Expression, VariableDeclaration}, got ' + printActualType(init) + ')');\n    }\n    if (typeof test === 'undefined' || test !== null && (isNotExpression(test))) {\n      throw new TypeError('Field \"test\" of ForStatement constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(test) + ')');\n    }\n    if (typeof update === 'undefined' || update !== null && (isNotExpression(update))) {\n      throw new TypeError('Field \"update\" of ForStatement constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(update) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of ForStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'ForStatement';\n    this.init = init;\n    this.test = test;\n    this.update = update;\n    this.body = body;\n  }\n};\n\nexports.FormalParameters = class {\n  constructor(arg, ...extraArgs) {\n    const { items, rest } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('FormalParameters constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['items', 'rest'])) {\n      throw new TypeError('Argument to FormalParameters constructor has wrong keys: expected {items, rest}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(items) || items.some(f => typeof f === 'undefined' || (f.type !== 'BindingWithDefault') && ((f.type !== 'BindingIdentifier') && ((f.type !== 'ArrayBinding') && (f.type !== 'ObjectBinding'))))) {\n      throw new TypeError('Field \"items\" of FormalParameters constructor argument is of incorrect type (expected [one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}], got ' + printActualType(items) + ')');\n    }\n    if (typeof rest === 'undefined' || rest !== null && ((rest.type !== 'BindingIdentifier') && ((rest.type !== 'ArrayBinding') && (rest.type !== 'ObjectBinding')))) {\n      throw new TypeError('Field \"rest\" of FormalParameters constructor argument is of incorrect type (expected null or one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(rest) + ')');\n    }\n    this.type = 'FormalParameters';\n    this.items = items;\n    this.rest = rest;\n  }\n};\n\nexports.FunctionBody = class {\n  constructor(arg, ...extraArgs) {\n    const { directives, statements } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('FunctionBody constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['directives', 'statements'])) {\n      throw new TypeError('Argument to FunctionBody constructor has wrong keys: expected {directives, statements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(directives) || directives.some(f => typeof f === 'undefined' || f.type !== 'Directive')) {\n      throw new TypeError('Field \"directives\" of FunctionBody constructor argument is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');\n    }\n    if (!Array.isArray(statements) || statements.some(f => isNotStatement(f))) {\n      throw new TypeError('Field \"statements\" of FunctionBody constructor argument is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');\n    }\n    this.type = 'FunctionBody';\n    this.directives = directives;\n    this.statements = statements;\n  }\n};\n\nexports.FunctionDeclaration = class {\n  constructor(arg, ...extraArgs) {\n    const { isAsync, isGenerator, name, params, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('FunctionDeclaration constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'isAsync', 'isGenerator', 'name', 'params'])) {\n      throw new TypeError('Argument to FunctionDeclaration constructor has wrong keys: expected {isAsync, isGenerator, name, params, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof isAsync !== 'boolean') {\n      throw new TypeError('Field \"isAsync\" of FunctionDeclaration constructor argument is of incorrect type (expected boolean, got ' + printActualType(isAsync) + ')');\n    }\n    if (typeof isGenerator !== 'boolean') {\n      throw new TypeError('Field \"isGenerator\" of FunctionDeclaration constructor argument is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');\n    }\n    if (typeof name === 'undefined' || name.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"name\" of FunctionDeclaration constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(name) + ')');\n    }\n    if (typeof params === 'undefined' || params.type !== 'FormalParameters') {\n      throw new TypeError('Field \"params\" of FunctionDeclaration constructor argument is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');\n    }\n    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {\n      throw new TypeError('Field \"body\" of FunctionDeclaration constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');\n    }\n    this.type = 'FunctionDeclaration';\n    this.isAsync = isAsync;\n    this.isGenerator = isGenerator;\n    this.name = name;\n    this.params = params;\n    this.body = body;\n  }\n};\n\nexports.FunctionExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { isAsync, isGenerator, name, params, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('FunctionExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'isAsync', 'isGenerator', 'name', 'params'])) {\n      throw new TypeError('Argument to FunctionExpression constructor has wrong keys: expected {isAsync, isGenerator, name, params, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof isAsync !== 'boolean') {\n      throw new TypeError('Field \"isAsync\" of FunctionExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(isAsync) + ')');\n    }\n    if (typeof isGenerator !== 'boolean') {\n      throw new TypeError('Field \"isGenerator\" of FunctionExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');\n    }\n    if (typeof name === 'undefined' || name !== null && (name.type !== 'BindingIdentifier')) {\n      throw new TypeError('Field \"name\" of FunctionExpression constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(name) + ')');\n    }\n    if (typeof params === 'undefined' || params.type !== 'FormalParameters') {\n      throw new TypeError('Field \"params\" of FunctionExpression constructor argument is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');\n    }\n    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {\n      throw new TypeError('Field \"body\" of FunctionExpression constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');\n    }\n    this.type = 'FunctionExpression';\n    this.isAsync = isAsync;\n    this.isGenerator = isGenerator;\n    this.name = name;\n    this.params = params;\n    this.body = body;\n  }\n};\n\nexports.Getter = class {\n  constructor(arg, ...extraArgs) {\n    const { name, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Getter constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'name'])) {\n      throw new TypeError('Argument to Getter constructor has wrong keys: expected {name, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {\n      throw new TypeError('Field \"name\" of Getter constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');\n    }\n    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {\n      throw new TypeError('Field \"body\" of Getter constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');\n    }\n    this.type = 'Getter';\n    this.name = name;\n    this.body = body;\n  }\n};\n\nexports.IdentifierExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { name } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('IdentifierExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['name'])) {\n      throw new TypeError('Argument to IdentifierExpression constructor has wrong keys: expected {name}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name !== 'string') {\n      throw new TypeError('Field \"name\" of IdentifierExpression constructor argument is of incorrect type (expected string, got ' + printActualType(name) + ')');\n    }\n    this.type = 'IdentifierExpression';\n    this.name = name;\n  }\n};\n\nexports.IfStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { test, consequent, alternate } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('IfStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['alternate', 'consequent', 'test'])) {\n      throw new TypeError('Argument to IfStatement constructor has wrong keys: expected {test, consequent, alternate}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(test)) {\n      throw new TypeError('Field \"test\" of IfStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');\n    }\n    if (isNotStatement(consequent)) {\n      throw new TypeError('Field \"consequent\" of IfStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(consequent) + ')');\n    }\n    if (typeof alternate === 'undefined' || alternate !== null && (isNotStatement(alternate))) {\n      throw new TypeError('Field \"alternate\" of IfStatement constructor argument is of incorrect type (expected null or Statement, got ' + printActualType(alternate) + ')');\n    }\n    this.type = 'IfStatement';\n    this.test = test;\n    this.consequent = consequent;\n    this.alternate = alternate;\n  }\n};\n\nexports.Import = class {\n  constructor(arg, ...extraArgs) {\n    const { defaultBinding, namedImports, moduleSpecifier } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Import constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['defaultBinding', 'moduleSpecifier', 'namedImports'])) {\n      throw new TypeError('Argument to Import constructor has wrong keys: expected {defaultBinding, namedImports, moduleSpecifier}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof defaultBinding === 'undefined' || defaultBinding !== null && (defaultBinding.type !== 'BindingIdentifier')) {\n      throw new TypeError('Field \"defaultBinding\" of Import constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(defaultBinding) + ')');\n    }\n    if (!Array.isArray(namedImports) || namedImports.some(f => typeof f === 'undefined' || f.type !== 'ImportSpecifier')) {\n      throw new TypeError('Field \"namedImports\" of Import constructor argument is of incorrect type (expected [ImportSpecifier], got ' + printActualType(namedImports) + ')');\n    }\n    if (typeof moduleSpecifier !== 'string') {\n      throw new TypeError('Field \"moduleSpecifier\" of Import constructor argument is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');\n    }\n    this.type = 'Import';\n    this.defaultBinding = defaultBinding;\n    this.namedImports = namedImports;\n    this.moduleSpecifier = moduleSpecifier;\n  }\n};\n\nexports.ImportNamespace = class {\n  constructor(arg, ...extraArgs) {\n    const { defaultBinding, namespaceBinding, moduleSpecifier } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ImportNamespace constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['defaultBinding', 'moduleSpecifier', 'namespaceBinding'])) {\n      throw new TypeError('Argument to ImportNamespace constructor has wrong keys: expected {defaultBinding, namespaceBinding, moduleSpecifier}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof defaultBinding === 'undefined' || defaultBinding !== null && (defaultBinding.type !== 'BindingIdentifier')) {\n      throw new TypeError('Field \"defaultBinding\" of ImportNamespace constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(defaultBinding) + ')');\n    }\n    if (typeof namespaceBinding === 'undefined' || namespaceBinding.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"namespaceBinding\" of ImportNamespace constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(namespaceBinding) + ')');\n    }\n    if (typeof moduleSpecifier !== 'string') {\n      throw new TypeError('Field \"moduleSpecifier\" of ImportNamespace constructor argument is of incorrect type (expected string, got ' + printActualType(moduleSpecifier) + ')');\n    }\n    this.type = 'ImportNamespace';\n    this.defaultBinding = defaultBinding;\n    this.namespaceBinding = namespaceBinding;\n    this.moduleSpecifier = moduleSpecifier;\n  }\n};\n\nexports.ImportSpecifier = class {\n  constructor(arg, ...extraArgs) {\n    const { name, binding } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ImportSpecifier constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'name'])) {\n      throw new TypeError('Argument to ImportSpecifier constructor has wrong keys: expected {name, binding}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name !== null && (typeof name !== 'string')) {\n      throw new TypeError('Field \"name\" of ImportSpecifier constructor argument is of incorrect type (expected null or string, got ' + printActualType(name) + ')');\n    }\n    if (typeof binding === 'undefined' || binding.type !== 'BindingIdentifier') {\n      throw new TypeError('Field \"binding\" of ImportSpecifier constructor argument is of incorrect type (expected BindingIdentifier, got ' + printActualType(binding) + ')');\n    }\n    this.type = 'ImportSpecifier';\n    this.name = name;\n    this.binding = binding;\n  }\n};\n\nexports.LabeledStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { label, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('LabeledStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'label'])) {\n      throw new TypeError('Argument to LabeledStatement constructor has wrong keys: expected {label, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof label !== 'string') {\n      throw new TypeError('Field \"label\" of LabeledStatement constructor argument is of incorrect type (expected string, got ' + printActualType(label) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of LabeledStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'LabeledStatement';\n    this.label = label;\n    this.body = body;\n  }\n};\n\nexports.LiteralBooleanExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { value } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('LiteralBooleanExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['value'])) {\n      throw new TypeError('Argument to LiteralBooleanExpression constructor has wrong keys: expected {value}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof value !== 'boolean') {\n      throw new TypeError('Field \"value\" of LiteralBooleanExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(value) + ')');\n    }\n    this.type = 'LiteralBooleanExpression';\n    this.value = value;\n  }\n};\n\nexports.LiteralInfinityExpression = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('LiteralInfinityExpression constructor takes no arguments');\n    }\n    this.type = 'LiteralInfinityExpression';\n  }\n};\n\nexports.LiteralNullExpression = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('LiteralNullExpression constructor takes no arguments');\n    }\n    this.type = 'LiteralNullExpression';\n  }\n};\n\nexports.LiteralNumericExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { value } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('LiteralNumericExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['value'])) {\n      throw new TypeError('Argument to LiteralNumericExpression constructor has wrong keys: expected {value}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof value !== 'number') {\n      throw new TypeError('Field \"value\" of LiteralNumericExpression constructor argument is of incorrect type (expected number, got ' + printActualType(value) + ')');\n    }\n    this.type = 'LiteralNumericExpression';\n    this.value = value;\n  }\n};\n\nexports.LiteralRegExpExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { pattern, global, ignoreCase, multiLine, dotAll, unicode, sticky } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('LiteralRegExpExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['dotAll', 'global', 'ignoreCase', 'multiLine', 'pattern', 'sticky', 'unicode'])) {\n      throw new TypeError('Argument to LiteralRegExpExpression constructor has wrong keys: expected {pattern, global, ignoreCase, multiLine, dotAll, unicode, sticky}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof pattern !== 'string') {\n      throw new TypeError('Field \"pattern\" of LiteralRegExpExpression constructor argument is of incorrect type (expected string, got ' + printActualType(pattern) + ')');\n    }\n    if (typeof global !== 'boolean') {\n      throw new TypeError('Field \"global\" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(global) + ')');\n    }\n    if (typeof ignoreCase !== 'boolean') {\n      throw new TypeError('Field \"ignoreCase\" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(ignoreCase) + ')');\n    }\n    if (typeof multiLine !== 'boolean') {\n      throw new TypeError('Field \"multiLine\" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(multiLine) + ')');\n    }\n    if (typeof dotAll !== 'boolean') {\n      throw new TypeError('Field \"dotAll\" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(dotAll) + ')');\n    }\n    if (typeof unicode !== 'boolean') {\n      throw new TypeError('Field \"unicode\" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(unicode) + ')');\n    }\n    if (typeof sticky !== 'boolean') {\n      throw new TypeError('Field \"sticky\" of LiteralRegExpExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(sticky) + ')');\n    }\n    this.type = 'LiteralRegExpExpression';\n    this.pattern = pattern;\n    this.global = global;\n    this.ignoreCase = ignoreCase;\n    this.multiLine = multiLine;\n    this.dotAll = dotAll;\n    this.unicode = unicode;\n    this.sticky = sticky;\n  }\n};\n\nexports.LiteralStringExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { value } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('LiteralStringExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['value'])) {\n      throw new TypeError('Argument to LiteralStringExpression constructor has wrong keys: expected {value}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof value !== 'string') {\n      throw new TypeError('Field \"value\" of LiteralStringExpression constructor argument is of incorrect type (expected string, got ' + printActualType(value) + ')');\n    }\n    this.type = 'LiteralStringExpression';\n    this.value = value;\n  }\n};\n\nexports.Method = class {\n  constructor(arg, ...extraArgs) {\n    const { isAsync, isGenerator, name, params, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Method constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'isAsync', 'isGenerator', 'name', 'params'])) {\n      throw new TypeError('Argument to Method constructor has wrong keys: expected {isAsync, isGenerator, name, params, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof isAsync !== 'boolean') {\n      throw new TypeError('Field \"isAsync\" of Method constructor argument is of incorrect type (expected boolean, got ' + printActualType(isAsync) + ')');\n    }\n    if (typeof isGenerator !== 'boolean') {\n      throw new TypeError('Field \"isGenerator\" of Method constructor argument is of incorrect type (expected boolean, got ' + printActualType(isGenerator) + ')');\n    }\n    if (typeof name === 'undefined' || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {\n      throw new TypeError('Field \"name\" of Method constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');\n    }\n    if (typeof params === 'undefined' || params.type !== 'FormalParameters') {\n      throw new TypeError('Field \"params\" of Method constructor argument is of incorrect type (expected FormalParameters, got ' + printActualType(params) + ')');\n    }\n    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {\n      throw new TypeError('Field \"body\" of Method constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');\n    }\n    this.type = 'Method';\n    this.isAsync = isAsync;\n    this.isGenerator = isGenerator;\n    this.name = name;\n    this.params = params;\n    this.body = body;\n  }\n};\n\nexports.Module = class {\n  constructor(arg, ...extraArgs) {\n    const { directives, items } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Module constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['directives', 'items'])) {\n      throw new TypeError('Argument to Module constructor has wrong keys: expected {directives, items}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(directives) || directives.some(f => typeof f === 'undefined' || f.type !== 'Directive')) {\n      throw new TypeError('Field \"directives\" of Module constructor argument is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');\n    }\n    if (!Array.isArray(items) || items.some(f => typeof f === 'undefined' || ((f.type !== 'Export') && (f.type !== 'ExportAllFrom') && (f.type !== 'ExportDefault') && (f.type !== 'ExportFrom') && (f.type !== 'ExportLocals')) && ((f.type !== 'Import') && (f.type !== 'ImportNamespace')) && (isNotStatement(f)))) {\n      throw new TypeError('Field \"items\" of Module constructor argument is of incorrect type (expected [one of {Export, ExportAllFrom, ExportDefault, ExportFrom, ExportLocals, Import, ImportNamespace, Statement}], got ' + printActualType(items) + ')');\n    }\n    this.type = 'Module';\n    this.directives = directives;\n    this.items = items;\n  }\n};\n\nexports.NewExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { callee, arguments: _arguments } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('NewExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['arguments', 'callee'])) {\n      throw new TypeError('Argument to NewExpression constructor has wrong keys: expected {callee, arguments}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(callee)) {\n      throw new TypeError('Field \"callee\" of NewExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(callee) + ')');\n    }\n    if (!Array.isArray(_arguments) || _arguments.some(f => typeof f === 'undefined' || (isNotExpression(f)) && (f.type !== 'SpreadElement'))) {\n      throw new TypeError('Field \"arguments\" of NewExpression constructor argument is of incorrect type (expected [one of {Expression, SpreadElement}], got ' + printActualType(_arguments) + ')');\n    }\n    this.type = 'NewExpression';\n    this.callee = callee;\n    this.arguments = _arguments;\n  }\n};\n\nexports.NewTargetExpression = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('NewTargetExpression constructor takes no arguments');\n    }\n    this.type = 'NewTargetExpression';\n  }\n};\n\nexports.ObjectAssignmentTarget = class {\n  constructor(arg, ...extraArgs) {\n    const { properties, rest } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ObjectAssignmentTarget constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['properties', 'rest'])) {\n      throw new TypeError('Argument to ObjectAssignmentTarget constructor has wrong keys: expected {properties, rest}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(properties) || properties.some(f => typeof f === 'undefined' || (f.type !== 'AssignmentTargetPropertyIdentifier') && (f.type !== 'AssignmentTargetPropertyProperty'))) {\n      throw new TypeError('Field \"properties\" of ObjectAssignmentTarget constructor argument is of incorrect type (expected [one of {AssignmentTargetPropertyIdentifier, AssignmentTargetPropertyProperty}], got ' + printActualType(properties) + ')');\n    }\n    if (typeof rest === 'undefined' || rest !== null && ((rest.type !== 'AssignmentTargetIdentifier') && ((rest.type !== 'ComputedMemberAssignmentTarget') && (rest.type !== 'StaticMemberAssignmentTarget')))) {\n      throw new TypeError('Field \"rest\" of ObjectAssignmentTarget constructor argument is of incorrect type (expected null or one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(rest) + ')');\n    }\n    this.type = 'ObjectAssignmentTarget';\n    this.properties = properties;\n    this.rest = rest;\n  }\n};\n\nexports.ObjectBinding = class {\n  constructor(arg, ...extraArgs) {\n    const { properties, rest } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ObjectBinding constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['properties', 'rest'])) {\n      throw new TypeError('Argument to ObjectBinding constructor has wrong keys: expected {properties, rest}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(properties) || properties.some(f => typeof f === 'undefined' || (f.type !== 'BindingPropertyIdentifier') && (f.type !== 'BindingPropertyProperty'))) {\n      throw new TypeError('Field \"properties\" of ObjectBinding constructor argument is of incorrect type (expected [one of {BindingPropertyIdentifier, BindingPropertyProperty}], got ' + printActualType(properties) + ')');\n    }\n    if (typeof rest === 'undefined' || rest !== null && (rest.type !== 'BindingIdentifier')) {\n      throw new TypeError('Field \"rest\" of ObjectBinding constructor argument is of incorrect type (expected null or BindingIdentifier, got ' + printActualType(rest) + ')');\n    }\n    this.type = 'ObjectBinding';\n    this.properties = properties;\n    this.rest = rest;\n  }\n};\n\nexports.ObjectExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { properties } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ObjectExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['properties'])) {\n      throw new TypeError('Argument to ObjectExpression constructor has wrong keys: expected {properties}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(properties) || properties.some(f => typeof f === 'undefined' || ((f.type !== 'DataProperty') && ((f.type !== 'Getter') && (f.type !== 'Method') && (f.type !== 'Setter'))) && (f.type !== 'ShorthandProperty') && (f.type !== 'SpreadProperty'))) {\n      throw new TypeError('Field \"properties\" of ObjectExpression constructor argument is of incorrect type (expected [one of {DataProperty, Getter, Method, Setter, ShorthandProperty, SpreadProperty}], got ' + printActualType(properties) + ')');\n    }\n    this.type = 'ObjectExpression';\n    this.properties = properties;\n  }\n};\n\nexports.ReturnStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ReturnStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to ReturnStatement constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof expression === 'undefined' || expression !== null && (isNotExpression(expression))) {\n      throw new TypeError('Field \"expression\" of ReturnStatement constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'ReturnStatement';\n    this.expression = expression;\n  }\n};\n\nexports.Script = class {\n  constructor(arg, ...extraArgs) {\n    const { directives, statements } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Script constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['directives', 'statements'])) {\n      throw new TypeError('Argument to Script constructor has wrong keys: expected {directives, statements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(directives) || directives.some(f => typeof f === 'undefined' || f.type !== 'Directive')) {\n      throw new TypeError('Field \"directives\" of Script constructor argument is of incorrect type (expected [Directive], got ' + printActualType(directives) + ')');\n    }\n    if (!Array.isArray(statements) || statements.some(f => isNotStatement(f))) {\n      throw new TypeError('Field \"statements\" of Script constructor argument is of incorrect type (expected [Statement], got ' + printActualType(statements) + ')');\n    }\n    this.type = 'Script';\n    this.directives = directives;\n    this.statements = statements;\n  }\n};\n\nexports.Setter = class {\n  constructor(arg, ...extraArgs) {\n    const { name, param, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('Setter constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'name', 'param'])) {\n      throw new TypeError('Argument to Setter constructor has wrong keys: expected {name, param, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || (name.type !== 'ComputedPropertyName') && (name.type !== 'StaticPropertyName')) {\n      throw new TypeError('Field \"name\" of Setter constructor argument is of incorrect type (expected one of {ComputedPropertyName, StaticPropertyName}, got ' + printActualType(name) + ')');\n    }\n    if (typeof param === 'undefined' || (param.type !== 'BindingWithDefault') && ((param.type !== 'BindingIdentifier') && ((param.type !== 'ArrayBinding') && (param.type !== 'ObjectBinding')))) {\n      throw new TypeError('Field \"param\" of Setter constructor argument is of incorrect type (expected one of {BindingWithDefault, BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(param) + ')');\n    }\n    if (typeof body === 'undefined' || body.type !== 'FunctionBody') {\n      throw new TypeError('Field \"body\" of Setter constructor argument is of incorrect type (expected FunctionBody, got ' + printActualType(body) + ')');\n    }\n    this.type = 'Setter';\n    this.name = name;\n    this.param = param;\n    this.body = body;\n  }\n};\n\nexports.ShorthandProperty = class {\n  constructor(arg, ...extraArgs) {\n    const { name } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ShorthandProperty constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['name'])) {\n      throw new TypeError('Argument to ShorthandProperty constructor has wrong keys: expected {name}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof name === 'undefined' || name.type !== 'IdentifierExpression') {\n      throw new TypeError('Field \"name\" of ShorthandProperty constructor argument is of incorrect type (expected IdentifierExpression, got ' + printActualType(name) + ')');\n    }\n    this.type = 'ShorthandProperty';\n    this.name = name;\n  }\n};\n\nexports.SpreadElement = class {\n  constructor(arg, ...extraArgs) {\n    const { expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('SpreadElement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to SpreadElement constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of SpreadElement constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'SpreadElement';\n    this.expression = expression;\n  }\n};\n\nexports.SpreadProperty = class {\n  constructor(arg, ...extraArgs) {\n    const { expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('SpreadProperty constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to SpreadProperty constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of SpreadProperty constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'SpreadProperty';\n    this.expression = expression;\n  }\n};\n\nexports.StaticMemberAssignmentTarget = class {\n  constructor(arg, ...extraArgs) {\n    const { object, property } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('StaticMemberAssignmentTarget constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['object', 'property'])) {\n      throw new TypeError('Argument to StaticMemberAssignmentTarget constructor has wrong keys: expected {object, property}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof object === 'undefined' || (isNotExpression(object)) && (object.type !== 'Super')) {\n      throw new TypeError('Field \"object\" of StaticMemberAssignmentTarget constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');\n    }\n    if (typeof property !== 'string') {\n      throw new TypeError('Field \"property\" of StaticMemberAssignmentTarget constructor argument is of incorrect type (expected string, got ' + printActualType(property) + ')');\n    }\n    this.type = 'StaticMemberAssignmentTarget';\n    this.object = object;\n    this.property = property;\n  }\n};\n\nexports.StaticMemberExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { object, property } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('StaticMemberExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['object', 'property'])) {\n      throw new TypeError('Argument to StaticMemberExpression constructor has wrong keys: expected {object, property}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof object === 'undefined' || (isNotExpression(object)) && (object.type !== 'Super')) {\n      throw new TypeError('Field \"object\" of StaticMemberExpression constructor argument is of incorrect type (expected one of {Expression, Super}, got ' + printActualType(object) + ')');\n    }\n    if (typeof property !== 'string') {\n      throw new TypeError('Field \"property\" of StaticMemberExpression constructor argument is of incorrect type (expected string, got ' + printActualType(property) + ')');\n    }\n    this.type = 'StaticMemberExpression';\n    this.object = object;\n    this.property = property;\n  }\n};\n\nexports.StaticPropertyName = class {\n  constructor(arg, ...extraArgs) {\n    const { value } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('StaticPropertyName constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['value'])) {\n      throw new TypeError('Argument to StaticPropertyName constructor has wrong keys: expected {value}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof value !== 'string') {\n      throw new TypeError('Field \"value\" of StaticPropertyName constructor argument is of incorrect type (expected string, got ' + printActualType(value) + ')');\n    }\n    this.type = 'StaticPropertyName';\n    this.value = value;\n  }\n};\n\nexports.Super = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('Super constructor takes no arguments');\n    }\n    this.type = 'Super';\n  }\n};\n\nexports.SwitchCase = class {\n  constructor(arg, ...extraArgs) {\n    const { test, consequent } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('SwitchCase constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['consequent', 'test'])) {\n      throw new TypeError('Argument to SwitchCase constructor has wrong keys: expected {test, consequent}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(test)) {\n      throw new TypeError('Field \"test\" of SwitchCase constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');\n    }\n    if (!Array.isArray(consequent) || consequent.some(f => isNotStatement(f))) {\n      throw new TypeError('Field \"consequent\" of SwitchCase constructor argument is of incorrect type (expected [Statement], got ' + printActualType(consequent) + ')');\n    }\n    this.type = 'SwitchCase';\n    this.test = test;\n    this.consequent = consequent;\n  }\n};\n\nexports.SwitchDefault = class {\n  constructor(arg, ...extraArgs) {\n    const { consequent } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('SwitchDefault constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['consequent'])) {\n      throw new TypeError('Argument to SwitchDefault constructor has wrong keys: expected {consequent}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (!Array.isArray(consequent) || consequent.some(f => isNotStatement(f))) {\n      throw new TypeError('Field \"consequent\" of SwitchDefault constructor argument is of incorrect type (expected [Statement], got ' + printActualType(consequent) + ')');\n    }\n    this.type = 'SwitchDefault';\n    this.consequent = consequent;\n  }\n};\n\nexports.SwitchStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { discriminant, cases } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('SwitchStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['cases', 'discriminant'])) {\n      throw new TypeError('Argument to SwitchStatement constructor has wrong keys: expected {discriminant, cases}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(discriminant)) {\n      throw new TypeError('Field \"discriminant\" of SwitchStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(discriminant) + ')');\n    }\n    if (!Array.isArray(cases) || cases.some(f => typeof f === 'undefined' || f.type !== 'SwitchCase')) {\n      throw new TypeError('Field \"cases\" of SwitchStatement constructor argument is of incorrect type (expected [SwitchCase], got ' + printActualType(cases) + ')');\n    }\n    this.type = 'SwitchStatement';\n    this.discriminant = discriminant;\n    this.cases = cases;\n  }\n};\n\nexports.SwitchStatementWithDefault = class {\n  constructor(arg, ...extraArgs) {\n    const { discriminant, preDefaultCases, defaultCase, postDefaultCases } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('SwitchStatementWithDefault constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['defaultCase', 'discriminant', 'postDefaultCases', 'preDefaultCases'])) {\n      throw new TypeError('Argument to SwitchStatementWithDefault constructor has wrong keys: expected {discriminant, preDefaultCases, defaultCase, postDefaultCases}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(discriminant)) {\n      throw new TypeError('Field \"discriminant\" of SwitchStatementWithDefault constructor argument is of incorrect type (expected Expression, got ' + printActualType(discriminant) + ')');\n    }\n    if (!Array.isArray(preDefaultCases) || preDefaultCases.some(f => typeof f === 'undefined' || f.type !== 'SwitchCase')) {\n      throw new TypeError('Field \"preDefaultCases\" of SwitchStatementWithDefault constructor argument is of incorrect type (expected [SwitchCase], got ' + printActualType(preDefaultCases) + ')');\n    }\n    if (typeof defaultCase === 'undefined' || defaultCase.type !== 'SwitchDefault') {\n      throw new TypeError('Field \"defaultCase\" of SwitchStatementWithDefault constructor argument is of incorrect type (expected SwitchDefault, got ' + printActualType(defaultCase) + ')');\n    }\n    if (!Array.isArray(postDefaultCases) || postDefaultCases.some(f => typeof f === 'undefined' || f.type !== 'SwitchCase')) {\n      throw new TypeError('Field \"postDefaultCases\" of SwitchStatementWithDefault constructor argument is of incorrect type (expected [SwitchCase], got ' + printActualType(postDefaultCases) + ')');\n    }\n    this.type = 'SwitchStatementWithDefault';\n    this.discriminant = discriminant;\n    this.preDefaultCases = preDefaultCases;\n    this.defaultCase = defaultCase;\n    this.postDefaultCases = postDefaultCases;\n  }\n};\n\nexports.TemplateElement = class {\n  constructor(arg, ...extraArgs) {\n    const { rawValue } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('TemplateElement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['rawValue'])) {\n      throw new TypeError('Argument to TemplateElement constructor has wrong keys: expected {rawValue}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof rawValue !== 'string') {\n      throw new TypeError('Field \"rawValue\" of TemplateElement constructor argument is of incorrect type (expected string, got ' + printActualType(rawValue) + ')');\n    }\n    this.type = 'TemplateElement';\n    this.rawValue = rawValue;\n  }\n};\n\nexports.TemplateExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { tag, elements } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('TemplateExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['elements', 'tag'])) {\n      throw new TypeError('Argument to TemplateExpression constructor has wrong keys: expected {tag, elements}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof tag === 'undefined' || tag !== null && (isNotExpression(tag))) {\n      throw new TypeError('Field \"tag\" of TemplateExpression constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(tag) + ')');\n    }\n    if (!Array.isArray(elements) || elements.some(f => typeof f === 'undefined' || (isNotExpression(f)) && (f.type !== 'TemplateElement'))) {\n      throw new TypeError('Field \"elements\" of TemplateExpression constructor argument is of incorrect type (expected [one of {Expression, TemplateElement}], got ' + printActualType(elements) + ')');\n    }\n    this.type = 'TemplateExpression';\n    this.tag = tag;\n    this.elements = elements;\n  }\n};\n\nexports.ThisExpression = class {\n  constructor(...extraArgs) {\n    if (extraArgs.length > 1 || extraArgs.length === 1 && (typeof extraArgs[0] !== 'object' || extraArgs[0] === null || Object.keys(extraArgs[0]).length !== 0)) {\n      throw new TypeError('ThisExpression constructor takes no arguments');\n    }\n    this.type = 'ThisExpression';\n  }\n};\n\nexports.ThrowStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('ThrowStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to ThrowStatement constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of ThrowStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'ThrowStatement';\n    this.expression = expression;\n  }\n};\n\nexports.TryCatchStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { body, catchClause } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('TryCatchStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'catchClause'])) {\n      throw new TypeError('Argument to TryCatchStatement constructor has wrong keys: expected {body, catchClause}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof body === 'undefined' || body.type !== 'Block') {\n      throw new TypeError('Field \"body\" of TryCatchStatement constructor argument is of incorrect type (expected Block, got ' + printActualType(body) + ')');\n    }\n    if (typeof catchClause === 'undefined' || catchClause.type !== 'CatchClause') {\n      throw new TypeError('Field \"catchClause\" of TryCatchStatement constructor argument is of incorrect type (expected CatchClause, got ' + printActualType(catchClause) + ')');\n    }\n    this.type = 'TryCatchStatement';\n    this.body = body;\n    this.catchClause = catchClause;\n  }\n};\n\nexports.TryFinallyStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { body, catchClause, finalizer } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('TryFinallyStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'catchClause', 'finalizer'])) {\n      throw new TypeError('Argument to TryFinallyStatement constructor has wrong keys: expected {body, catchClause, finalizer}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof body === 'undefined' || body.type !== 'Block') {\n      throw new TypeError('Field \"body\" of TryFinallyStatement constructor argument is of incorrect type (expected Block, got ' + printActualType(body) + ')');\n    }\n    if (typeof catchClause === 'undefined' || catchClause !== null && (catchClause.type !== 'CatchClause')) {\n      throw new TypeError('Field \"catchClause\" of TryFinallyStatement constructor argument is of incorrect type (expected null or CatchClause, got ' + printActualType(catchClause) + ')');\n    }\n    if (typeof finalizer === 'undefined' || finalizer.type !== 'Block') {\n      throw new TypeError('Field \"finalizer\" of TryFinallyStatement constructor argument is of incorrect type (expected Block, got ' + printActualType(finalizer) + ')');\n    }\n    this.type = 'TryFinallyStatement';\n    this.body = body;\n    this.catchClause = catchClause;\n    this.finalizer = finalizer;\n  }\n};\n\nexports.UnaryExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { operator, operand } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('UnaryExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['operand', 'operator'])) {\n      throw new TypeError('Argument to UnaryExpression constructor has wrong keys: expected {operator, operand}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof operator === 'undefined' || ['+', '-', '!', '~', 'typeof', 'void', 'delete'].indexOf(operator) === -1) {\n      throw new TypeError('Field \"operator\" of UnaryExpression constructor argument is of incorrect type (expected one of {\"+\", \"-\", \"!\", \"~\", \"typeof\", \"void\", \"delete\"}, got ' + printActualType(operator) + ')');\n    }\n    if (isNotExpression(operand)) {\n      throw new TypeError('Field \"operand\" of UnaryExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(operand) + ')');\n    }\n    this.type = 'UnaryExpression';\n    this.operator = operator;\n    this.operand = operand;\n  }\n};\n\nexports.UpdateExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { isPrefix, operator, operand } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('UpdateExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['isPrefix', 'operand', 'operator'])) {\n      throw new TypeError('Argument to UpdateExpression constructor has wrong keys: expected {isPrefix, operator, operand}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof isPrefix !== 'boolean') {\n      throw new TypeError('Field \"isPrefix\" of UpdateExpression constructor argument is of incorrect type (expected boolean, got ' + printActualType(isPrefix) + ')');\n    }\n    if (typeof operator === 'undefined' || ['++', '--'].indexOf(operator) === -1) {\n      throw new TypeError('Field \"operator\" of UpdateExpression constructor argument is of incorrect type (expected one of {\"++\", \"--\"}, got ' + printActualType(operator) + ')');\n    }\n    if (typeof operand === 'undefined' || (operand.type !== 'AssignmentTargetIdentifier') && ((operand.type !== 'ComputedMemberAssignmentTarget') && (operand.type !== 'StaticMemberAssignmentTarget'))) {\n      throw new TypeError('Field \"operand\" of UpdateExpression constructor argument is of incorrect type (expected one of {AssignmentTargetIdentifier, ComputedMemberAssignmentTarget, StaticMemberAssignmentTarget}, got ' + printActualType(operand) + ')');\n    }\n    this.type = 'UpdateExpression';\n    this.isPrefix = isPrefix;\n    this.operator = operator;\n    this.operand = operand;\n  }\n};\n\nexports.VariableDeclaration = class {\n  constructor(arg, ...extraArgs) {\n    const { kind, declarators } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('VariableDeclaration constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['declarators', 'kind'])) {\n      throw new TypeError('Argument to VariableDeclaration constructor has wrong keys: expected {kind, declarators}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof kind === 'undefined' || ['var', 'let', 'const'].indexOf(kind) === -1) {\n      throw new TypeError('Field \"kind\" of VariableDeclaration constructor argument is of incorrect type (expected one of {\"var\", \"let\", \"const\"}, got ' + printActualType(kind) + ')');\n    }\n    if (!Array.isArray(declarators) || declarators.some(f => typeof f === 'undefined' || f.type !== 'VariableDeclarator')) {\n      throw new TypeError('Field \"declarators\" of VariableDeclaration constructor argument is of incorrect type (expected [VariableDeclarator], got ' + printActualType(declarators) + ')');\n    }\n    this.type = 'VariableDeclaration';\n    this.kind = kind;\n    this.declarators = declarators;\n  }\n};\n\nexports.VariableDeclarationStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { declaration } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('VariableDeclarationStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['declaration'])) {\n      throw new TypeError('Argument to VariableDeclarationStatement constructor has wrong keys: expected {declaration}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof declaration === 'undefined' || declaration.type !== 'VariableDeclaration') {\n      throw new TypeError('Field \"declaration\" of VariableDeclarationStatement constructor argument is of incorrect type (expected VariableDeclaration, got ' + printActualType(declaration) + ')');\n    }\n    this.type = 'VariableDeclarationStatement';\n    this.declaration = declaration;\n  }\n};\n\nexports.VariableDeclarator = class {\n  constructor(arg, ...extraArgs) {\n    const { binding, init } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('VariableDeclarator constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['binding', 'init'])) {\n      throw new TypeError('Argument to VariableDeclarator constructor has wrong keys: expected {binding, init}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof binding === 'undefined' || (binding.type !== 'BindingIdentifier') && ((binding.type !== 'ArrayBinding') && (binding.type !== 'ObjectBinding'))) {\n      throw new TypeError('Field \"binding\" of VariableDeclarator constructor argument is of incorrect type (expected one of {BindingIdentifier, ArrayBinding, ObjectBinding}, got ' + printActualType(binding) + ')');\n    }\n    if (typeof init === 'undefined' || init !== null && (isNotExpression(init))) {\n      throw new TypeError('Field \"init\" of VariableDeclarator constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(init) + ')');\n    }\n    this.type = 'VariableDeclarator';\n    this.binding = binding;\n    this.init = init;\n  }\n};\n\nexports.WhileStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { test, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('WhileStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'test'])) {\n      throw new TypeError('Argument to WhileStatement constructor has wrong keys: expected {test, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(test)) {\n      throw new TypeError('Field \"test\" of WhileStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(test) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of WhileStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'WhileStatement';\n    this.test = test;\n    this.body = body;\n  }\n};\n\nexports.WithStatement = class {\n  constructor(arg, ...extraArgs) {\n    const { object, body } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('WithStatement constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['body', 'object'])) {\n      throw new TypeError('Argument to WithStatement constructor has wrong keys: expected {object, body}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(object)) {\n      throw new TypeError('Field \"object\" of WithStatement constructor argument is of incorrect type (expected Expression, got ' + printActualType(object) + ')');\n    }\n    if (isNotStatement(body)) {\n      throw new TypeError('Field \"body\" of WithStatement constructor argument is of incorrect type (expected Statement, got ' + printActualType(body) + ')');\n    }\n    this.type = 'WithStatement';\n    this.object = object;\n    this.body = body;\n  }\n};\n\nexports.YieldExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('YieldExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to YieldExpression constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (typeof expression === 'undefined' || expression !== null && (isNotExpression(expression))) {\n      throw new TypeError('Field \"expression\" of YieldExpression constructor argument is of incorrect type (expected null or Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'YieldExpression';\n    this.expression = expression;\n  }\n};\n\nexports.YieldGeneratorExpression = class {\n  constructor(arg, ...extraArgs) {\n    const { expression } = arg;\n    if (extraArgs.length !== 0) {\n      throw new TypeError('YieldGeneratorExpression constructor takes exactly one argument (' + (1 + extraArgs.length) + ' given)');\n    }\n    if (!arrayEquals(Object.keys(arg).sort(), ['expression'])) {\n      throw new TypeError('Argument to YieldGeneratorExpression constructor has wrong keys: expected {expression}, got {' + Object.keys(arg).join(', ') + '}');\n    }\n    if (isNotExpression(expression)) {\n      throw new TypeError('Field \"expression\" of YieldGeneratorExpression constructor argument is of incorrect type (expected Expression, got ' + printActualType(expression) + ')');\n    }\n    this.type = 'YieldGeneratorExpression';\n    this.expression = expression;\n  }\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}