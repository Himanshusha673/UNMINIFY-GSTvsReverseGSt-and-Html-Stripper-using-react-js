{"ast":null,"code":"/**\n * Copyright 2016 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst {\n  GenericParser\n} = require('./parser');\nconst {\n  JsError\n} = require('./tokenizer');\nconst {\n  EarlyErrorChecker\n} = require('./early-errors');\nconst {\n  isLineTerminator\n} = require('./utils');\nconst {\n  Tokenizer,\n  TokenClass,\n  TokenType\n} = require('./tokenizer');\nclass ParserWithLocation extends GenericParser {\n  constructor(source) {\n    super(source);\n    this.locations = new WeakMap();\n    this.comments = [];\n  }\n  startNode() {\n    return this.getLocation();\n  }\n  finishNode(node, start) {\n    if (node.type === 'Script' || node.type === 'Module') {\n      this.locations.set(node, {\n        start: {\n          line: 1,\n          column: 0,\n          offset: 0\n        },\n        end: this.getLocation()\n      });\n      return node;\n    }\n    if (node.type === 'TemplateExpression') {\n      // Adjust TemplateElements to not include surrounding backticks or braces\n      for (let i = 0; i < node.elements.length; i += 2) {\n        const endAdjustment = i < node.elements.length - 1 ? 2 : 1; // discard '${' or '`' respectively\n        const element = node.elements[i];\n        const location = this.locations.get(element);\n        this.locations.set(element, {\n          start: {\n            line: location.start.line,\n            column: location.start.column + 1,\n            offset: location.start.offset + 1\n          },\n          // discard '}' or '`'\n          end: {\n            line: location.end.line,\n            column: location.end.column - endAdjustment,\n            offset: location.end.offset - endAdjustment\n          }\n        });\n      }\n    }\n    this.locations.set(node, {\n      start,\n      end: this.getLastTokenEndLocation()\n    });\n    return node;\n  }\n  copyNode(src, dest) {\n    this.locations.set(dest, this.locations.get(src)); // todo check undefined\n    return dest;\n  }\n  skipSingleLineComment(offset) {\n    // We're actually extending the *tokenizer*, here.\n    const start = {\n      line: this.line + 1,\n      column: this.index - this.lineStart,\n      offset: this.index\n    };\n    const c = this.source[this.index];\n    const type = c === '/' ? 'SingleLine' : c === '<' ? 'HTMLOpen' : 'HTMLClose';\n    super.skipSingleLineComment(offset);\n    const end = {\n      line: this.line + 1,\n      column: this.index - this.lineStart,\n      offset: this.index\n    };\n    const trailingLineTerminatorCharacters = this.source[this.index - 2] === '\\r' ? 2 : isLineTerminator(this.source.charCodeAt(this.index - 1)) ? 1 : 0;\n    const text = this.source.substring(start.offset + offset, end.offset - trailingLineTerminatorCharacters);\n    this.comments.push({\n      text,\n      type,\n      start,\n      end\n    });\n  }\n  skipMultiLineComment() {\n    const start = {\n      line: this.line + 1,\n      column: this.index - this.lineStart,\n      offset: this.index\n    };\n    const type = 'MultiLine';\n    const retval = super.skipMultiLineComment();\n    const end = {\n      line: this.line + 1,\n      column: this.index - this.lineStart,\n      offset: this.index\n    };\n    const text = this.source.substring(start.offset + 2, end.offset - 2);\n    this.comments.push({\n      text,\n      type,\n      start,\n      end\n    });\n    return retval;\n  }\n}\nfunction generateInterface(parsingFunctionName) {\n  return function parse(code, {\n    earlyErrors = true\n  } = {}) {\n    let parser = new GenericParser(code);\n    let tree = parser[parsingFunctionName]();\n    if (earlyErrors) {\n      let errors = EarlyErrorChecker.check(tree);\n      // for now, just throw the first error; we will handle multiple errors later\n      if (errors.length > 0) {\n        throw new JsError(0, 1, 0, errors[0].message);\n      }\n    }\n    return tree;\n  };\n}\nfunction generateInterfaceWithLocation(parsingFunctionName) {\n  return function parse(code, {\n    earlyErrors = true\n  } = {}) {\n    let parser = new ParserWithLocation(code);\n    let tree = parser[parsingFunctionName]();\n    if (earlyErrors) {\n      let errors = EarlyErrorChecker.check(tree);\n      // for now, just throw the first error; we will handle multiple errors later\n      if (errors.length > 0) {\n        let {\n          node,\n          message\n        } = errors[0];\n        let {\n          offset,\n          line,\n          column\n        } = parser.locations.get(node).start;\n        throw new JsError(offset, line, column, message);\n      }\n    }\n    return {\n      tree,\n      locations: parser.locations,\n      comments: parser.comments\n    };\n  };\n}\nconst parseScript = generateInterface('parseScript');\nconst parseModule = generateInterface('parseModule');\nconst parseModuleWithLocation = generateInterfaceWithLocation('parseModule');\nconst parseScriptWithLocation = generateInterfaceWithLocation('parseScript');\nmodule.exports = {\n  default: parseScript,\n  parseScript,\n  parseModule,\n  parseModuleWithLocation,\n  parseScriptWithLocation,\n  EarlyErrorChecker,\n  GenericParser,\n  ParserWithLocation,\n  Tokenizer,\n  TokenClass,\n  TokenType\n};","map":{"version":3,"names":["GenericParser","require","JsError","EarlyErrorChecker","isLineTerminator","Tokenizer","TokenClass","TokenType","ParserWithLocation","constructor","source","locations","WeakMap","comments","startNode","getLocation","finishNode","node","start","type","set","line","column","offset","end","i","elements","length","endAdjustment","element","location","get","getLastTokenEndLocation","copyNode","src","dest","skipSingleLineComment","index","lineStart","c","trailingLineTerminatorCharacters","charCodeAt","text","substring","push","skipMultiLineComment","retval","generateInterface","parsingFunctionName","parse","code","earlyErrors","parser","tree","errors","check","message","generateInterfaceWithLocation","parseScript","parseModule","parseModuleWithLocation","parseScriptWithLocation","module","exports","default"],"sources":["/Users/binarychai3/Documents/React js Projects/first-react/node_modules/shift-parser/src/index.js"],"sourcesContent":["/**\n * Copyright 2016 Shape Security, Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\")\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nconst { GenericParser } = require('./parser');\nconst { JsError } = require('./tokenizer');\nconst { EarlyErrorChecker } = require('./early-errors');\nconst { isLineTerminator } = require('./utils');\nconst { Tokenizer, TokenClass, TokenType } = require('./tokenizer');\n\nclass ParserWithLocation extends GenericParser {\n  constructor(source) {\n    super(source);\n    this.locations = new WeakMap;\n    this.comments = [];\n  }\n\n  startNode() {\n    return this.getLocation();\n  }\n\n  finishNode(node, start) {\n    if (node.type === 'Script' || node.type === 'Module') {\n      this.locations.set(node, {\n        start: { line: 1, column: 0, offset: 0 },\n        end: this.getLocation(),\n      });\n      return node;\n    }\n    if (node.type === 'TemplateExpression') {\n      // Adjust TemplateElements to not include surrounding backticks or braces\n      for (let i = 0; i < node.elements.length; i += 2) {\n        const endAdjustment = i < node.elements.length - 1 ? 2 : 1; // discard '${' or '`' respectively\n        const element = node.elements[i];\n        const location = this.locations.get(element);\n        this.locations.set(element, {\n          start: { line: location.start.line, column: location.start.column + 1, offset: location.start.offset + 1 }, // discard '}' or '`'\n          end: { line: location.end.line, column: location.end.column - endAdjustment, offset: location.end.offset - endAdjustment },\n        });\n      }\n    }\n    this.locations.set(node, {\n      start,\n      end: this.getLastTokenEndLocation(),\n    });\n    return node;\n  }\n\n  copyNode(src, dest) {\n    this.locations.set(dest, this.locations.get(src)); // todo check undefined\n    return dest;\n  }\n\n  skipSingleLineComment(offset) {\n    // We're actually extending the *tokenizer*, here.\n    const start = {\n      line: this.line + 1,\n      column: this.index - this.lineStart,\n      offset: this.index,\n    };\n    const c = this.source[this.index];\n    const type = c === '/' ? 'SingleLine' : c === '<' ? 'HTMLOpen' : 'HTMLClose';\n\n    super.skipSingleLineComment(offset);\n\n    const end = {\n      line: this.line + 1,\n      column: this.index - this.lineStart,\n      offset: this.index,\n    };\n    const trailingLineTerminatorCharacters = this.source[this.index - 2] === '\\r' ? 2 : isLineTerminator(this.source.charCodeAt(this.index - 1)) ? 1 : 0;\n    const text = this.source.substring(start.offset + offset, end.offset - trailingLineTerminatorCharacters);\n\n    this.comments.push({ text, type, start, end });\n  }\n\n  skipMultiLineComment() {\n    const start = {\n      line: this.line + 1,\n      column: this.index - this.lineStart,\n      offset: this.index,\n    };\n    const type = 'MultiLine';\n\n    const retval = super.skipMultiLineComment();\n\n    const end = {\n      line: this.line + 1,\n      column: this.index - this.lineStart,\n      offset: this.index,\n    };\n    const text = this.source.substring(start.offset + 2, end.offset - 2);\n\n    this.comments.push({ text, type, start, end });\n\n    return retval;\n  }\n}\n\nfunction generateInterface(parsingFunctionName) {\n  return function parse(code, { earlyErrors = true } = {}) {\n    let parser = new GenericParser(code);\n    let tree = parser[parsingFunctionName]();\n    if (earlyErrors) {\n      let errors = EarlyErrorChecker.check(tree);\n      // for now, just throw the first error; we will handle multiple errors later\n      if (errors.length > 0) {\n        throw new JsError(0, 1, 0, errors[0].message);\n      }\n    }\n    return tree;\n  };\n}\n\nfunction generateInterfaceWithLocation(parsingFunctionName) {\n  return function parse(code, { earlyErrors = true } = {}) {\n    let parser = new ParserWithLocation(code);\n    let tree = parser[parsingFunctionName]();\n    if (earlyErrors) {\n      let errors = EarlyErrorChecker.check(tree);\n      // for now, just throw the first error; we will handle multiple errors later\n      if (errors.length > 0) {\n        let { node, message } = errors[0];\n        let { offset, line, column } = parser.locations.get(node).start;\n        throw new JsError(offset, line, column, message);\n      }\n    }\n    return { tree, locations: parser.locations, comments: parser.comments };\n  };\n}\n\nconst parseScript = generateInterface('parseScript');\nconst parseModule = generateInterface('parseModule');\nconst parseModuleWithLocation = generateInterfaceWithLocation('parseModule');\nconst parseScriptWithLocation = generateInterfaceWithLocation('parseScript');\n\nmodule.exports = {\n  default: parseScript,\n  parseScript,\n  parseModule,\n  parseModuleWithLocation,\n  parseScriptWithLocation,\n  EarlyErrorChecker,\n  GenericParser,\n  ParserWithLocation,\n  Tokenizer,\n  TokenClass,\n  TokenType,\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"script","externalDependencies":[]}